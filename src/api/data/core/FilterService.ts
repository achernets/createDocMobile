/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import Int64 from "node-int64";
import * as thrift from "thrift";
import * as core from "./";
import * as DocFilter from "./DocFilter";
import * as CustomFilterItem from "./CustomFilterItem";
import * as DocFiltersWithSortColumn from "./DocFiltersWithSortColumn";
export interface IGetAllCustomDocFiltersArgsArgs {
    token: string;
    filter: core.KazFilter;
    personal: boolean;
}
export class GetAllCustomDocFiltersArgs {
    public token: string;
    public filter: core.KazFilter;
    public personal: boolean;
    constructor(args: IGetAllCustomDocFiltersArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
        if (args != null && args.personal != null) {
            this.personal = args.personal;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[personal] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllCustomDocFiltersArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        if (this.personal != null) {
            output.writeFieldBegin("personal", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.personal);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllCustomDocFiltersArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_1: string = input.readString();
                        _args.token = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_2: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_2;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_3: boolean = input.readBool();
                        _args.personal = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined && _args.personal !== undefined) {
            return new GetAllCustomDocFiltersArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllCustomDocFiltersArgs from input");
        }
    }
}
export interface ICreateOrUpdateCustomDocFilterArgsArgs {
    token: string;
    filter: DocFilter.DocFilter;
    customFilterItems: Array<string>;
}
export class CreateOrUpdateCustomDocFilterArgs {
    public token: string;
    public filter: DocFilter.DocFilter;
    public customFilterItems: Array<string>;
    constructor(args: ICreateOrUpdateCustomDocFilterArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
        if (args != null && args.customFilterItems != null) {
            this.customFilterItems = args.customFilterItems;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[customFilterItems] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateCustomDocFilterArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        if (this.customFilterItems != null) {
            output.writeFieldBegin("customFilterItems", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.customFilterItems.length);
            this.customFilterItems.forEach((value_4: string): void => {
                output.writeString(value_4);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateCustomDocFilterArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_5: string = input.readString();
                        _args.token = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_6: DocFilter.DocFilter = DocFilter.DocFilter.read(input);
                        _args.filter = value_6;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_7: Array<string> = new Array<string>();
                        const metadata_1: thrift.TList = input.readListBegin();
                        const size_1: number = metadata_1.size;
                        for (let i_1: number = 0; i_1 < size_1; i_1++) {
                            const value_8: string = input.readString();
                            value_7.push(value_8);
                        }
                        input.readListEnd();
                        _args.customFilterItems = value_7;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined && _args.customFilterItems !== undefined) {
            return new CreateOrUpdateCustomDocFilterArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateOrUpdateCustomDocFilterArgs from input");
        }
    }
}
export interface IRemoveCustomDocFilterArgsArgs {
    token: string;
    docFilterId: string;
}
export class RemoveCustomDocFilterArgs {
    public token: string;
    public docFilterId: string;
    constructor(args: IRemoveCustomDocFilterArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docFilterId != null) {
            this.docFilterId = args.docFilterId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docFilterId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveCustomDocFilterArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docFilterId != null) {
            output.writeFieldBegin("docFilterId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.docFilterId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveCustomDocFilterArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_9: string = input.readString();
                        _args.token = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_10: string = input.readString();
                        _args.docFilterId = value_10;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docFilterId !== undefined) {
            return new RemoveCustomDocFilterArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveCustomDocFilterArgs from input");
        }
    }
}
export interface ICreateOrUpdateCustomFilterItemArgsArgs {
    token: string;
    filterItem: CustomFilterItem.CustomFilterItem;
}
export class CreateOrUpdateCustomFilterItemArgs {
    public token: string;
    public filterItem: CustomFilterItem.CustomFilterItem;
    constructor(args: ICreateOrUpdateCustomFilterItemArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filterItem != null) {
            this.filterItem = args.filterItem;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filterItem] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateCustomFilterItemArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filterItem != null) {
            output.writeFieldBegin("filterItem", thrift.Thrift.Type.STRUCT, 2);
            this.filterItem.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateCustomFilterItemArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_11: string = input.readString();
                        _args.token = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_12: CustomFilterItem.CustomFilterItem = CustomFilterItem.CustomFilterItem.read(input);
                        _args.filterItem = value_12;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filterItem !== undefined) {
            return new CreateOrUpdateCustomFilterItemArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateOrUpdateCustomFilterItemArgs from input");
        }
    }
}
export interface IRemoveCustomFilterItemArgsArgs {
    token: string;
    filterItemId: string;
}
export class RemoveCustomFilterItemArgs {
    public token: string;
    public filterItemId: string;
    constructor(args: IRemoveCustomFilterItemArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filterItemId != null) {
            this.filterItemId = args.filterItemId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filterItemId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveCustomFilterItemArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filterItemId != null) {
            output.writeFieldBegin("filterItemId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.filterItemId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveCustomFilterItemArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_13: string = input.readString();
                        _args.token = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_14: string = input.readString();
                        _args.filterItemId = value_14;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filterItemId !== undefined) {
            return new RemoveCustomFilterItemArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveCustomFilterItemArgs from input");
        }
    }
}
export interface IAddDocFiltersToUserGroupsArgsArgs {
    token: string;
    docFilterIds: Array<string>;
    userOrGroups: Array<core.UserOrGroup>;
}
export class AddDocFiltersToUserGroupsArgs {
    public token: string;
    public docFilterIds: Array<string>;
    public userOrGroups: Array<core.UserOrGroup>;
    constructor(args: IAddDocFiltersToUserGroupsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docFilterIds != null) {
            this.docFilterIds = args.docFilterIds;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docFilterIds] is unset!");
        }
        if (args != null && args.userOrGroups != null) {
            this.userOrGroups = args.userOrGroups;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userOrGroups] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddDocFiltersToUserGroupsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docFilterIds != null) {
            output.writeFieldBegin("docFilterIds", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.docFilterIds.length);
            this.docFilterIds.forEach((value_15: string): void => {
                output.writeString(value_15);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.userOrGroups != null) {
            output.writeFieldBegin("userOrGroups", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.userOrGroups.length);
            this.userOrGroups.forEach((value_16: core.UserOrGroup): void => {
                value_16.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddDocFiltersToUserGroupsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_17: string = input.readString();
                        _args.token = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_18: Array<string> = new Array<string>();
                        const metadata_2: thrift.TList = input.readListBegin();
                        const size_2: number = metadata_2.size;
                        for (let i_2: number = 0; i_2 < size_2; i_2++) {
                            const value_19: string = input.readString();
                            value_18.push(value_19);
                        }
                        input.readListEnd();
                        _args.docFilterIds = value_18;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_20: Array<core.UserOrGroup> = new Array<core.UserOrGroup>();
                        const metadata_3: thrift.TList = input.readListBegin();
                        const size_3: number = metadata_3.size;
                        for (let i_3: number = 0; i_3 < size_3; i_3++) {
                            const value_21: core.UserOrGroup = core.UserOrGroup.read(input);
                            value_20.push(value_21);
                        }
                        input.readListEnd();
                        _args.userOrGroups = value_20;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docFilterIds !== undefined && _args.userOrGroups !== undefined) {
            return new AddDocFiltersToUserGroupsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddDocFiltersToUserGroupsArgs from input");
        }
    }
}
export interface IRemoveDocFiltersFromUserGroupsArgsArgs {
    token: string;
    docFilterIds: Array<string>;
    userOrGroups: Array<core.UserOrGroup>;
}
export class RemoveDocFiltersFromUserGroupsArgs {
    public token: string;
    public docFilterIds: Array<string>;
    public userOrGroups: Array<core.UserOrGroup>;
    constructor(args: IRemoveDocFiltersFromUserGroupsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docFilterIds != null) {
            this.docFilterIds = args.docFilterIds;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docFilterIds] is unset!");
        }
        if (args != null && args.userOrGroups != null) {
            this.userOrGroups = args.userOrGroups;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userOrGroups] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveDocFiltersFromUserGroupsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docFilterIds != null) {
            output.writeFieldBegin("docFilterIds", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.docFilterIds.length);
            this.docFilterIds.forEach((value_22: string): void => {
                output.writeString(value_22);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.userOrGroups != null) {
            output.writeFieldBegin("userOrGroups", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.userOrGroups.length);
            this.userOrGroups.forEach((value_23: core.UserOrGroup): void => {
                value_23.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveDocFiltersFromUserGroupsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_24: string = input.readString();
                        _args.token = value_24;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_25: Array<string> = new Array<string>();
                        const metadata_4: thrift.TList = input.readListBegin();
                        const size_4: number = metadata_4.size;
                        for (let i_4: number = 0; i_4 < size_4; i_4++) {
                            const value_26: string = input.readString();
                            value_25.push(value_26);
                        }
                        input.readListEnd();
                        _args.docFilterIds = value_25;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_27: Array<core.UserOrGroup> = new Array<core.UserOrGroup>();
                        const metadata_5: thrift.TList = input.readListBegin();
                        const size_5: number = metadata_5.size;
                        for (let i_5: number = 0; i_5 < size_5; i_5++) {
                            const value_28: core.UserOrGroup = core.UserOrGroup.read(input);
                            value_27.push(value_28);
                        }
                        input.readListEnd();
                        _args.userOrGroups = value_27;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docFilterIds !== undefined && _args.userOrGroups !== undefined) {
            return new RemoveDocFiltersFromUserGroupsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveDocFiltersFromUserGroupsArgs from input");
        }
    }
}
export interface IGetAllDocFiltersByUserOrGroupArgsArgs {
    token: string;
    type: core.UserOrGroupType;
    userOrGroupId: string;
    filter: core.KazFilter;
}
export class GetAllDocFiltersByUserOrGroupArgs {
    public token: string;
    public type: core.UserOrGroupType;
    public userOrGroupId: string;
    public filter: core.KazFilter;
    constructor(args: IGetAllDocFiltersByUserOrGroupArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.type != null) {
            this.type = args.type;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[type] is unset!");
        }
        if (args != null && args.userOrGroupId != null) {
            this.userOrGroupId = args.userOrGroupId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userOrGroupId] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocFiltersByUserOrGroupArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.type != null) {
            output.writeFieldBegin("type", thrift.Thrift.Type.I32, 2);
            output.writeI32(this.type);
            output.writeFieldEnd();
        }
        if (this.userOrGroupId != null) {
            output.writeFieldBegin("userOrGroupId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.userOrGroupId);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 4);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocFiltersByUserOrGroupArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_29: string = input.readString();
                        _args.token = value_29;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_30: core.UserOrGroupType = input.readI32();
                        _args.type = value_30;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_31: string = input.readString();
                        _args.userOrGroupId = value_31;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_32: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_32;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.type !== undefined && _args.userOrGroupId !== undefined && _args.filter !== undefined) {
            return new GetAllDocFiltersByUserOrGroupArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllDocFiltersByUserOrGroupArgs from input");
        }
    }
}
export interface IGetAllUserOrGroupsByDocFilterIdArgsArgs {
    token: string;
    docFilterId: string;
    filter: core.KazFilter;
}
export class GetAllUserOrGroupsByDocFilterIdArgs {
    public token: string;
    public docFilterId: string;
    public filter: core.KazFilter;
    constructor(args: IGetAllUserOrGroupsByDocFilterIdArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docFilterId != null) {
            this.docFilterId = args.docFilterId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docFilterId] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllUserOrGroupsByDocFilterIdArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docFilterId != null) {
            output.writeFieldBegin("docFilterId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.docFilterId);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 3);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllUserOrGroupsByDocFilterIdArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_33: string = input.readString();
                        _args.token = value_33;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_34: string = input.readString();
                        _args.docFilterId = value_34;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_35: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_35;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docFilterId !== undefined && _args.filter !== undefined) {
            return new GetAllUserOrGroupsByDocFilterIdArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllUserOrGroupsByDocFilterIdArgs from input");
        }
    }
}
export interface IExportDocFiltersArgsArgs {
    token: string;
    docFilterIds: Array<string>;
}
export class ExportDocFiltersArgs {
    public token: string;
    public docFilterIds: Array<string>;
    constructor(args: IExportDocFiltersArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docFilterIds != null) {
            this.docFilterIds = args.docFilterIds;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docFilterIds] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExportDocFiltersArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docFilterIds != null) {
            output.writeFieldBegin("docFilterIds", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.docFilterIds.length);
            this.docFilterIds.forEach((value_36: string): void => {
                output.writeString(value_36);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExportDocFiltersArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_37: string = input.readString();
                        _args.token = value_37;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_38: Array<string> = new Array<string>();
                        const metadata_6: thrift.TList = input.readListBegin();
                        const size_6: number = metadata_6.size;
                        for (let i_6: number = 0; i_6 < size_6; i_6++) {
                            const value_39: string = input.readString();
                            value_38.push(value_39);
                        }
                        input.readListEnd();
                        _args.docFilterIds = value_38;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docFilterIds !== undefined) {
            return new ExportDocFiltersArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExportDocFiltersArgs from input");
        }
    }
}
export interface IImportDocFiltersArgsArgs {
    token: string;
    json: Buffer;
    clearExistFilters: boolean;
}
export class ImportDocFiltersArgs {
    public token: string;
    public json: Buffer;
    public clearExistFilters: boolean;
    constructor(args: IImportDocFiltersArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.json != null) {
            this.json = args.json;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[json] is unset!");
        }
        if (args != null && args.clearExistFilters != null) {
            this.clearExistFilters = args.clearExistFilters;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[clearExistFilters] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ImportDocFiltersArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.json != null) {
            output.writeFieldBegin("json", thrift.Thrift.Type.STRING, 2);
            output.writeBinary(this.json);
            output.writeFieldEnd();
        }
        if (this.clearExistFilters != null) {
            output.writeFieldBegin("clearExistFilters", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.clearExistFilters);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ImportDocFiltersArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_40: string = input.readString();
                        _args.token = value_40;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_41: Buffer = input.readBinary();
                        _args.json = value_41;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_42: boolean = input.readBool();
                        _args.clearExistFilters = value_42;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.json !== undefined && _args.clearExistFilters !== undefined) {
            return new ImportDocFiltersArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ImportDocFiltersArgs from input");
        }
    }
}
export interface IGetDocFilterUserDefineListArgsArgs {
    token: string;
    filter: core.KazFilter;
}
export class GetDocFilterUserDefineListArgs {
    public token: string;
    public filter: core.KazFilter;
    constructor(args: IGetDocFilterUserDefineListArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocFilterUserDefineListArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocFilterUserDefineListArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_43: string = input.readString();
                        _args.token = value_43;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_44: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_44;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetDocFilterUserDefineListArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetDocFilterUserDefineListArgs from input");
        }
    }
}
export interface IChangeDocFilterUserDefineArgsArgs {
    token: string;
    toUpdate: Array<DocFilter.DocFilter>;
    toRemove: Array<string>;
}
export class ChangeDocFilterUserDefineArgs {
    public token: string;
    public toUpdate: Array<DocFilter.DocFilter>;
    public toRemove: Array<string>;
    constructor(args: IChangeDocFilterUserDefineArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.toUpdate != null) {
            this.toUpdate = args.toUpdate;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toUpdate] is unset!");
        }
        if (args != null && args.toRemove != null) {
            this.toRemove = args.toRemove;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toRemove] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeDocFilterUserDefineArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.toUpdate != null) {
            output.writeFieldBegin("toUpdate", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.toUpdate.length);
            this.toUpdate.forEach((value_45: DocFilter.DocFilter): void => {
                value_45.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.toRemove != null) {
            output.writeFieldBegin("toRemove", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.toRemove.length);
            this.toRemove.forEach((value_46: string): void => {
                output.writeString(value_46);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeDocFilterUserDefineArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_47: string = input.readString();
                        _args.token = value_47;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_48: Array<DocFilter.DocFilter> = new Array<DocFilter.DocFilter>();
                        const metadata_7: thrift.TList = input.readListBegin();
                        const size_7: number = metadata_7.size;
                        for (let i_7: number = 0; i_7 < size_7; i_7++) {
                            const value_49: DocFilter.DocFilter = DocFilter.DocFilter.read(input);
                            value_48.push(value_49);
                        }
                        input.readListEnd();
                        _args.toUpdate = value_48;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_50: Array<string> = new Array<string>();
                        const metadata_8: thrift.TList = input.readListBegin();
                        const size_8: number = metadata_8.size;
                        for (let i_8: number = 0; i_8 < size_8; i_8++) {
                            const value_51: string = input.readString();
                            value_50.push(value_51);
                        }
                        input.readListEnd();
                        _args.toRemove = value_50;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.toUpdate !== undefined && _args.toRemove !== undefined) {
            return new ChangeDocFilterUserDefineArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeDocFilterUserDefineArgs from input");
        }
    }
}
export interface ICheckCustomDocFiltersArgsArgs {
    token: string;
    filter: core.KazFilter;
}
export class CheckCustomDocFiltersArgs {
    public token: string;
    public filter: core.KazFilter;
    constructor(args: ICheckCustomDocFiltersArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CheckCustomDocFiltersArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CheckCustomDocFiltersArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_52: string = input.readString();
                        _args.token = value_52;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_53: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_53;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new CheckCustomDocFiltersArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CheckCustomDocFiltersArgs from input");
        }
    }
}
export interface IGetCountAllDeclaredColumnArgsArgs {
    token: string;
    filter: core.KazFilter;
}
export class GetCountAllDeclaredColumnArgs {
    public token: string;
    public filter: core.KazFilter;
    constructor(args: IGetCountAllDeclaredColumnArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllDeclaredColumnArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllDeclaredColumnArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_54: string = input.readString();
                        _args.token = value_54;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_55: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_55;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetCountAllDeclaredColumnArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetCountAllDeclaredColumnArgs from input");
        }
    }
}
export interface IGetAllDeclaredColumnArgsArgs {
    token: string;
    filter: core.KazFilter;
}
export class GetAllDeclaredColumnArgs {
    public token: string;
    public filter: core.KazFilter;
    constructor(args: IGetAllDeclaredColumnArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDeclaredColumnArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDeclaredColumnArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_56: string = input.readString();
                        _args.token = value_56;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_57: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_57;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllDeclaredColumnArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllDeclaredColumnArgs from input");
        }
    }
}
export interface IChangeDeclaredColumnsArgsArgs {
    token: string;
    toUpdate: Array<core.DocColumn>;
    toRemove: Array<string>;
}
export class ChangeDeclaredColumnsArgs {
    public token: string;
    public toUpdate: Array<core.DocColumn>;
    public toRemove: Array<string>;
    constructor(args: IChangeDeclaredColumnsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.toUpdate != null) {
            this.toUpdate = args.toUpdate;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toUpdate] is unset!");
        }
        if (args != null && args.toRemove != null) {
            this.toRemove = args.toRemove;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toRemove] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeDeclaredColumnsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.toUpdate != null) {
            output.writeFieldBegin("toUpdate", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.toUpdate.length);
            this.toUpdate.forEach((value_58: core.DocColumn): void => {
                value_58.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.toRemove != null) {
            output.writeFieldBegin("toRemove", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.toRemove.length);
            this.toRemove.forEach((value_59: string): void => {
                output.writeString(value_59);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeDeclaredColumnsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_60: string = input.readString();
                        _args.token = value_60;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_61: Array<core.DocColumn> = new Array<core.DocColumn>();
                        const metadata_9: thrift.TList = input.readListBegin();
                        const size_9: number = metadata_9.size;
                        for (let i_9: number = 0; i_9 < size_9; i_9++) {
                            const value_62: core.DocColumn = core.DocColumn.read(input);
                            value_61.push(value_62);
                        }
                        input.readListEnd();
                        _args.toUpdate = value_61;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_63: Array<string> = new Array<string>();
                        const metadata_10: thrift.TList = input.readListBegin();
                        const size_10: number = metadata_10.size;
                        for (let i_10: number = 0; i_10 < size_10; i_10++) {
                            const value_64: string = input.readString();
                            value_63.push(value_64);
                        }
                        input.readListEnd();
                        _args.toRemove = value_63;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.toUpdate !== undefined && _args.toRemove !== undefined) {
            return new ChangeDeclaredColumnsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeDeclaredColumnsArgs from input");
        }
    }
}
export interface IChangeUserPreferencesColumnArgsArgs {
    token: string;
    toUpdate: Array<core.DocColumn>;
    toRemove: Array<string>;
    forRegistry: boolean;
}
export class ChangeUserPreferencesColumnArgs {
    public token: string;
    public toUpdate: Array<core.DocColumn>;
    public toRemove: Array<string>;
    public forRegistry: boolean;
    constructor(args: IChangeUserPreferencesColumnArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.toUpdate != null) {
            this.toUpdate = args.toUpdate;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toUpdate] is unset!");
        }
        if (args != null && args.toRemove != null) {
            this.toRemove = args.toRemove;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toRemove] is unset!");
        }
        if (args != null && args.forRegistry != null) {
            this.forRegistry = args.forRegistry;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[forRegistry] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeUserPreferencesColumnArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.toUpdate != null) {
            output.writeFieldBegin("toUpdate", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.toUpdate.length);
            this.toUpdate.forEach((value_65: core.DocColumn): void => {
                value_65.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.toRemove != null) {
            output.writeFieldBegin("toRemove", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.toRemove.length);
            this.toRemove.forEach((value_66: string): void => {
                output.writeString(value_66);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.forRegistry != null) {
            output.writeFieldBegin("forRegistry", thrift.Thrift.Type.BOOL, 4);
            output.writeBool(this.forRegistry);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeUserPreferencesColumnArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_67: string = input.readString();
                        _args.token = value_67;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_68: Array<core.DocColumn> = new Array<core.DocColumn>();
                        const metadata_11: thrift.TList = input.readListBegin();
                        const size_11: number = metadata_11.size;
                        for (let i_11: number = 0; i_11 < size_11; i_11++) {
                            const value_69: core.DocColumn = core.DocColumn.read(input);
                            value_68.push(value_69);
                        }
                        input.readListEnd();
                        _args.toUpdate = value_68;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_70: Array<string> = new Array<string>();
                        const metadata_12: thrift.TList = input.readListBegin();
                        const size_12: number = metadata_12.size;
                        for (let i_12: number = 0; i_12 < size_12; i_12++) {
                            const value_71: string = input.readString();
                            value_70.push(value_71);
                        }
                        input.readListEnd();
                        _args.toRemove = value_70;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_72: boolean = input.readBool();
                        _args.forRegistry = value_72;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.toUpdate !== undefined && _args.toRemove !== undefined && _args.forRegistry !== undefined) {
            return new ChangeUserPreferencesColumnArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeUserPreferencesColumnArgs from input");
        }
    }
}
export interface IGetAllUserPreferencesColumnArgsArgs {
    token: string;
    registryId: string;
    filter: core.KazFilter;
}
export class GetAllUserPreferencesColumnArgs {
    public token: string;
    public registryId: string;
    public filter: core.KazFilter;
    constructor(args: IGetAllUserPreferencesColumnArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.registryId != null) {
            this.registryId = args.registryId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[registryId] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllUserPreferencesColumnArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.registryId != null) {
            output.writeFieldBegin("registryId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.registryId);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 3);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllUserPreferencesColumnArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_73: string = input.readString();
                        _args.token = value_73;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_74: string = input.readString();
                        _args.registryId = value_74;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_75: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_75;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.registryId !== undefined && _args.filter !== undefined) {
            return new GetAllUserPreferencesColumnArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllUserPreferencesColumnArgs from input");
        }
    }
}
export interface IGetAllAggregateColumnsForDocumentsArgsArgs {
    token: string;
    filter: core.KazFilter;
    registryId: string;
}
export class GetAllAggregateColumnsForDocumentsArgs {
    public token: string;
    public filter: core.KazFilter;
    public registryId: string;
    constructor(args: IGetAllAggregateColumnsForDocumentsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
        if (args != null && args.registryId != null) {
            this.registryId = args.registryId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[registryId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllAggregateColumnsForDocumentsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        if (this.registryId != null) {
            output.writeFieldBegin("registryId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.registryId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllAggregateColumnsForDocumentsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_76: string = input.readString();
                        _args.token = value_76;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_77: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_77;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_78: string = input.readString();
                        _args.registryId = value_78;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined && _args.registryId !== undefined) {
            return new GetAllAggregateColumnsForDocumentsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllAggregateColumnsForDocumentsArgs from input");
        }
    }
}
export interface IGetAllColumnsForCustomDocFilterArgsArgs {
    token: string;
    customDocFilterId: string;
    filter: core.KazFilter;
}
export class GetAllColumnsForCustomDocFilterArgs {
    public token: string;
    public customDocFilterId: string;
    public filter: core.KazFilter;
    constructor(args: IGetAllColumnsForCustomDocFilterArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.customDocFilterId != null) {
            this.customDocFilterId = args.customDocFilterId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[customDocFilterId] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllColumnsForCustomDocFilterArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.customDocFilterId != null) {
            output.writeFieldBegin("customDocFilterId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.customDocFilterId);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 3);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllColumnsForCustomDocFilterArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_79: string = input.readString();
                        _args.token = value_79;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_80: string = input.readString();
                        _args.customDocFilterId = value_80;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_81: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_81;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.customDocFilterId !== undefined && _args.filter !== undefined) {
            return new GetAllColumnsForCustomDocFilterArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllColumnsForCustomDocFilterArgs from input");
        }
    }
}
export interface IChangeCustomDocFilterColumnsArgsArgs {
    token: string;
    customDocFilterId: string;
    useDefaultColumns: boolean;
    toSave: Array<core.DocColumn>;
}
export class ChangeCustomDocFilterColumnsArgs {
    public token: string;
    public customDocFilterId: string;
    public useDefaultColumns: boolean;
    public toSave: Array<core.DocColumn>;
    constructor(args: IChangeCustomDocFilterColumnsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.customDocFilterId != null) {
            this.customDocFilterId = args.customDocFilterId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[customDocFilterId] is unset!");
        }
        if (args != null && args.useDefaultColumns != null) {
            this.useDefaultColumns = args.useDefaultColumns;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[useDefaultColumns] is unset!");
        }
        if (args != null && args.toSave != null) {
            this.toSave = args.toSave;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toSave] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeCustomDocFilterColumnsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.customDocFilterId != null) {
            output.writeFieldBegin("customDocFilterId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.customDocFilterId);
            output.writeFieldEnd();
        }
        if (this.useDefaultColumns != null) {
            output.writeFieldBegin("useDefaultColumns", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.useDefaultColumns);
            output.writeFieldEnd();
        }
        if (this.toSave != null) {
            output.writeFieldBegin("toSave", thrift.Thrift.Type.LIST, 4);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.toSave.length);
            this.toSave.forEach((value_82: core.DocColumn): void => {
                value_82.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeCustomDocFilterColumnsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_83: string = input.readString();
                        _args.token = value_83;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_84: string = input.readString();
                        _args.customDocFilterId = value_84;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_85: boolean = input.readBool();
                        _args.useDefaultColumns = value_85;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_86: Array<core.DocColumn> = new Array<core.DocColumn>();
                        const metadata_13: thrift.TList = input.readListBegin();
                        const size_13: number = metadata_13.size;
                        for (let i_13: number = 0; i_13 < size_13; i_13++) {
                            const value_87: core.DocColumn = core.DocColumn.read(input);
                            value_86.push(value_87);
                        }
                        input.readListEnd();
                        _args.toSave = value_86;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.customDocFilterId !== undefined && _args.useDefaultColumns !== undefined && _args.toSave !== undefined) {
            return new ChangeCustomDocFilterColumnsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeCustomDocFilterColumnsArgs from input");
        }
    }
}
export interface IGetAllColumnsForCustomDocFilterWithSortingFieldArgsArgs {
    token: string;
    customDocFilterId: string;
    filter: core.KazFilter;
}
export class GetAllColumnsForCustomDocFilterWithSortingFieldArgs {
    public token: string;
    public customDocFilterId: string;
    public filter: core.KazFilter;
    constructor(args: IGetAllColumnsForCustomDocFilterWithSortingFieldArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.customDocFilterId != null) {
            this.customDocFilterId = args.customDocFilterId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[customDocFilterId] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllColumnsForCustomDocFilterWithSortingFieldArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.customDocFilterId != null) {
            output.writeFieldBegin("customDocFilterId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.customDocFilterId);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 3);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllColumnsForCustomDocFilterWithSortingFieldArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_88: string = input.readString();
                        _args.token = value_88;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_89: string = input.readString();
                        _args.customDocFilterId = value_89;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_90: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_90;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.customDocFilterId !== undefined && _args.filter !== undefined) {
            return new GetAllColumnsForCustomDocFilterWithSortingFieldArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllColumnsForCustomDocFilterWithSortingFieldArgs from input");
        }
    }
}
export interface IChangeCustomDocFilterColumnsAndDefaultSortingFieldArgsArgs {
    token: string;
    customDocFilterId: string;
    useDefaultColumns: boolean;
    toSave: DocFiltersWithSortColumn.DocFiltersWithSortColumn;
}
export class ChangeCustomDocFilterColumnsAndDefaultSortingFieldArgs {
    public token: string;
    public customDocFilterId: string;
    public useDefaultColumns: boolean;
    public toSave: DocFiltersWithSortColumn.DocFiltersWithSortColumn;
    constructor(args: IChangeCustomDocFilterColumnsAndDefaultSortingFieldArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.customDocFilterId != null) {
            this.customDocFilterId = args.customDocFilterId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[customDocFilterId] is unset!");
        }
        if (args != null && args.useDefaultColumns != null) {
            this.useDefaultColumns = args.useDefaultColumns;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[useDefaultColumns] is unset!");
        }
        if (args != null && args.toSave != null) {
            this.toSave = args.toSave;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toSave] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeCustomDocFilterColumnsAndDefaultSortingFieldArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.customDocFilterId != null) {
            output.writeFieldBegin("customDocFilterId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.customDocFilterId);
            output.writeFieldEnd();
        }
        if (this.useDefaultColumns != null) {
            output.writeFieldBegin("useDefaultColumns", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.useDefaultColumns);
            output.writeFieldEnd();
        }
        if (this.toSave != null) {
            output.writeFieldBegin("toSave", thrift.Thrift.Type.STRUCT, 4);
            this.toSave.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeCustomDocFilterColumnsAndDefaultSortingFieldArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_91: string = input.readString();
                        _args.token = value_91;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_92: string = input.readString();
                        _args.customDocFilterId = value_92;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_93: boolean = input.readBool();
                        _args.useDefaultColumns = value_93;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_94: DocFiltersWithSortColumn.DocFiltersWithSortColumn = DocFiltersWithSortColumn.DocFiltersWithSortColumn.read(input);
                        _args.toSave = value_94;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.customDocFilterId !== undefined && _args.useDefaultColumns !== undefined && _args.toSave !== undefined) {
            return new ChangeCustomDocFilterColumnsAndDefaultSortingFieldArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeCustomDocFilterColumnsAndDefaultSortingFieldArgs from input");
        }
    }
}
export interface IGetAllCustomDocFiltersResultArgs {
    success?: Array<DocFilter.DocFilter>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllCustomDocFiltersResult {
    public success?: Array<DocFilter.DocFilter>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllCustomDocFiltersResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllCustomDocFiltersResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_95: DocFilter.DocFilter): void => {
                value_95.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllCustomDocFiltersResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_96: Array<DocFilter.DocFilter> = new Array<DocFilter.DocFilter>();
                        const metadata_14: thrift.TList = input.readListBegin();
                        const size_14: number = metadata_14.size;
                        for (let i_14: number = 0; i_14 < size_14; i_14++) {
                            const value_97: DocFilter.DocFilter = DocFilter.DocFilter.read(input);
                            value_96.push(value_97);
                        }
                        input.readListEnd();
                        _args.success = value_96;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_98: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_98;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_99: core.ServerException = core.ServerException.read(input);
                        _args.error = value_99;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllCustomDocFiltersResult(_args);
    }
}
export interface ICreateOrUpdateCustomDocFilterResultArgs {
    success?: DocFilter.DocFilter;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CreateOrUpdateCustomDocFilterResult {
    public success?: DocFilter.DocFilter;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICreateOrUpdateCustomDocFilterResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateCustomDocFilterResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateCustomDocFilterResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_100: DocFilter.DocFilter = DocFilter.DocFilter.read(input);
                        _args.success = value_100;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_101: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_101;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_102: core.ServerException = core.ServerException.read(input);
                        _args.error = value_102;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateOrUpdateCustomDocFilterResult(_args);
    }
}
export interface IRemoveCustomDocFilterResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class RemoveCustomDocFilterResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IRemoveCustomDocFilterResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveCustomDocFilterResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveCustomDocFilterResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_103: boolean = input.readBool();
                        _args.success = value_103;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_104: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_104;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_105: core.ServerException = core.ServerException.read(input);
                        _args.error = value_105;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveCustomDocFilterResult(_args);
    }
}
export interface ICreateOrUpdateCustomFilterItemResultArgs {
    success?: CustomFilterItem.CustomFilterItem;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CreateOrUpdateCustomFilterItemResult {
    public success?: CustomFilterItem.CustomFilterItem;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICreateOrUpdateCustomFilterItemResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateCustomFilterItemResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateCustomFilterItemResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_106: CustomFilterItem.CustomFilterItem = CustomFilterItem.CustomFilterItem.read(input);
                        _args.success = value_106;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_107: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_107;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_108: core.ServerException = core.ServerException.read(input);
                        _args.error = value_108;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateOrUpdateCustomFilterItemResult(_args);
    }
}
export interface IRemoveCustomFilterItemResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class RemoveCustomFilterItemResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IRemoveCustomFilterItemResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveCustomFilterItemResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveCustomFilterItemResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_109: boolean = input.readBool();
                        _args.success = value_109;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_110: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_110;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_111: core.ServerException = core.ServerException.read(input);
                        _args.error = value_111;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveCustomFilterItemResult(_args);
    }
}
export interface IAddDocFiltersToUserGroupsResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class AddDocFiltersToUserGroupsResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IAddDocFiltersToUserGroupsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddDocFiltersToUserGroupsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddDocFiltersToUserGroupsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_112: boolean = input.readBool();
                        _args.success = value_112;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_113: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_113;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_114: core.ServerException = core.ServerException.read(input);
                        _args.error = value_114;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AddDocFiltersToUserGroupsResult(_args);
    }
}
export interface IRemoveDocFiltersFromUserGroupsResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class RemoveDocFiltersFromUserGroupsResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IRemoveDocFiltersFromUserGroupsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveDocFiltersFromUserGroupsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveDocFiltersFromUserGroupsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_115: boolean = input.readBool();
                        _args.success = value_115;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_116: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_116;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_117: core.ServerException = core.ServerException.read(input);
                        _args.error = value_117;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveDocFiltersFromUserGroupsResult(_args);
    }
}
export interface IGetAllDocFiltersByUserOrGroupResultArgs {
    success?: Array<DocFilter.DocFilter>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllDocFiltersByUserOrGroupResult {
    public success?: Array<DocFilter.DocFilter>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllDocFiltersByUserOrGroupResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocFiltersByUserOrGroupResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_118: DocFilter.DocFilter): void => {
                value_118.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocFiltersByUserOrGroupResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_119: Array<DocFilter.DocFilter> = new Array<DocFilter.DocFilter>();
                        const metadata_15: thrift.TList = input.readListBegin();
                        const size_15: number = metadata_15.size;
                        for (let i_15: number = 0; i_15 < size_15; i_15++) {
                            const value_120: DocFilter.DocFilter = DocFilter.DocFilter.read(input);
                            value_119.push(value_120);
                        }
                        input.readListEnd();
                        _args.success = value_119;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_121: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_121;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_122: core.ServerException = core.ServerException.read(input);
                        _args.error = value_122;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllDocFiltersByUserOrGroupResult(_args);
    }
}
export interface IGetAllUserOrGroupsByDocFilterIdResultArgs {
    success?: Array<core.UserOrGroup>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllUserOrGroupsByDocFilterIdResult {
    public success?: Array<core.UserOrGroup>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllUserOrGroupsByDocFilterIdResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllUserOrGroupsByDocFilterIdResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_123: core.UserOrGroup): void => {
                value_123.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllUserOrGroupsByDocFilterIdResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_124: Array<core.UserOrGroup> = new Array<core.UserOrGroup>();
                        const metadata_16: thrift.TList = input.readListBegin();
                        const size_16: number = metadata_16.size;
                        for (let i_16: number = 0; i_16 < size_16; i_16++) {
                            const value_125: core.UserOrGroup = core.UserOrGroup.read(input);
                            value_124.push(value_125);
                        }
                        input.readListEnd();
                        _args.success = value_124;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_126: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_126;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_127: core.ServerException = core.ServerException.read(input);
                        _args.error = value_127;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllUserOrGroupsByDocFilterIdResult(_args);
    }
}
export interface IExportDocFiltersResultArgs {
    success?: Buffer;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ExportDocFiltersResult {
    public success?: Buffer;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IExportDocFiltersResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExportDocFiltersResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeBinary(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExportDocFiltersResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_128: Buffer = input.readBinary();
                        _args.success = value_128;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_129: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_129;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_130: core.ServerException = core.ServerException.read(input);
                        _args.error = value_130;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExportDocFiltersResult(_args);
    }
}
export interface IImportDocFiltersResultArgs {
    success?: Map<string, string>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ImportDocFiltersResult {
    public success?: Map<string, string>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IImportDocFiltersResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ImportDocFiltersResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.MAP, 0);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.STRING, this.success.size);
            this.success.forEach((value_131: string, key_1: string): void => {
                output.writeString(key_1);
                output.writeString(value_131);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ImportDocFiltersResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_132: Map<string, string> = new Map<string, string>();
                        const metadata_17: thrift.TMap = input.readMapBegin();
                        const size_17: number = metadata_17.size;
                        for (let i_17: number = 0; i_17 < size_17; i_17++) {
                            const key_2: string = input.readString();
                            const value_133: string = input.readString();
                            value_132.set(key_2, value_133);
                        }
                        input.readMapEnd();
                        _args.success = value_132;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_134: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_134;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_135: core.ServerException = core.ServerException.read(input);
                        _args.error = value_135;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ImportDocFiltersResult(_args);
    }
}
export interface IGetDocFilterUserDefineListResultArgs {
    success?: Array<DocFilter.DocFilter>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetDocFilterUserDefineListResult {
    public success?: Array<DocFilter.DocFilter>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetDocFilterUserDefineListResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocFilterUserDefineListResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_136: DocFilter.DocFilter): void => {
                value_136.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocFilterUserDefineListResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_137: Array<DocFilter.DocFilter> = new Array<DocFilter.DocFilter>();
                        const metadata_18: thrift.TList = input.readListBegin();
                        const size_18: number = metadata_18.size;
                        for (let i_18: number = 0; i_18 < size_18; i_18++) {
                            const value_138: DocFilter.DocFilter = DocFilter.DocFilter.read(input);
                            value_137.push(value_138);
                        }
                        input.readListEnd();
                        _args.success = value_137;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_139: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_139;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_140: core.ServerException = core.ServerException.read(input);
                        _args.error = value_140;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetDocFilterUserDefineListResult(_args);
    }
}
export interface IChangeDocFilterUserDefineResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeDocFilterUserDefineResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeDocFilterUserDefineResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeDocFilterUserDefineResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeDocFilterUserDefineResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_141: boolean = input.readBool();
                        _args.success = value_141;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_142: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_142;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_143: core.ServerException = core.ServerException.read(input);
                        _args.error = value_143;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeDocFilterUserDefineResult(_args);
    }
}
export interface ICheckCustomDocFiltersResultArgs {
    success?: Array<string>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CheckCustomDocFiltersResult {
    public success?: Array<string>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICheckCustomDocFiltersResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CheckCustomDocFiltersResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.success.length);
            this.success.forEach((value_144: string): void => {
                output.writeString(value_144);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CheckCustomDocFiltersResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_145: Array<string> = new Array<string>();
                        const metadata_19: thrift.TList = input.readListBegin();
                        const size_19: number = metadata_19.size;
                        for (let i_19: number = 0; i_19 < size_19; i_19++) {
                            const value_146: string = input.readString();
                            value_145.push(value_146);
                        }
                        input.readListEnd();
                        _args.success = value_145;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_147: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_147;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_148: core.ServerException = core.ServerException.read(input);
                        _args.error = value_148;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CheckCustomDocFiltersResult(_args);
    }
}
export interface IGetCountAllDeclaredColumnResultArgs {
    success?: number | Int64;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetCountAllDeclaredColumnResult {
    public success?: Int64;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetCountAllDeclaredColumnResultArgs) {
        if (args != null && args.success != null) {
            if (typeof args.success === "number") {
                this.success = new Int64(args.success);
            }
            else {
                this.success = args.success;
            }
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllDeclaredColumnResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I64, 0);
            output.writeI64(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllDeclaredColumnResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_149: Int64 = input.readI64();
                        _args.success = value_149;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_150: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_150;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_151: core.ServerException = core.ServerException.read(input);
                        _args.error = value_151;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetCountAllDeclaredColumnResult(_args);
    }
}
export interface IGetAllDeclaredColumnResultArgs {
    success?: Array<core.DocColumn>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllDeclaredColumnResult {
    public success?: Array<core.DocColumn>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllDeclaredColumnResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDeclaredColumnResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_152: core.DocColumn): void => {
                value_152.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDeclaredColumnResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_153: Array<core.DocColumn> = new Array<core.DocColumn>();
                        const metadata_20: thrift.TList = input.readListBegin();
                        const size_20: number = metadata_20.size;
                        for (let i_20: number = 0; i_20 < size_20; i_20++) {
                            const value_154: core.DocColumn = core.DocColumn.read(input);
                            value_153.push(value_154);
                        }
                        input.readListEnd();
                        _args.success = value_153;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_155: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_155;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_156: core.ServerException = core.ServerException.read(input);
                        _args.error = value_156;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllDeclaredColumnResult(_args);
    }
}
export interface IChangeDeclaredColumnsResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeDeclaredColumnsResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeDeclaredColumnsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeDeclaredColumnsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeDeclaredColumnsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_157: boolean = input.readBool();
                        _args.success = value_157;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_158: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_158;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_159: core.ServerException = core.ServerException.read(input);
                        _args.error = value_159;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeDeclaredColumnsResult(_args);
    }
}
export interface IChangeUserPreferencesColumnResultArgs {
    success?: Array<core.DocColumn>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeUserPreferencesColumnResult {
    public success?: Array<core.DocColumn>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeUserPreferencesColumnResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeUserPreferencesColumnResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_160: core.DocColumn): void => {
                value_160.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeUserPreferencesColumnResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_161: Array<core.DocColumn> = new Array<core.DocColumn>();
                        const metadata_21: thrift.TList = input.readListBegin();
                        const size_21: number = metadata_21.size;
                        for (let i_21: number = 0; i_21 < size_21; i_21++) {
                            const value_162: core.DocColumn = core.DocColumn.read(input);
                            value_161.push(value_162);
                        }
                        input.readListEnd();
                        _args.success = value_161;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_163: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_163;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_164: core.ServerException = core.ServerException.read(input);
                        _args.error = value_164;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeUserPreferencesColumnResult(_args);
    }
}
export interface IGetAllUserPreferencesColumnResultArgs {
    success?: Array<core.DocColumn>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllUserPreferencesColumnResult {
    public success?: Array<core.DocColumn>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllUserPreferencesColumnResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllUserPreferencesColumnResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_165: core.DocColumn): void => {
                value_165.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllUserPreferencesColumnResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_166: Array<core.DocColumn> = new Array<core.DocColumn>();
                        const metadata_22: thrift.TList = input.readListBegin();
                        const size_22: number = metadata_22.size;
                        for (let i_22: number = 0; i_22 < size_22; i_22++) {
                            const value_167: core.DocColumn = core.DocColumn.read(input);
                            value_166.push(value_167);
                        }
                        input.readListEnd();
                        _args.success = value_166;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_168: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_168;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_169: core.ServerException = core.ServerException.read(input);
                        _args.error = value_169;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllUserPreferencesColumnResult(_args);
    }
}
export interface IGetAllAggregateColumnsForDocumentsResultArgs {
    success?: Array<core.DocColumn>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllAggregateColumnsForDocumentsResult {
    public success?: Array<core.DocColumn>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllAggregateColumnsForDocumentsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllAggregateColumnsForDocumentsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_170: core.DocColumn): void => {
                value_170.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllAggregateColumnsForDocumentsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_171: Array<core.DocColumn> = new Array<core.DocColumn>();
                        const metadata_23: thrift.TList = input.readListBegin();
                        const size_23: number = metadata_23.size;
                        for (let i_23: number = 0; i_23 < size_23; i_23++) {
                            const value_172: core.DocColumn = core.DocColumn.read(input);
                            value_171.push(value_172);
                        }
                        input.readListEnd();
                        _args.success = value_171;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_173: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_173;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_174: core.ServerException = core.ServerException.read(input);
                        _args.error = value_174;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllAggregateColumnsForDocumentsResult(_args);
    }
}
export interface IGetAllColumnsForCustomDocFilterResultArgs {
    success?: Array<core.DocColumn>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllColumnsForCustomDocFilterResult {
    public success?: Array<core.DocColumn>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllColumnsForCustomDocFilterResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllColumnsForCustomDocFilterResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_175: core.DocColumn): void => {
                value_175.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllColumnsForCustomDocFilterResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_176: Array<core.DocColumn> = new Array<core.DocColumn>();
                        const metadata_24: thrift.TList = input.readListBegin();
                        const size_24: number = metadata_24.size;
                        for (let i_24: number = 0; i_24 < size_24; i_24++) {
                            const value_177: core.DocColumn = core.DocColumn.read(input);
                            value_176.push(value_177);
                        }
                        input.readListEnd();
                        _args.success = value_176;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_178: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_178;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_179: core.ServerException = core.ServerException.read(input);
                        _args.error = value_179;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllColumnsForCustomDocFilterResult(_args);
    }
}
export interface IChangeCustomDocFilterColumnsResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeCustomDocFilterColumnsResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeCustomDocFilterColumnsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeCustomDocFilterColumnsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeCustomDocFilterColumnsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_180: boolean = input.readBool();
                        _args.success = value_180;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_181: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_181;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_182: core.ServerException = core.ServerException.read(input);
                        _args.error = value_182;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeCustomDocFilterColumnsResult(_args);
    }
}
export interface IGetAllColumnsForCustomDocFilterWithSortingFieldResultArgs {
    success?: DocFiltersWithSortColumn.DocFiltersWithSortColumn;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllColumnsForCustomDocFilterWithSortingFieldResult {
    public success?: DocFiltersWithSortColumn.DocFiltersWithSortColumn;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllColumnsForCustomDocFilterWithSortingFieldResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllColumnsForCustomDocFilterWithSortingFieldResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllColumnsForCustomDocFilterWithSortingFieldResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_183: DocFiltersWithSortColumn.DocFiltersWithSortColumn = DocFiltersWithSortColumn.DocFiltersWithSortColumn.read(input);
                        _args.success = value_183;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_184: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_184;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_185: core.ServerException = core.ServerException.read(input);
                        _args.error = value_185;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllColumnsForCustomDocFilterWithSortingFieldResult(_args);
    }
}
export interface IChangeCustomDocFilterColumnsAndDefaultSortingFieldResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeCustomDocFilterColumnsAndDefaultSortingFieldResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeCustomDocFilterColumnsAndDefaultSortingFieldResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeCustomDocFilterColumnsAndDefaultSortingFieldResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeCustomDocFilterColumnsAndDefaultSortingFieldResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_186: boolean = input.readBool();
                        _args.success = value_186;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_187: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_187;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_188: core.ServerException = core.ServerException.read(input);
                        _args.error = value_188;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeCustomDocFilterColumnsAndDefaultSortingFieldResult(_args);
    }
}
export class Client {
    public _seqid: number;
    public _reqs: {
        [name: number]: (err: Error | object | undefined, val?: any) => void;
    };
    public output: thrift.TTransport;
    public protocol: new (trans: thrift.TTransport) => thrift.TProtocol;
    constructor(output: thrift.TTransport, protocol: new (trans: thrift.TTransport) => thrift.TProtocol) {
        this._seqid = 0;
        this._reqs = {};
        this.output = output;
        this.protocol = protocol;
    }
    public incrementSeqId(): number {
        return this._seqid += 1;
    }
    public getAllCustomDocFilters(token: string, filter: core.KazFilter, personal: boolean): Promise<Array<DocFilter.DocFilter>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocFilter.DocFilter>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllCustomDocFilters(token, filter, personal, requestId);
        });
    }
    public createOrUpdateCustomDocFilter(token: string, filter: DocFilter.DocFilter, customFilterItems: Array<string>): Promise<DocFilter.DocFilter> {
        const requestId: number = this.incrementSeqId();
        return new Promise<DocFilter.DocFilter>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createOrUpdateCustomDocFilter(token, filter, customFilterItems, requestId);
        });
    }
    public removeCustomDocFilter(token: string, docFilterId: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeCustomDocFilter(token, docFilterId, requestId);
        });
    }
    public createOrUpdateCustomFilterItem(token: string, filterItem: CustomFilterItem.CustomFilterItem): Promise<CustomFilterItem.CustomFilterItem> {
        const requestId: number = this.incrementSeqId();
        return new Promise<CustomFilterItem.CustomFilterItem>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createOrUpdateCustomFilterItem(token, filterItem, requestId);
        });
    }
    public removeCustomFilterItem(token: string, filterItemId: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeCustomFilterItem(token, filterItemId, requestId);
        });
    }
    public addDocFiltersToUserGroups(token: string, docFilterIds: Array<string>, userOrGroups: Array<core.UserOrGroup>): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_addDocFiltersToUserGroups(token, docFilterIds, userOrGroups, requestId);
        });
    }
    public removeDocFiltersFromUserGroups(token: string, docFilterIds: Array<string>, userOrGroups: Array<core.UserOrGroup>): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeDocFiltersFromUserGroups(token, docFilterIds, userOrGroups, requestId);
        });
    }
    public getAllDocFiltersByUserOrGroup(token: string, type: core.UserOrGroupType, userOrGroupId: string, filter: core.KazFilter): Promise<Array<DocFilter.DocFilter>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocFilter.DocFilter>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllDocFiltersByUserOrGroup(token, type, userOrGroupId, filter, requestId);
        });
    }
    public getAllUserOrGroupsByDocFilterId(token: string, docFilterId: string, filter: core.KazFilter): Promise<Array<core.UserOrGroup>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<core.UserOrGroup>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllUserOrGroupsByDocFilterId(token, docFilterId, filter, requestId);
        });
    }
    public exportDocFilters(token: string, docFilterIds: Array<string>): Promise<Buffer> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Buffer>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_exportDocFilters(token, docFilterIds, requestId);
        });
    }
    public importDocFilters(token: string, json: Buffer, clearExistFilters: boolean): Promise<Map<string, string>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Map<string, string>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_importDocFilters(token, json, clearExistFilters, requestId);
        });
    }
    public getDocFilterUserDefineList(token: string, filter: core.KazFilter): Promise<Array<DocFilter.DocFilter>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocFilter.DocFilter>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getDocFilterUserDefineList(token, filter, requestId);
        });
    }
    public changeDocFilterUserDefine(token: string, toUpdate: Array<DocFilter.DocFilter>, toRemove: Array<string>): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeDocFilterUserDefine(token, toUpdate, toRemove, requestId);
        });
    }
    public checkCustomDocFilters(token: string, filter: core.KazFilter): Promise<Array<string>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<string>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_checkCustomDocFilters(token, filter, requestId);
        });
    }
    public getCountAllDeclaredColumn(token: string, filter: core.KazFilter): Promise<Int64> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Int64>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getCountAllDeclaredColumn(token, filter, requestId);
        });
    }
    public getAllDeclaredColumn(token: string, filter: core.KazFilter): Promise<Array<core.DocColumn>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<core.DocColumn>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllDeclaredColumn(token, filter, requestId);
        });
    }
    public changeDeclaredColumns(token: string, toUpdate: Array<core.DocColumn>, toRemove: Array<string>): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeDeclaredColumns(token, toUpdate, toRemove, requestId);
        });
    }
    public changeUserPreferencesColumn(token: string, toUpdate: Array<core.DocColumn>, toRemove: Array<string>, forRegistry: boolean): Promise<Array<core.DocColumn>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<core.DocColumn>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeUserPreferencesColumn(token, toUpdate, toRemove, forRegistry, requestId);
        });
    }
    public getAllUserPreferencesColumn(token: string, registryId: string, filter: core.KazFilter): Promise<Array<core.DocColumn>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<core.DocColumn>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllUserPreferencesColumn(token, registryId, filter, requestId);
        });
    }
    public getAllAggregateColumnsForDocuments(token: string, filter: core.KazFilter, registryId: string): Promise<Array<core.DocColumn>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<core.DocColumn>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllAggregateColumnsForDocuments(token, filter, registryId, requestId);
        });
    }
    public getAllColumnsForCustomDocFilter(token: string, customDocFilterId: string, filter: core.KazFilter): Promise<Array<core.DocColumn>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<core.DocColumn>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllColumnsForCustomDocFilter(token, customDocFilterId, filter, requestId);
        });
    }
    public changeCustomDocFilterColumns(token: string, customDocFilterId: string, useDefaultColumns: boolean, toSave: Array<core.DocColumn>): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeCustomDocFilterColumns(token, customDocFilterId, useDefaultColumns, toSave, requestId);
        });
    }
    public getAllColumnsForCustomDocFilterWithSortingField(token: string, customDocFilterId: string, filter: core.KazFilter): Promise<DocFiltersWithSortColumn.DocFiltersWithSortColumn> {
        const requestId: number = this.incrementSeqId();
        return new Promise<DocFiltersWithSortColumn.DocFiltersWithSortColumn>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllColumnsForCustomDocFilterWithSortingField(token, customDocFilterId, filter, requestId);
        });
    }
    public changeCustomDocFilterColumnsAndDefaultSortingField(token: string, customDocFilterId: string, useDefaultColumns: boolean, toSave: DocFiltersWithSortColumn.DocFiltersWithSortColumn): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeCustomDocFilterColumnsAndDefaultSortingField(token, customDocFilterId, useDefaultColumns, toSave, requestId);
        });
    }
    public send_getAllCustomDocFilters(token: string, filter: core.KazFilter, personal: boolean, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllCustomDocFilters", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllCustomDocFiltersArgs = new GetAllCustomDocFiltersArgs({ token, filter, personal });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createOrUpdateCustomDocFilter(token: string, filter: DocFilter.DocFilter, customFilterItems: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createOrUpdateCustomDocFilter", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateOrUpdateCustomDocFilterArgs = new CreateOrUpdateCustomDocFilterArgs({ token, filter, customFilterItems });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeCustomDocFilter(token: string, docFilterId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeCustomDocFilter", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveCustomDocFilterArgs = new RemoveCustomDocFilterArgs({ token, docFilterId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createOrUpdateCustomFilterItem(token: string, filterItem: CustomFilterItem.CustomFilterItem, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createOrUpdateCustomFilterItem", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateOrUpdateCustomFilterItemArgs = new CreateOrUpdateCustomFilterItemArgs({ token, filterItem });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeCustomFilterItem(token: string, filterItemId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeCustomFilterItem", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveCustomFilterItemArgs = new RemoveCustomFilterItemArgs({ token, filterItemId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_addDocFiltersToUserGroups(token: string, docFilterIds: Array<string>, userOrGroups: Array<core.UserOrGroup>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("addDocFiltersToUserGroups", thrift.Thrift.MessageType.CALL, requestId);
        const args: AddDocFiltersToUserGroupsArgs = new AddDocFiltersToUserGroupsArgs({ token, docFilterIds, userOrGroups });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeDocFiltersFromUserGroups(token: string, docFilterIds: Array<string>, userOrGroups: Array<core.UserOrGroup>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeDocFiltersFromUserGroups", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveDocFiltersFromUserGroupsArgs = new RemoveDocFiltersFromUserGroupsArgs({ token, docFilterIds, userOrGroups });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllDocFiltersByUserOrGroup(token: string, type: core.UserOrGroupType, userOrGroupId: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllDocFiltersByUserOrGroup", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllDocFiltersByUserOrGroupArgs = new GetAllDocFiltersByUserOrGroupArgs({ token, type, userOrGroupId, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllUserOrGroupsByDocFilterId(token: string, docFilterId: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllUserOrGroupsByDocFilterId", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllUserOrGroupsByDocFilterIdArgs = new GetAllUserOrGroupsByDocFilterIdArgs({ token, docFilterId, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_exportDocFilters(token: string, docFilterIds: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("exportDocFilters", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExportDocFiltersArgs = new ExportDocFiltersArgs({ token, docFilterIds });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_importDocFilters(token: string, json: Buffer, clearExistFilters: boolean, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("importDocFilters", thrift.Thrift.MessageType.CALL, requestId);
        const args: ImportDocFiltersArgs = new ImportDocFiltersArgs({ token, json, clearExistFilters });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getDocFilterUserDefineList(token: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getDocFilterUserDefineList", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetDocFilterUserDefineListArgs = new GetDocFilterUserDefineListArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeDocFilterUserDefine(token: string, toUpdate: Array<DocFilter.DocFilter>, toRemove: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeDocFilterUserDefine", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeDocFilterUserDefineArgs = new ChangeDocFilterUserDefineArgs({ token, toUpdate, toRemove });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_checkCustomDocFilters(token: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("checkCustomDocFilters", thrift.Thrift.MessageType.CALL, requestId);
        const args: CheckCustomDocFiltersArgs = new CheckCustomDocFiltersArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getCountAllDeclaredColumn(token: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getCountAllDeclaredColumn", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetCountAllDeclaredColumnArgs = new GetCountAllDeclaredColumnArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllDeclaredColumn(token: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllDeclaredColumn", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllDeclaredColumnArgs = new GetAllDeclaredColumnArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeDeclaredColumns(token: string, toUpdate: Array<core.DocColumn>, toRemove: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeDeclaredColumns", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeDeclaredColumnsArgs = new ChangeDeclaredColumnsArgs({ token, toUpdate, toRemove });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeUserPreferencesColumn(token: string, toUpdate: Array<core.DocColumn>, toRemove: Array<string>, forRegistry: boolean, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeUserPreferencesColumn", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeUserPreferencesColumnArgs = new ChangeUserPreferencesColumnArgs({ token, toUpdate, toRemove, forRegistry });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllUserPreferencesColumn(token: string, registryId: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllUserPreferencesColumn", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllUserPreferencesColumnArgs = new GetAllUserPreferencesColumnArgs({ token, registryId, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllAggregateColumnsForDocuments(token: string, filter: core.KazFilter, registryId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllAggregateColumnsForDocuments", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllAggregateColumnsForDocumentsArgs = new GetAllAggregateColumnsForDocumentsArgs({ token, filter, registryId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllColumnsForCustomDocFilter(token: string, customDocFilterId: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllColumnsForCustomDocFilter", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllColumnsForCustomDocFilterArgs = new GetAllColumnsForCustomDocFilterArgs({ token, customDocFilterId, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeCustomDocFilterColumns(token: string, customDocFilterId: string, useDefaultColumns: boolean, toSave: Array<core.DocColumn>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeCustomDocFilterColumns", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeCustomDocFilterColumnsArgs = new ChangeCustomDocFilterColumnsArgs({ token, customDocFilterId, useDefaultColumns, toSave });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllColumnsForCustomDocFilterWithSortingField(token: string, customDocFilterId: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllColumnsForCustomDocFilterWithSortingField", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllColumnsForCustomDocFilterWithSortingFieldArgs = new GetAllColumnsForCustomDocFilterWithSortingFieldArgs({ token, customDocFilterId, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeCustomDocFilterColumnsAndDefaultSortingField(token: string, customDocFilterId: string, useDefaultColumns: boolean, toSave: DocFiltersWithSortColumn.DocFiltersWithSortColumn, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeCustomDocFilterColumnsAndDefaultSortingField", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeCustomDocFilterColumnsAndDefaultSortingFieldArgs = new ChangeCustomDocFilterColumnsAndDefaultSortingFieldArgs({ token, customDocFilterId, useDefaultColumns, toSave });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public recv_getAllCustomDocFilters(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllCustomDocFiltersResult = GetAllCustomDocFiltersResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllCustomDocFilters failed: unknown result"));
                }
            }
        }
    }
    public recv_createOrUpdateCustomDocFilter(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateOrUpdateCustomDocFilterResult = CreateOrUpdateCustomDocFilterResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createOrUpdateCustomDocFilter failed: unknown result"));
                }
            }
        }
    }
    public recv_removeCustomDocFilter(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveCustomDocFilterResult = RemoveCustomDocFilterResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeCustomDocFilter failed: unknown result"));
                }
            }
        }
    }
    public recv_createOrUpdateCustomFilterItem(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateOrUpdateCustomFilterItemResult = CreateOrUpdateCustomFilterItemResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createOrUpdateCustomFilterItem failed: unknown result"));
                }
            }
        }
    }
    public recv_removeCustomFilterItem(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveCustomFilterItemResult = RemoveCustomFilterItemResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeCustomFilterItem failed: unknown result"));
                }
            }
        }
    }
    public recv_addDocFiltersToUserGroups(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AddDocFiltersToUserGroupsResult = AddDocFiltersToUserGroupsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addDocFiltersToUserGroups failed: unknown result"));
                }
            }
        }
    }
    public recv_removeDocFiltersFromUserGroups(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveDocFiltersFromUserGroupsResult = RemoveDocFiltersFromUserGroupsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeDocFiltersFromUserGroups failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllDocFiltersByUserOrGroup(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllDocFiltersByUserOrGroupResult = GetAllDocFiltersByUserOrGroupResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllDocFiltersByUserOrGroup failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllUserOrGroupsByDocFilterId(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllUserOrGroupsByDocFilterIdResult = GetAllUserOrGroupsByDocFilterIdResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllUserOrGroupsByDocFilterId failed: unknown result"));
                }
            }
        }
    }
    public recv_exportDocFilters(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExportDocFiltersResult = ExportDocFiltersResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "exportDocFilters failed: unknown result"));
                }
            }
        }
    }
    public recv_importDocFilters(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ImportDocFiltersResult = ImportDocFiltersResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "importDocFilters failed: unknown result"));
                }
            }
        }
    }
    public recv_getDocFilterUserDefineList(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetDocFilterUserDefineListResult = GetDocFilterUserDefineListResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getDocFilterUserDefineList failed: unknown result"));
                }
            }
        }
    }
    public recv_changeDocFilterUserDefine(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeDocFilterUserDefineResult = ChangeDocFilterUserDefineResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeDocFilterUserDefine failed: unknown result"));
                }
            }
        }
    }
    public recv_checkCustomDocFilters(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CheckCustomDocFiltersResult = CheckCustomDocFiltersResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "checkCustomDocFilters failed: unknown result"));
                }
            }
        }
    }
    public recv_getCountAllDeclaredColumn(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetCountAllDeclaredColumnResult = GetCountAllDeclaredColumnResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getCountAllDeclaredColumn failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllDeclaredColumn(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllDeclaredColumnResult = GetAllDeclaredColumnResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllDeclaredColumn failed: unknown result"));
                }
            }
        }
    }
    public recv_changeDeclaredColumns(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeDeclaredColumnsResult = ChangeDeclaredColumnsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeDeclaredColumns failed: unknown result"));
                }
            }
        }
    }
    public recv_changeUserPreferencesColumn(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeUserPreferencesColumnResult = ChangeUserPreferencesColumnResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeUserPreferencesColumn failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllUserPreferencesColumn(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllUserPreferencesColumnResult = GetAllUserPreferencesColumnResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllUserPreferencesColumn failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllAggregateColumnsForDocuments(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllAggregateColumnsForDocumentsResult = GetAllAggregateColumnsForDocumentsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllAggregateColumnsForDocuments failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllColumnsForCustomDocFilter(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllColumnsForCustomDocFilterResult = GetAllColumnsForCustomDocFilterResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllColumnsForCustomDocFilter failed: unknown result"));
                }
            }
        }
    }
    public recv_changeCustomDocFilterColumns(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeCustomDocFilterColumnsResult = ChangeCustomDocFilterColumnsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeCustomDocFilterColumns failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllColumnsForCustomDocFilterWithSortingField(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllColumnsForCustomDocFilterWithSortingFieldResult = GetAllColumnsForCustomDocFilterWithSortingFieldResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllColumnsForCustomDocFilterWithSortingField failed: unknown result"));
                }
            }
        }
    }
    public recv_changeCustomDocFilterColumnsAndDefaultSortingField(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeCustomDocFilterColumnsAndDefaultSortingFieldResult = ChangeCustomDocFilterColumnsAndDefaultSortingFieldResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeCustomDocFilterColumnsAndDefaultSortingField failed: unknown result"));
                }
            }
        }
    }
}
export interface IHandler {
    getAllCustomDocFilters(token: string, filter: core.KazFilter, personal: boolean): Array<DocFilter.DocFilter> | Promise<Array<DocFilter.DocFilter>>;
    createOrUpdateCustomDocFilter(token: string, filter: DocFilter.DocFilter, customFilterItems: Array<string>): DocFilter.DocFilter | Promise<DocFilter.DocFilter>;
    removeCustomDocFilter(token: string, docFilterId: string): boolean | Promise<boolean>;
    createOrUpdateCustomFilterItem(token: string, filterItem: CustomFilterItem.CustomFilterItem): CustomFilterItem.CustomFilterItem | Promise<CustomFilterItem.CustomFilterItem>;
    removeCustomFilterItem(token: string, filterItemId: string): boolean | Promise<boolean>;
    addDocFiltersToUserGroups(token: string, docFilterIds: Array<string>, userOrGroups: Array<core.UserOrGroup>): boolean | Promise<boolean>;
    removeDocFiltersFromUserGroups(token: string, docFilterIds: Array<string>, userOrGroups: Array<core.UserOrGroup>): boolean | Promise<boolean>;
    getAllDocFiltersByUserOrGroup(token: string, type: core.UserOrGroupType, userOrGroupId: string, filter: core.KazFilter): Array<DocFilter.DocFilter> | Promise<Array<DocFilter.DocFilter>>;
    getAllUserOrGroupsByDocFilterId(token: string, docFilterId: string, filter: core.KazFilter): Array<core.UserOrGroup> | Promise<Array<core.UserOrGroup>>;
    exportDocFilters(token: string, docFilterIds: Array<string>): Buffer | Promise<Buffer>;
    importDocFilters(token: string, json: Buffer, clearExistFilters: boolean): Map<string, string> | Promise<Map<string, string>>;
    getDocFilterUserDefineList(token: string, filter: core.KazFilter): Array<DocFilter.DocFilter> | Promise<Array<DocFilter.DocFilter>>;
    changeDocFilterUserDefine(token: string, toUpdate: Array<DocFilter.DocFilter>, toRemove: Array<string>): boolean | Promise<boolean>;
    checkCustomDocFilters(token: string, filter: core.KazFilter): Array<string> | Promise<Array<string>>;
    getCountAllDeclaredColumn(token: string, filter: core.KazFilter): Int64 | Promise<Int64>;
    getAllDeclaredColumn(token: string, filter: core.KazFilter): Array<core.DocColumn> | Promise<Array<core.DocColumn>>;
    changeDeclaredColumns(token: string, toUpdate: Array<core.DocColumn>, toRemove: Array<string>): boolean | Promise<boolean>;
    changeUserPreferencesColumn(token: string, toUpdate: Array<core.DocColumn>, toRemove: Array<string>, forRegistry: boolean): Array<core.DocColumn> | Promise<Array<core.DocColumn>>;
    getAllUserPreferencesColumn(token: string, registryId: string, filter: core.KazFilter): Array<core.DocColumn> | Promise<Array<core.DocColumn>>;
    getAllAggregateColumnsForDocuments(token: string, filter: core.KazFilter, registryId: string): Array<core.DocColumn> | Promise<Array<core.DocColumn>>;
    getAllColumnsForCustomDocFilter(token: string, customDocFilterId: string, filter: core.KazFilter): Array<core.DocColumn> | Promise<Array<core.DocColumn>>;
    changeCustomDocFilterColumns(token: string, customDocFilterId: string, useDefaultColumns: boolean, toSave: Array<core.DocColumn>): boolean | Promise<boolean>;
    getAllColumnsForCustomDocFilterWithSortingField(token: string, customDocFilterId: string, filter: core.KazFilter): DocFiltersWithSortColumn.DocFiltersWithSortColumn | Promise<DocFiltersWithSortColumn.DocFiltersWithSortColumn>;
    changeCustomDocFilterColumnsAndDefaultSortingField(token: string, customDocFilterId: string, useDefaultColumns: boolean, toSave: DocFiltersWithSortColumn.DocFiltersWithSortColumn): boolean | Promise<boolean>;
}
export class Processor {
    public _handler: IHandler;
    constructor(handler: IHandler) {
        this._handler = handler;
    }
    public process(input: thrift.TProtocol, output: thrift.TProtocol): void {
        const metadata: thrift.TMessage = input.readMessageBegin();
        const fname: string = metadata.fname;
        const requestId: number = metadata.rseqid;
        const methodName: string = "process_" + fname;
        switch (methodName) {
            case "process_getAllCustomDocFilters": {
                this.process_getAllCustomDocFilters(requestId, input, output);
                return;
            }
            case "process_createOrUpdateCustomDocFilter": {
                this.process_createOrUpdateCustomDocFilter(requestId, input, output);
                return;
            }
            case "process_removeCustomDocFilter": {
                this.process_removeCustomDocFilter(requestId, input, output);
                return;
            }
            case "process_createOrUpdateCustomFilterItem": {
                this.process_createOrUpdateCustomFilterItem(requestId, input, output);
                return;
            }
            case "process_removeCustomFilterItem": {
                this.process_removeCustomFilterItem(requestId, input, output);
                return;
            }
            case "process_addDocFiltersToUserGroups": {
                this.process_addDocFiltersToUserGroups(requestId, input, output);
                return;
            }
            case "process_removeDocFiltersFromUserGroups": {
                this.process_removeDocFiltersFromUserGroups(requestId, input, output);
                return;
            }
            case "process_getAllDocFiltersByUserOrGroup": {
                this.process_getAllDocFiltersByUserOrGroup(requestId, input, output);
                return;
            }
            case "process_getAllUserOrGroupsByDocFilterId": {
                this.process_getAllUserOrGroupsByDocFilterId(requestId, input, output);
                return;
            }
            case "process_exportDocFilters": {
                this.process_exportDocFilters(requestId, input, output);
                return;
            }
            case "process_importDocFilters": {
                this.process_importDocFilters(requestId, input, output);
                return;
            }
            case "process_getDocFilterUserDefineList": {
                this.process_getDocFilterUserDefineList(requestId, input, output);
                return;
            }
            case "process_changeDocFilterUserDefine": {
                this.process_changeDocFilterUserDefine(requestId, input, output);
                return;
            }
            case "process_checkCustomDocFilters": {
                this.process_checkCustomDocFilters(requestId, input, output);
                return;
            }
            case "process_getCountAllDeclaredColumn": {
                this.process_getCountAllDeclaredColumn(requestId, input, output);
                return;
            }
            case "process_getAllDeclaredColumn": {
                this.process_getAllDeclaredColumn(requestId, input, output);
                return;
            }
            case "process_changeDeclaredColumns": {
                this.process_changeDeclaredColumns(requestId, input, output);
                return;
            }
            case "process_changeUserPreferencesColumn": {
                this.process_changeUserPreferencesColumn(requestId, input, output);
                return;
            }
            case "process_getAllUserPreferencesColumn": {
                this.process_getAllUserPreferencesColumn(requestId, input, output);
                return;
            }
            case "process_getAllAggregateColumnsForDocuments": {
                this.process_getAllAggregateColumnsForDocuments(requestId, input, output);
                return;
            }
            case "process_getAllColumnsForCustomDocFilter": {
                this.process_getAllColumnsForCustomDocFilter(requestId, input, output);
                return;
            }
            case "process_changeCustomDocFilterColumns": {
                this.process_changeCustomDocFilterColumns(requestId, input, output);
                return;
            }
            case "process_getAllColumnsForCustomDocFilterWithSortingField": {
                this.process_getAllColumnsForCustomDocFilterWithSortingField(requestId, input, output);
                return;
            }
            case "process_changeCustomDocFilterColumnsAndDefaultSortingField": {
                this.process_changeCustomDocFilterColumnsAndDefaultSortingField(requestId, input, output);
                return;
            }
            default: {
                input.skip(thrift.Thrift.Type.STRUCT);
                input.readMessageEnd();
                const errMessage = "Unknown function " + fname;
                const err = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                output.writeMessageBegin(fname, thrift.Thrift.MessageType.EXCEPTION, requestId);
                err.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        }
    }
    public process_getAllCustomDocFilters(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocFilter.DocFilter>>((resolve, reject): void => {
            try {
                const args: GetAllCustomDocFiltersArgs = GetAllCustomDocFiltersArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllCustomDocFilters(args.token, args.filter, args.personal));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocFilter.DocFilter>): void => {
            const result: GetAllCustomDocFiltersResult = new GetAllCustomDocFiltersResult({ success: data });
            output.writeMessageBegin("getAllCustomDocFilters", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllCustomDocFiltersResult = new GetAllCustomDocFiltersResult({ validError: err });
                output.writeMessageBegin("getAllCustomDocFilters", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllCustomDocFiltersResult = new GetAllCustomDocFiltersResult({ error: err });
                output.writeMessageBegin("getAllCustomDocFilters", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllCustomDocFilters", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createOrUpdateCustomDocFilter(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<DocFilter.DocFilter>((resolve, reject): void => {
            try {
                const args: CreateOrUpdateCustomDocFilterArgs = CreateOrUpdateCustomDocFilterArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createOrUpdateCustomDocFilter(args.token, args.filter, args.customFilterItems));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DocFilter.DocFilter): void => {
            const result: CreateOrUpdateCustomDocFilterResult = new CreateOrUpdateCustomDocFilterResult({ success: data });
            output.writeMessageBegin("createOrUpdateCustomDocFilter", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CreateOrUpdateCustomDocFilterResult = new CreateOrUpdateCustomDocFilterResult({ validError: err });
                output.writeMessageBegin("createOrUpdateCustomDocFilter", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CreateOrUpdateCustomDocFilterResult = new CreateOrUpdateCustomDocFilterResult({ error: err });
                output.writeMessageBegin("createOrUpdateCustomDocFilter", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createOrUpdateCustomDocFilter", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeCustomDocFilter(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemoveCustomDocFilterArgs = RemoveCustomDocFilterArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeCustomDocFilter(args.token, args.docFilterId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemoveCustomDocFilterResult = new RemoveCustomDocFilterResult({ success: data });
            output.writeMessageBegin("removeCustomDocFilter", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: RemoveCustomDocFilterResult = new RemoveCustomDocFilterResult({ validError: err });
                output.writeMessageBegin("removeCustomDocFilter", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: RemoveCustomDocFilterResult = new RemoveCustomDocFilterResult({ error: err });
                output.writeMessageBegin("removeCustomDocFilter", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeCustomDocFilter", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createOrUpdateCustomFilterItem(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<CustomFilterItem.CustomFilterItem>((resolve, reject): void => {
            try {
                const args: CreateOrUpdateCustomFilterItemArgs = CreateOrUpdateCustomFilterItemArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createOrUpdateCustomFilterItem(args.token, args.filterItem));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: CustomFilterItem.CustomFilterItem): void => {
            const result: CreateOrUpdateCustomFilterItemResult = new CreateOrUpdateCustomFilterItemResult({ success: data });
            output.writeMessageBegin("createOrUpdateCustomFilterItem", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CreateOrUpdateCustomFilterItemResult = new CreateOrUpdateCustomFilterItemResult({ validError: err });
                output.writeMessageBegin("createOrUpdateCustomFilterItem", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CreateOrUpdateCustomFilterItemResult = new CreateOrUpdateCustomFilterItemResult({ error: err });
                output.writeMessageBegin("createOrUpdateCustomFilterItem", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createOrUpdateCustomFilterItem", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeCustomFilterItem(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemoveCustomFilterItemArgs = RemoveCustomFilterItemArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeCustomFilterItem(args.token, args.filterItemId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemoveCustomFilterItemResult = new RemoveCustomFilterItemResult({ success: data });
            output.writeMessageBegin("removeCustomFilterItem", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: RemoveCustomFilterItemResult = new RemoveCustomFilterItemResult({ validError: err });
                output.writeMessageBegin("removeCustomFilterItem", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: RemoveCustomFilterItemResult = new RemoveCustomFilterItemResult({ error: err });
                output.writeMessageBegin("removeCustomFilterItem", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeCustomFilterItem", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_addDocFiltersToUserGroups(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: AddDocFiltersToUserGroupsArgs = AddDocFiltersToUserGroupsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.addDocFiltersToUserGroups(args.token, args.docFilterIds, args.userOrGroups));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: AddDocFiltersToUserGroupsResult = new AddDocFiltersToUserGroupsResult({ success: data });
            output.writeMessageBegin("addDocFiltersToUserGroups", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: AddDocFiltersToUserGroupsResult = new AddDocFiltersToUserGroupsResult({ validError: err });
                output.writeMessageBegin("addDocFiltersToUserGroups", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: AddDocFiltersToUserGroupsResult = new AddDocFiltersToUserGroupsResult({ error: err });
                output.writeMessageBegin("addDocFiltersToUserGroups", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addDocFiltersToUserGroups", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeDocFiltersFromUserGroups(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemoveDocFiltersFromUserGroupsArgs = RemoveDocFiltersFromUserGroupsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeDocFiltersFromUserGroups(args.token, args.docFilterIds, args.userOrGroups));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemoveDocFiltersFromUserGroupsResult = new RemoveDocFiltersFromUserGroupsResult({ success: data });
            output.writeMessageBegin("removeDocFiltersFromUserGroups", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: RemoveDocFiltersFromUserGroupsResult = new RemoveDocFiltersFromUserGroupsResult({ validError: err });
                output.writeMessageBegin("removeDocFiltersFromUserGroups", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: RemoveDocFiltersFromUserGroupsResult = new RemoveDocFiltersFromUserGroupsResult({ error: err });
                output.writeMessageBegin("removeDocFiltersFromUserGroups", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeDocFiltersFromUserGroups", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllDocFiltersByUserOrGroup(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocFilter.DocFilter>>((resolve, reject): void => {
            try {
                const args: GetAllDocFiltersByUserOrGroupArgs = GetAllDocFiltersByUserOrGroupArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllDocFiltersByUserOrGroup(args.token, args.type, args.userOrGroupId, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocFilter.DocFilter>): void => {
            const result: GetAllDocFiltersByUserOrGroupResult = new GetAllDocFiltersByUserOrGroupResult({ success: data });
            output.writeMessageBegin("getAllDocFiltersByUserOrGroup", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllDocFiltersByUserOrGroupResult = new GetAllDocFiltersByUserOrGroupResult({ validError: err });
                output.writeMessageBegin("getAllDocFiltersByUserOrGroup", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllDocFiltersByUserOrGroupResult = new GetAllDocFiltersByUserOrGroupResult({ error: err });
                output.writeMessageBegin("getAllDocFiltersByUserOrGroup", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllDocFiltersByUserOrGroup", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllUserOrGroupsByDocFilterId(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<core.UserOrGroup>>((resolve, reject): void => {
            try {
                const args: GetAllUserOrGroupsByDocFilterIdArgs = GetAllUserOrGroupsByDocFilterIdArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllUserOrGroupsByDocFilterId(args.token, args.docFilterId, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<core.UserOrGroup>): void => {
            const result: GetAllUserOrGroupsByDocFilterIdResult = new GetAllUserOrGroupsByDocFilterIdResult({ success: data });
            output.writeMessageBegin("getAllUserOrGroupsByDocFilterId", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllUserOrGroupsByDocFilterIdResult = new GetAllUserOrGroupsByDocFilterIdResult({ validError: err });
                output.writeMessageBegin("getAllUserOrGroupsByDocFilterId", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllUserOrGroupsByDocFilterIdResult = new GetAllUserOrGroupsByDocFilterIdResult({ error: err });
                output.writeMessageBegin("getAllUserOrGroupsByDocFilterId", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllUserOrGroupsByDocFilterId", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_exportDocFilters(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Buffer>((resolve, reject): void => {
            try {
                const args: ExportDocFiltersArgs = ExportDocFiltersArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.exportDocFilters(args.token, args.docFilterIds));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Buffer): void => {
            const result: ExportDocFiltersResult = new ExportDocFiltersResult({ success: data });
            output.writeMessageBegin("exportDocFilters", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ExportDocFiltersResult = new ExportDocFiltersResult({ validError: err });
                output.writeMessageBegin("exportDocFilters", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ExportDocFiltersResult = new ExportDocFiltersResult({ error: err });
                output.writeMessageBegin("exportDocFilters", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("exportDocFilters", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_importDocFilters(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Map<string, string>>((resolve, reject): void => {
            try {
                const args: ImportDocFiltersArgs = ImportDocFiltersArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.importDocFilters(args.token, args.json, args.clearExistFilters));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Map<string, string>): void => {
            const result: ImportDocFiltersResult = new ImportDocFiltersResult({ success: data });
            output.writeMessageBegin("importDocFilters", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ImportDocFiltersResult = new ImportDocFiltersResult({ validError: err });
                output.writeMessageBegin("importDocFilters", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ImportDocFiltersResult = new ImportDocFiltersResult({ error: err });
                output.writeMessageBegin("importDocFilters", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("importDocFilters", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getDocFilterUserDefineList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocFilter.DocFilter>>((resolve, reject): void => {
            try {
                const args: GetDocFilterUserDefineListArgs = GetDocFilterUserDefineListArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getDocFilterUserDefineList(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocFilter.DocFilter>): void => {
            const result: GetDocFilterUserDefineListResult = new GetDocFilterUserDefineListResult({ success: data });
            output.writeMessageBegin("getDocFilterUserDefineList", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetDocFilterUserDefineListResult = new GetDocFilterUserDefineListResult({ validError: err });
                output.writeMessageBegin("getDocFilterUserDefineList", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetDocFilterUserDefineListResult = new GetDocFilterUserDefineListResult({ error: err });
                output.writeMessageBegin("getDocFilterUserDefineList", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getDocFilterUserDefineList", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeDocFilterUserDefine(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeDocFilterUserDefineArgs = ChangeDocFilterUserDefineArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeDocFilterUserDefine(args.token, args.toUpdate, args.toRemove));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeDocFilterUserDefineResult = new ChangeDocFilterUserDefineResult({ success: data });
            output.writeMessageBegin("changeDocFilterUserDefine", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeDocFilterUserDefineResult = new ChangeDocFilterUserDefineResult({ validError: err });
                output.writeMessageBegin("changeDocFilterUserDefine", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeDocFilterUserDefineResult = new ChangeDocFilterUserDefineResult({ error: err });
                output.writeMessageBegin("changeDocFilterUserDefine", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeDocFilterUserDefine", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_checkCustomDocFilters(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<string>>((resolve, reject): void => {
            try {
                const args: CheckCustomDocFiltersArgs = CheckCustomDocFiltersArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.checkCustomDocFilters(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<string>): void => {
            const result: CheckCustomDocFiltersResult = new CheckCustomDocFiltersResult({ success: data });
            output.writeMessageBegin("checkCustomDocFilters", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CheckCustomDocFiltersResult = new CheckCustomDocFiltersResult({ validError: err });
                output.writeMessageBegin("checkCustomDocFilters", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CheckCustomDocFiltersResult = new CheckCustomDocFiltersResult({ error: err });
                output.writeMessageBegin("checkCustomDocFilters", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("checkCustomDocFilters", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getCountAllDeclaredColumn(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Int64>((resolve, reject): void => {
            try {
                const args: GetCountAllDeclaredColumnArgs = GetCountAllDeclaredColumnArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getCountAllDeclaredColumn(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Int64): void => {
            const result: GetCountAllDeclaredColumnResult = new GetCountAllDeclaredColumnResult({ success: data });
            output.writeMessageBegin("getCountAllDeclaredColumn", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetCountAllDeclaredColumnResult = new GetCountAllDeclaredColumnResult({ validError: err });
                output.writeMessageBegin("getCountAllDeclaredColumn", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetCountAllDeclaredColumnResult = new GetCountAllDeclaredColumnResult({ error: err });
                output.writeMessageBegin("getCountAllDeclaredColumn", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getCountAllDeclaredColumn", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllDeclaredColumn(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<core.DocColumn>>((resolve, reject): void => {
            try {
                const args: GetAllDeclaredColumnArgs = GetAllDeclaredColumnArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllDeclaredColumn(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<core.DocColumn>): void => {
            const result: GetAllDeclaredColumnResult = new GetAllDeclaredColumnResult({ success: data });
            output.writeMessageBegin("getAllDeclaredColumn", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllDeclaredColumnResult = new GetAllDeclaredColumnResult({ validError: err });
                output.writeMessageBegin("getAllDeclaredColumn", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllDeclaredColumnResult = new GetAllDeclaredColumnResult({ error: err });
                output.writeMessageBegin("getAllDeclaredColumn", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllDeclaredColumn", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeDeclaredColumns(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeDeclaredColumnsArgs = ChangeDeclaredColumnsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeDeclaredColumns(args.token, args.toUpdate, args.toRemove));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeDeclaredColumnsResult = new ChangeDeclaredColumnsResult({ success: data });
            output.writeMessageBegin("changeDeclaredColumns", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeDeclaredColumnsResult = new ChangeDeclaredColumnsResult({ validError: err });
                output.writeMessageBegin("changeDeclaredColumns", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeDeclaredColumnsResult = new ChangeDeclaredColumnsResult({ error: err });
                output.writeMessageBegin("changeDeclaredColumns", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeDeclaredColumns", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeUserPreferencesColumn(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<core.DocColumn>>((resolve, reject): void => {
            try {
                const args: ChangeUserPreferencesColumnArgs = ChangeUserPreferencesColumnArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeUserPreferencesColumn(args.token, args.toUpdate, args.toRemove, args.forRegistry));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<core.DocColumn>): void => {
            const result: ChangeUserPreferencesColumnResult = new ChangeUserPreferencesColumnResult({ success: data });
            output.writeMessageBegin("changeUserPreferencesColumn", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeUserPreferencesColumnResult = new ChangeUserPreferencesColumnResult({ validError: err });
                output.writeMessageBegin("changeUserPreferencesColumn", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeUserPreferencesColumnResult = new ChangeUserPreferencesColumnResult({ error: err });
                output.writeMessageBegin("changeUserPreferencesColumn", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeUserPreferencesColumn", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllUserPreferencesColumn(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<core.DocColumn>>((resolve, reject): void => {
            try {
                const args: GetAllUserPreferencesColumnArgs = GetAllUserPreferencesColumnArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllUserPreferencesColumn(args.token, args.registryId, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<core.DocColumn>): void => {
            const result: GetAllUserPreferencesColumnResult = new GetAllUserPreferencesColumnResult({ success: data });
            output.writeMessageBegin("getAllUserPreferencesColumn", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllUserPreferencesColumnResult = new GetAllUserPreferencesColumnResult({ validError: err });
                output.writeMessageBegin("getAllUserPreferencesColumn", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllUserPreferencesColumnResult = new GetAllUserPreferencesColumnResult({ error: err });
                output.writeMessageBegin("getAllUserPreferencesColumn", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllUserPreferencesColumn", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllAggregateColumnsForDocuments(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<core.DocColumn>>((resolve, reject): void => {
            try {
                const args: GetAllAggregateColumnsForDocumentsArgs = GetAllAggregateColumnsForDocumentsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllAggregateColumnsForDocuments(args.token, args.filter, args.registryId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<core.DocColumn>): void => {
            const result: GetAllAggregateColumnsForDocumentsResult = new GetAllAggregateColumnsForDocumentsResult({ success: data });
            output.writeMessageBegin("getAllAggregateColumnsForDocuments", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllAggregateColumnsForDocumentsResult = new GetAllAggregateColumnsForDocumentsResult({ validError: err });
                output.writeMessageBegin("getAllAggregateColumnsForDocuments", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllAggregateColumnsForDocumentsResult = new GetAllAggregateColumnsForDocumentsResult({ error: err });
                output.writeMessageBegin("getAllAggregateColumnsForDocuments", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllAggregateColumnsForDocuments", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllColumnsForCustomDocFilter(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<core.DocColumn>>((resolve, reject): void => {
            try {
                const args: GetAllColumnsForCustomDocFilterArgs = GetAllColumnsForCustomDocFilterArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllColumnsForCustomDocFilter(args.token, args.customDocFilterId, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<core.DocColumn>): void => {
            const result: GetAllColumnsForCustomDocFilterResult = new GetAllColumnsForCustomDocFilterResult({ success: data });
            output.writeMessageBegin("getAllColumnsForCustomDocFilter", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllColumnsForCustomDocFilterResult = new GetAllColumnsForCustomDocFilterResult({ validError: err });
                output.writeMessageBegin("getAllColumnsForCustomDocFilter", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllColumnsForCustomDocFilterResult = new GetAllColumnsForCustomDocFilterResult({ error: err });
                output.writeMessageBegin("getAllColumnsForCustomDocFilter", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllColumnsForCustomDocFilter", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeCustomDocFilterColumns(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeCustomDocFilterColumnsArgs = ChangeCustomDocFilterColumnsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeCustomDocFilterColumns(args.token, args.customDocFilterId, args.useDefaultColumns, args.toSave));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeCustomDocFilterColumnsResult = new ChangeCustomDocFilterColumnsResult({ success: data });
            output.writeMessageBegin("changeCustomDocFilterColumns", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeCustomDocFilterColumnsResult = new ChangeCustomDocFilterColumnsResult({ validError: err });
                output.writeMessageBegin("changeCustomDocFilterColumns", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeCustomDocFilterColumnsResult = new ChangeCustomDocFilterColumnsResult({ error: err });
                output.writeMessageBegin("changeCustomDocFilterColumns", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeCustomDocFilterColumns", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllColumnsForCustomDocFilterWithSortingField(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<DocFiltersWithSortColumn.DocFiltersWithSortColumn>((resolve, reject): void => {
            try {
                const args: GetAllColumnsForCustomDocFilterWithSortingFieldArgs = GetAllColumnsForCustomDocFilterWithSortingFieldArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllColumnsForCustomDocFilterWithSortingField(args.token, args.customDocFilterId, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DocFiltersWithSortColumn.DocFiltersWithSortColumn): void => {
            const result: GetAllColumnsForCustomDocFilterWithSortingFieldResult = new GetAllColumnsForCustomDocFilterWithSortingFieldResult({ success: data });
            output.writeMessageBegin("getAllColumnsForCustomDocFilterWithSortingField", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllColumnsForCustomDocFilterWithSortingFieldResult = new GetAllColumnsForCustomDocFilterWithSortingFieldResult({ validError: err });
                output.writeMessageBegin("getAllColumnsForCustomDocFilterWithSortingField", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllColumnsForCustomDocFilterWithSortingFieldResult = new GetAllColumnsForCustomDocFilterWithSortingFieldResult({ error: err });
                output.writeMessageBegin("getAllColumnsForCustomDocFilterWithSortingField", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllColumnsForCustomDocFilterWithSortingField", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeCustomDocFilterColumnsAndDefaultSortingField(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeCustomDocFilterColumnsAndDefaultSortingFieldArgs = ChangeCustomDocFilterColumnsAndDefaultSortingFieldArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeCustomDocFilterColumnsAndDefaultSortingField(args.token, args.customDocFilterId, args.useDefaultColumns, args.toSave));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeCustomDocFilterColumnsAndDefaultSortingFieldResult = new ChangeCustomDocFilterColumnsAndDefaultSortingFieldResult({ success: data });
            output.writeMessageBegin("changeCustomDocFilterColumnsAndDefaultSortingField", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeCustomDocFilterColumnsAndDefaultSortingFieldResult = new ChangeCustomDocFilterColumnsAndDefaultSortingFieldResult({ validError: err });
                output.writeMessageBegin("changeCustomDocFilterColumnsAndDefaultSortingField", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeCustomDocFilterColumnsAndDefaultSortingFieldResult = new ChangeCustomDocFilterColumnsAndDefaultSortingFieldResult({ error: err });
                output.writeMessageBegin("changeCustomDocFilterColumnsAndDefaultSortingField", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeCustomDocFilterColumnsAndDefaultSortingField", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
}
