/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import Int64 from "node-int64";
import * as thrift from "thrift";
import * as DocumentAccessPolicy from "./DocumentAccessPolicy";
import * as core from "./";
import * as DocPermissions from "./DocPermissions";
import * as Document from "./Document";
import * as ContentHolderLink from "./ContentHolderLink";
import * as AttCreateInfo from "./AttCreateInfo";
import * as DocumentRelation from "./DocumentRelation";
import * as PassedStage from "./PassedStage";
import * as ExecutionTree from "./ExecutionTree";
import * as DocumentPatternStage from "./DocumentPatternStage";
import * as DocumentExecution from "./DocumentExecution";
import * as DocumentReassign from "./DocumentReassign";
import * as ExecutionReassignType from "./ExecutionReassignType";
import * as DocumentExecutionTypeLink from "./DocumentExecutionTypeLink";
import * as AttachmentProcessingType from "./AttachmentProcessingType";
import * as Attachment from "./Attachment";
import * as AttachmentType from "./AttachmentType";
import * as DocumentComment from "./DocumentComment";
import * as ChangeType from "./ChangeType";
import * as ContentHolderShowPlace from "./ContentHolderShowPlace";
import * as HistoryPage from "./HistoryPage";
import * as TodayTaskType from "./TodayTaskType";
import * as DocPatternStageSubStatus from "./DocPatternStageSubStatus";
import * as DocumentExecutionStatisticType from "./DocumentExecutionStatisticType";
import * as DocumentExtShare from "./DocumentExtShare";
import * as ContentItem from "./ContentItem";
import * as PatternProcessRole from "./PatternProcessRole";
import * as PatternVariable from "./PatternVariable";
import * as DocumentRelationModel from "./DocumentRelationModel";
import * as DocumentSearchType from "./DocumentSearchType";
import * as SubStatusKey from "./SubStatusKey";
import * as DocumentTag from "./DocumentTag";
import * as DocKeyType from "./DocKeyType";
export interface ICalculatePermissionsArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class CalculatePermissionsArgs {
    public token: string;
    public documentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: ICalculatePermissionsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CalculatePermissionsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CalculatePermissionsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_1: string = input.readString();
                        _args.token = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_2: string = input.readString();
                        _args.documentId = value_2;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_3: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined) {
            return new CalculatePermissionsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CalculatePermissionsArgs from input");
        }
    }
}
export interface ICreateOrUpdateDocumentArgsArgs {
    token: string;
    document: Document.Document;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class CreateOrUpdateDocumentArgs {
    public token: string;
    public document: Document.Document;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: ICreateOrUpdateDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.document != null) {
            this.document = args.document;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[document] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.document != null) {
            output.writeFieldBegin("document", thrift.Thrift.Type.STRUCT, 2);
            this.document.write(output);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_4: string = input.readString();
                        _args.token = value_4;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_5: Document.Document = Document.Document.read(input);
                        _args.document = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_6: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_6;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.document !== undefined && _args.accessPolicy !== undefined) {
            return new CreateOrUpdateDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateOrUpdateDocumentArgs from input");
        }
    }
}
export interface IUpdateDocumentArgsArgs {
    token: string;
    document: Document.Document;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    addedResponsibles: Array<core.UserOrGroup>;
    removedResponsibles: Array<core.UserOrGroup>;
    addedSecurityClassificationIds: Array<string>;
    removedSecurityClassificationIds: Array<string>;
}
export class UpdateDocumentArgs {
    public token: string;
    public document: Document.Document;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public addedResponsibles: Array<core.UserOrGroup>;
    public removedResponsibles: Array<core.UserOrGroup>;
    public addedSecurityClassificationIds: Array<string>;
    public removedSecurityClassificationIds: Array<string>;
    constructor(args: IUpdateDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.document != null) {
            this.document = args.document;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[document] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.addedResponsibles != null) {
            this.addedResponsibles = args.addedResponsibles;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[addedResponsibles] is unset!");
        }
        if (args != null && args.removedResponsibles != null) {
            this.removedResponsibles = args.removedResponsibles;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[removedResponsibles] is unset!");
        }
        if (args != null && args.addedSecurityClassificationIds != null) {
            this.addedSecurityClassificationIds = args.addedSecurityClassificationIds;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[addedSecurityClassificationIds] is unset!");
        }
        if (args != null && args.removedSecurityClassificationIds != null) {
            this.removedSecurityClassificationIds = args.removedSecurityClassificationIds;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[removedSecurityClassificationIds] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.document != null) {
            output.writeFieldBegin("document", thrift.Thrift.Type.STRUCT, 2);
            this.document.write(output);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.addedResponsibles != null) {
            output.writeFieldBegin("addedResponsibles", thrift.Thrift.Type.LIST, 4);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.addedResponsibles.length);
            this.addedResponsibles.forEach((value_7: core.UserOrGroup): void => {
                value_7.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.removedResponsibles != null) {
            output.writeFieldBegin("removedResponsibles", thrift.Thrift.Type.LIST, 5);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.removedResponsibles.length);
            this.removedResponsibles.forEach((value_8: core.UserOrGroup): void => {
                value_8.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.addedSecurityClassificationIds != null) {
            output.writeFieldBegin("addedSecurityClassificationIds", thrift.Thrift.Type.LIST, 6);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.addedSecurityClassificationIds.length);
            this.addedSecurityClassificationIds.forEach((value_9: string): void => {
                output.writeString(value_9);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.removedSecurityClassificationIds != null) {
            output.writeFieldBegin("removedSecurityClassificationIds", thrift.Thrift.Type.LIST, 7);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.removedSecurityClassificationIds.length);
            this.removedSecurityClassificationIds.forEach((value_10: string): void => {
                output.writeString(value_10);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_11: string = input.readString();
                        _args.token = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_12: Document.Document = Document.Document.read(input);
                        _args.document = value_12;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_13: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_14: Array<core.UserOrGroup> = new Array<core.UserOrGroup>();
                        const metadata_1: thrift.TList = input.readListBegin();
                        const size_1: number = metadata_1.size;
                        for (let i_1: number = 0; i_1 < size_1; i_1++) {
                            const value_15: core.UserOrGroup = core.UserOrGroup.read(input);
                            value_14.push(value_15);
                        }
                        input.readListEnd();
                        _args.addedResponsibles = value_14;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_16: Array<core.UserOrGroup> = new Array<core.UserOrGroup>();
                        const metadata_2: thrift.TList = input.readListBegin();
                        const size_2: number = metadata_2.size;
                        for (let i_2: number = 0; i_2 < size_2; i_2++) {
                            const value_17: core.UserOrGroup = core.UserOrGroup.read(input);
                            value_16.push(value_17);
                        }
                        input.readListEnd();
                        _args.removedResponsibles = value_16;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_18: Array<string> = new Array<string>();
                        const metadata_3: thrift.TList = input.readListBegin();
                        const size_3: number = metadata_3.size;
                        for (let i_3: number = 0; i_3 < size_3; i_3++) {
                            const value_19: string = input.readString();
                            value_18.push(value_19);
                        }
                        input.readListEnd();
                        _args.addedSecurityClassificationIds = value_18;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_20: Array<string> = new Array<string>();
                        const metadata_4: thrift.TList = input.readListBegin();
                        const size_4: number = metadata_4.size;
                        for (let i_4: number = 0; i_4 < size_4; i_4++) {
                            const value_21: string = input.readString();
                            value_20.push(value_21);
                        }
                        input.readListEnd();
                        _args.removedSecurityClassificationIds = value_20;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.document !== undefined && _args.accessPolicy !== undefined && _args.addedResponsibles !== undefined && _args.removedResponsibles !== undefined && _args.addedSecurityClassificationIds !== undefined && _args.removedSecurityClassificationIds !== undefined) {
            return new UpdateDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateDocumentArgs from input");
        }
    }
}
export interface ICreateDocumentArgsArgs {
    token: string;
    document: Document.Document;
    users: Array<core.UserOrGroup>;
    holderLinks: Array<ContentHolderLink.ContentHolderLink>;
    securityClassificationsId: Set<string>;
    attachments: Array<AttCreateInfo.AttCreateInfo>;
    docRelations: Array<DocumentRelation.DocumentRelation>;
}
export class CreateDocumentArgs {
    public token: string;
    public document: Document.Document;
    public users: Array<core.UserOrGroup>;
    public holderLinks: Array<ContentHolderLink.ContentHolderLink>;
    public securityClassificationsId: Set<string>;
    public attachments: Array<AttCreateInfo.AttCreateInfo>;
    public docRelations: Array<DocumentRelation.DocumentRelation>;
    constructor(args: ICreateDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.document != null) {
            this.document = args.document;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[document] is unset!");
        }
        if (args != null && args.users != null) {
            this.users = args.users;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[users] is unset!");
        }
        if (args != null && args.holderLinks != null) {
            this.holderLinks = args.holderLinks;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[holderLinks] is unset!");
        }
        if (args != null && args.securityClassificationsId != null) {
            this.securityClassificationsId = args.securityClassificationsId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[securityClassificationsId] is unset!");
        }
        if (args != null && args.attachments != null) {
            this.attachments = args.attachments;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachments] is unset!");
        }
        if (args != null && args.docRelations != null) {
            this.docRelations = args.docRelations;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docRelations] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.document != null) {
            output.writeFieldBegin("document", thrift.Thrift.Type.STRUCT, 2);
            this.document.write(output);
            output.writeFieldEnd();
        }
        if (this.users != null) {
            output.writeFieldBegin("users", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.users.length);
            this.users.forEach((value_22: core.UserOrGroup): void => {
                value_22.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.holderLinks != null) {
            output.writeFieldBegin("holderLinks", thrift.Thrift.Type.LIST, 4);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.holderLinks.length);
            this.holderLinks.forEach((value_23: ContentHolderLink.ContentHolderLink): void => {
                value_23.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.securityClassificationsId != null) {
            output.writeFieldBegin("securityClassificationsId", thrift.Thrift.Type.SET, 5);
            output.writeSetBegin(thrift.Thrift.Type.STRING, this.securityClassificationsId.size);
            this.securityClassificationsId.forEach((value_24: string): void => {
                output.writeString(value_24);
            });
            output.writeSetEnd();
            output.writeFieldEnd();
        }
        if (this.attachments != null) {
            output.writeFieldBegin("attachments", thrift.Thrift.Type.LIST, 6);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.attachments.length);
            this.attachments.forEach((value_25: AttCreateInfo.AttCreateInfo): void => {
                value_25.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.docRelations != null) {
            output.writeFieldBegin("docRelations", thrift.Thrift.Type.LIST, 7);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.docRelations.length);
            this.docRelations.forEach((value_26: DocumentRelation.DocumentRelation): void => {
                value_26.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_27: string = input.readString();
                        _args.token = value_27;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_28: Document.Document = Document.Document.read(input);
                        _args.document = value_28;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_29: Array<core.UserOrGroup> = new Array<core.UserOrGroup>();
                        const metadata_5: thrift.TList = input.readListBegin();
                        const size_5: number = metadata_5.size;
                        for (let i_5: number = 0; i_5 < size_5; i_5++) {
                            const value_30: core.UserOrGroup = core.UserOrGroup.read(input);
                            value_29.push(value_30);
                        }
                        input.readListEnd();
                        _args.users = value_29;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_31: Array<ContentHolderLink.ContentHolderLink> = new Array<ContentHolderLink.ContentHolderLink>();
                        const metadata_6: thrift.TList = input.readListBegin();
                        const size_6: number = metadata_6.size;
                        for (let i_6: number = 0; i_6 < size_6; i_6++) {
                            const value_32: ContentHolderLink.ContentHolderLink = ContentHolderLink.ContentHolderLink.read(input);
                            value_31.push(value_32);
                        }
                        input.readListEnd();
                        _args.holderLinks = value_31;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.SET) {
                        const value_33: Set<string> = new Set<string>();
                        const metadata_7: thrift.TSet = input.readSetBegin();
                        const size_7: number = metadata_7.size;
                        for (let i_7: number = 0; i_7 < size_7; i_7++) {
                            const value_34: string = input.readString();
                            value_33.add(value_34);
                        }
                        input.readSetEnd();
                        _args.securityClassificationsId = value_33;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_35: Array<AttCreateInfo.AttCreateInfo> = new Array<AttCreateInfo.AttCreateInfo>();
                        const metadata_8: thrift.TList = input.readListBegin();
                        const size_8: number = metadata_8.size;
                        for (let i_8: number = 0; i_8 < size_8; i_8++) {
                            const value_36: AttCreateInfo.AttCreateInfo = AttCreateInfo.AttCreateInfo.read(input);
                            value_35.push(value_36);
                        }
                        input.readListEnd();
                        _args.attachments = value_35;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_37: Array<DocumentRelation.DocumentRelation> = new Array<DocumentRelation.DocumentRelation>();
                        const metadata_9: thrift.TList = input.readListBegin();
                        const size_9: number = metadata_9.size;
                        for (let i_9: number = 0; i_9 < size_9; i_9++) {
                            const value_38: DocumentRelation.DocumentRelation = DocumentRelation.DocumentRelation.read(input);
                            value_37.push(value_38);
                        }
                        input.readListEnd();
                        _args.docRelations = value_37;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.document !== undefined && _args.users !== undefined && _args.holderLinks !== undefined && _args.securityClassificationsId !== undefined && _args.attachments !== undefined && _args.docRelations !== undefined) {
            return new CreateDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateDocumentArgs from input");
        }
    }
}
export interface ICreateDocumentFromXMLArgsArgs {
    token: string;
    xmlDoc: Buffer;
}
export class CreateDocumentFromXMLArgs {
    public token: string;
    public xmlDoc: Buffer;
    constructor(args: ICreateDocumentFromXMLArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.xmlDoc != null) {
            this.xmlDoc = args.xmlDoc;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[xmlDoc] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateDocumentFromXMLArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.xmlDoc != null) {
            output.writeFieldBegin("xmlDoc", thrift.Thrift.Type.STRING, 2);
            output.writeBinary(this.xmlDoc);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateDocumentFromXMLArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_39: string = input.readString();
                        _args.token = value_39;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_40: Buffer = input.readBinary();
                        _args.xmlDoc = value_40;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.xmlDoc !== undefined) {
            return new CreateDocumentFromXMLArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateDocumentFromXMLArgs from input");
        }
    }
}
export interface IGetDocumentArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    decrypt: boolean;
    executorsPortion: number;
}
export class GetDocumentArgs {
    public token: string;
    public documentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public decrypt: boolean;
    public executorsPortion: number;
    constructor(args: IGetDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.decrypt != null) {
            this.decrypt = args.decrypt;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[decrypt] is unset!");
        }
        if (args != null && args.executorsPortion != null) {
            this.executorsPortion = args.executorsPortion;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[executorsPortion] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.decrypt != null) {
            output.writeFieldBegin("decrypt", thrift.Thrift.Type.BOOL, 4);
            output.writeBool(this.decrypt);
            output.writeFieldEnd();
        }
        if (this.executorsPortion != null) {
            output.writeFieldBegin("executorsPortion", thrift.Thrift.Type.I32, 5);
            output.writeI32(this.executorsPortion);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_41: string = input.readString();
                        _args.token = value_41;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_42: string = input.readString();
                        _args.documentId = value_42;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_43: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_43;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_44: boolean = input.readBool();
                        _args.decrypt = value_44;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_45: number = input.readI32();
                        _args.executorsPortion = value_45;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined && _args.decrypt !== undefined && _args.executorsPortion !== undefined) {
            return new GetDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetDocumentArgs from input");
        }
    }
}
export interface IGetAllDocumentsArgsArgs {
    token: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    filter: core.KazFilter;
}
export class GetAllDocumentsArgs {
    public token: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public filter: core.KazFilter;
    constructor(args: IGetAllDocumentsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 2);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 3);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_46: string = input.readString();
                        _args.token = value_46;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_47: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_47;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_48: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_48;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.accessPolicy !== undefined && _args.filter !== undefined) {
            return new GetAllDocumentsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllDocumentsArgs from input");
        }
    }
}
export interface IGetCountAllDocumentsArgsArgs {
    token: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    filter: core.KazFilter;
}
export class GetCountAllDocumentsArgs {
    public token: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public filter: core.KazFilter;
    constructor(args: IGetCountAllDocumentsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllDocumentsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 2);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 3);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllDocumentsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_49: string = input.readString();
                        _args.token = value_49;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_50: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_50;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_51: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_51;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.accessPolicy !== undefined && _args.filter !== undefined) {
            return new GetCountAllDocumentsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetCountAllDocumentsArgs from input");
        }
    }
}
export interface IDeleteDocumentArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class DeleteDocumentArgs {
    public token: string;
    public documentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IDeleteDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_52: string = input.readString();
                        _args.token = value_52;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_53: string = input.readString();
                        _args.documentId = value_53;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_54: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_54;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined) {
            return new DeleteDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteDocumentArgs from input");
        }
    }
}
export interface IGetAllPassedStagesArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    filter: core.KazFilter;
}
export class GetAllPassedStagesArgs {
    public token: string;
    public documentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public filter: core.KazFilter;
    constructor(args: IGetAllPassedStagesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllPassedStagesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 4);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllPassedStagesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_55: string = input.readString();
                        _args.token = value_55;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_56: string = input.readString();
                        _args.documentId = value_56;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_57: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_57;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_58: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_58;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined && _args.filter !== undefined) {
            return new GetAllPassedStagesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllPassedStagesArgs from input");
        }
    }
}
export interface IGetExecutionTreeArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    iteration: number;
    filter: core.KazFilter;
}
export class GetExecutionTreeArgs {
    public token: string;
    public documentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public iteration: number;
    public filter: core.KazFilter;
    constructor(args: IGetExecutionTreeArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.iteration != null) {
            this.iteration = args.iteration;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[iteration] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetExecutionTreeArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.iteration != null) {
            output.writeFieldBegin("iteration", thrift.Thrift.Type.I32, 4);
            output.writeI32(this.iteration);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 5);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetExecutionTreeArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_59: string = input.readString();
                        _args.token = value_59;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_60: string = input.readString();
                        _args.documentId = value_60;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_61: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_61;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_62: number = input.readI32();
                        _args.iteration = value_62;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_63: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_63;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined && _args.iteration !== undefined && _args.filter !== undefined) {
            return new GetExecutionTreeArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetExecutionTreeArgs from input");
        }
    }
}
export interface IGetActiveStagesArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class GetActiveStagesArgs {
    public token: string;
    public documentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IGetActiveStagesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetActiveStagesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetActiveStagesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_64: string = input.readString();
                        _args.token = value_64;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_65: string = input.readString();
                        _args.documentId = value_65;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_66: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_66;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined) {
            return new GetActiveStagesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetActiveStagesArgs from input");
        }
    }
}
export interface IGetCountPeoplesWhenRenderedDecisionArgsArgs {
    token: string;
    documentId: string;
    stageId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class GetCountPeoplesWhenRenderedDecisionArgs {
    public token: string;
    public documentId: string;
    public stageId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IGetCountPeoplesWhenRenderedDecisionArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.stageId != null) {
            this.stageId = args.stageId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[stageId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountPeoplesWhenRenderedDecisionArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.stageId != null) {
            output.writeFieldBegin("stageId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.stageId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountPeoplesWhenRenderedDecisionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_67: string = input.readString();
                        _args.token = value_67;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_68: string = input.readString();
                        _args.documentId = value_68;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_69: string = input.readString();
                        _args.stageId = value_69;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_70: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_70;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.stageId !== undefined && _args.accessPolicy !== undefined) {
            return new GetCountPeoplesWhenRenderedDecisionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetCountPeoplesWhenRenderedDecisionArgs from input");
        }
    }
}
export interface ISetDocumentDecisionArgsArgs {
    token: string;
    documentId: string;
    decision: string;
    documentComment: string;
    force: boolean;
    signature: string;
    cardId: string;
    attachments: Array<AttCreateInfo.AttCreateInfo>;
    holderLinks: Array<ContentHolderLink.ContentHolderLink>;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    addSignToAttachment: Map<string, Array<string>>;
}
export class SetDocumentDecisionArgs {
    public token: string;
    public documentId: string;
    public decision: string;
    public documentComment: string;
    public force: boolean;
    public signature: string;
    public cardId: string;
    public attachments: Array<AttCreateInfo.AttCreateInfo>;
    public holderLinks: Array<ContentHolderLink.ContentHolderLink>;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public addSignToAttachment: Map<string, Array<string>>;
    constructor(args: ISetDocumentDecisionArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.decision != null) {
            this.decision = args.decision;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[decision] is unset!");
        }
        if (args != null && args.documentComment != null) {
            this.documentComment = args.documentComment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentComment] is unset!");
        }
        if (args != null && args.force != null) {
            this.force = args.force;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[force] is unset!");
        }
        if (args != null && args.signature != null) {
            this.signature = args.signature;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[signature] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.attachments != null) {
            this.attachments = args.attachments;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachments] is unset!");
        }
        if (args != null && args.holderLinks != null) {
            this.holderLinks = args.holderLinks;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[holderLinks] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.addSignToAttachment != null) {
            this.addSignToAttachment = args.addSignToAttachment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[addSignToAttachment] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetDocumentDecisionArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.decision != null) {
            output.writeFieldBegin("decision", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.decision);
            output.writeFieldEnd();
        }
        if (this.documentComment != null) {
            output.writeFieldBegin("documentComment", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.documentComment);
            output.writeFieldEnd();
        }
        if (this.force != null) {
            output.writeFieldBegin("force", thrift.Thrift.Type.BOOL, 5);
            output.writeBool(this.force);
            output.writeFieldEnd();
        }
        if (this.signature != null) {
            output.writeFieldBegin("signature", thrift.Thrift.Type.STRING, 6);
            output.writeString(this.signature);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 7);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.attachments != null) {
            output.writeFieldBegin("attachments", thrift.Thrift.Type.LIST, 8);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.attachments.length);
            this.attachments.forEach((value_71: AttCreateInfo.AttCreateInfo): void => {
                value_71.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.holderLinks != null) {
            output.writeFieldBegin("holderLinks", thrift.Thrift.Type.LIST, 9);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.holderLinks.length);
            this.holderLinks.forEach((value_72: ContentHolderLink.ContentHolderLink): void => {
                value_72.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 10);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.addSignToAttachment != null) {
            output.writeFieldBegin("addSignToAttachment", thrift.Thrift.Type.MAP, 11);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.LIST, this.addSignToAttachment.size);
            this.addSignToAttachment.forEach((value_73: Array<string>, key_1: string): void => {
                output.writeString(key_1);
                output.writeListBegin(thrift.Thrift.Type.STRING, value_73.length);
                value_73.forEach((value_74: string): void => {
                    output.writeString(value_74);
                });
                output.writeListEnd();
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetDocumentDecisionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_75: string = input.readString();
                        _args.token = value_75;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_76: string = input.readString();
                        _args.documentId = value_76;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_77: string = input.readString();
                        _args.decision = value_77;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_78: string = input.readString();
                        _args.documentComment = value_78;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_79: boolean = input.readBool();
                        _args.force = value_79;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_80: string = input.readString();
                        _args.signature = value_80;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_81: string = input.readString();
                        _args.cardId = value_81;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 8:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_82: Array<AttCreateInfo.AttCreateInfo> = new Array<AttCreateInfo.AttCreateInfo>();
                        const metadata_10: thrift.TList = input.readListBegin();
                        const size_10: number = metadata_10.size;
                        for (let i_10: number = 0; i_10 < size_10; i_10++) {
                            const value_83: AttCreateInfo.AttCreateInfo = AttCreateInfo.AttCreateInfo.read(input);
                            value_82.push(value_83);
                        }
                        input.readListEnd();
                        _args.attachments = value_82;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 9:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_84: Array<ContentHolderLink.ContentHolderLink> = new Array<ContentHolderLink.ContentHolderLink>();
                        const metadata_11: thrift.TList = input.readListBegin();
                        const size_11: number = metadata_11.size;
                        for (let i_11: number = 0; i_11 < size_11; i_11++) {
                            const value_85: ContentHolderLink.ContentHolderLink = ContentHolderLink.ContentHolderLink.read(input);
                            value_84.push(value_85);
                        }
                        input.readListEnd();
                        _args.holderLinks = value_84;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 10:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_86: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_86;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 11:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_87: Map<string, Array<string>> = new Map<string, Array<string>>();
                        const metadata_12: thrift.TMap = input.readMapBegin();
                        const size_12: number = metadata_12.size;
                        for (let i_12: number = 0; i_12 < size_12; i_12++) {
                            const key_2: string = input.readString();
                            const value_88: Array<string> = new Array<string>();
                            const metadata_13: thrift.TList = input.readListBegin();
                            const size_13: number = metadata_13.size;
                            for (let i_13: number = 0; i_13 < size_13; i_13++) {
                                const value_89: string = input.readString();
                                value_88.push(value_89);
                            }
                            input.readListEnd();
                            value_87.set(key_2, value_88);
                        }
                        input.readMapEnd();
                        _args.addSignToAttachment = value_87;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.decision !== undefined && _args.documentComment !== undefined && _args.force !== undefined && _args.signature !== undefined && _args.cardId !== undefined && _args.attachments !== undefined && _args.holderLinks !== undefined && _args.accessPolicy !== undefined && _args.addSignToAttachment !== undefined) {
            return new SetDocumentDecisionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetDocumentDecisionArgs from input");
        }
    }
}
export interface ISetDocumentDecisionByLinkIdArgsArgs {
    token: string;
    documentId: string;
    linkID: string;
    cardId: string;
    documentComment: string;
    force: boolean;
    signature: string;
    pKeyId: string;
    password: string;
    attachments: Array<AttCreateInfo.AttCreateInfo>;
    holderLinks: Array<ContentHolderLink.ContentHolderLink>;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    addSignToAttachment: Map<string, Array<string>>;
    attachmentsToSign: Array<string>;
}
export class SetDocumentDecisionByLinkIdArgs {
    public token: string;
    public documentId: string;
    public linkID: string;
    public cardId: string;
    public documentComment: string;
    public force: boolean;
    public signature: string;
    public pKeyId: string;
    public password: string;
    public attachments: Array<AttCreateInfo.AttCreateInfo>;
    public holderLinks: Array<ContentHolderLink.ContentHolderLink>;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public addSignToAttachment: Map<string, Array<string>>;
    public attachmentsToSign: Array<string>;
    constructor(args: ISetDocumentDecisionByLinkIdArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.linkID != null) {
            this.linkID = args.linkID;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[linkID] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.documentComment != null) {
            this.documentComment = args.documentComment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentComment] is unset!");
        }
        if (args != null && args.force != null) {
            this.force = args.force;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[force] is unset!");
        }
        if (args != null && args.signature != null) {
            this.signature = args.signature;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[signature] is unset!");
        }
        if (args != null && args.pKeyId != null) {
            this.pKeyId = args.pKeyId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[pKeyId] is unset!");
        }
        if (args != null && args.password != null) {
            this.password = args.password;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[password] is unset!");
        }
        if (args != null && args.attachments != null) {
            this.attachments = args.attachments;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachments] is unset!");
        }
        if (args != null && args.holderLinks != null) {
            this.holderLinks = args.holderLinks;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[holderLinks] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.addSignToAttachment != null) {
            this.addSignToAttachment = args.addSignToAttachment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[addSignToAttachment] is unset!");
        }
        if (args != null && args.attachmentsToSign != null) {
            this.attachmentsToSign = args.attachmentsToSign;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentsToSign] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetDocumentDecisionByLinkIdArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.linkID != null) {
            output.writeFieldBegin("linkID", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.linkID);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.documentComment != null) {
            output.writeFieldBegin("documentComment", thrift.Thrift.Type.STRING, 5);
            output.writeString(this.documentComment);
            output.writeFieldEnd();
        }
        if (this.force != null) {
            output.writeFieldBegin("force", thrift.Thrift.Type.BOOL, 6);
            output.writeBool(this.force);
            output.writeFieldEnd();
        }
        if (this.signature != null) {
            output.writeFieldBegin("signature", thrift.Thrift.Type.STRING, 7);
            output.writeString(this.signature);
            output.writeFieldEnd();
        }
        if (this.pKeyId != null) {
            output.writeFieldBegin("pKeyId", thrift.Thrift.Type.STRING, 8);
            output.writeString(this.pKeyId);
            output.writeFieldEnd();
        }
        if (this.password != null) {
            output.writeFieldBegin("password", thrift.Thrift.Type.STRING, 9);
            output.writeString(this.password);
            output.writeFieldEnd();
        }
        if (this.attachments != null) {
            output.writeFieldBegin("attachments", thrift.Thrift.Type.LIST, 10);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.attachments.length);
            this.attachments.forEach((value_90: AttCreateInfo.AttCreateInfo): void => {
                value_90.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.holderLinks != null) {
            output.writeFieldBegin("holderLinks", thrift.Thrift.Type.LIST, 11);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.holderLinks.length);
            this.holderLinks.forEach((value_91: ContentHolderLink.ContentHolderLink): void => {
                value_91.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 12);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.addSignToAttachment != null) {
            output.writeFieldBegin("addSignToAttachment", thrift.Thrift.Type.MAP, 13);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.LIST, this.addSignToAttachment.size);
            this.addSignToAttachment.forEach((value_92: Array<string>, key_3: string): void => {
                output.writeString(key_3);
                output.writeListBegin(thrift.Thrift.Type.STRING, value_92.length);
                value_92.forEach((value_93: string): void => {
                    output.writeString(value_93);
                });
                output.writeListEnd();
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        if (this.attachmentsToSign != null) {
            output.writeFieldBegin("attachmentsToSign", thrift.Thrift.Type.LIST, 14);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.attachmentsToSign.length);
            this.attachmentsToSign.forEach((value_94: string): void => {
                output.writeString(value_94);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetDocumentDecisionByLinkIdArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_95: string = input.readString();
                        _args.token = value_95;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_96: string = input.readString();
                        _args.documentId = value_96;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_97: string = input.readString();
                        _args.linkID = value_97;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_98: string = input.readString();
                        _args.cardId = value_98;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_99: string = input.readString();
                        _args.documentComment = value_99;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_100: boolean = input.readBool();
                        _args.force = value_100;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_101: string = input.readString();
                        _args.signature = value_101;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 8:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_102: string = input.readString();
                        _args.pKeyId = value_102;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 9:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_103: string = input.readString();
                        _args.password = value_103;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 10:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_104: Array<AttCreateInfo.AttCreateInfo> = new Array<AttCreateInfo.AttCreateInfo>();
                        const metadata_14: thrift.TList = input.readListBegin();
                        const size_14: number = metadata_14.size;
                        for (let i_14: number = 0; i_14 < size_14; i_14++) {
                            const value_105: AttCreateInfo.AttCreateInfo = AttCreateInfo.AttCreateInfo.read(input);
                            value_104.push(value_105);
                        }
                        input.readListEnd();
                        _args.attachments = value_104;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 11:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_106: Array<ContentHolderLink.ContentHolderLink> = new Array<ContentHolderLink.ContentHolderLink>();
                        const metadata_15: thrift.TList = input.readListBegin();
                        const size_15: number = metadata_15.size;
                        for (let i_15: number = 0; i_15 < size_15; i_15++) {
                            const value_107: ContentHolderLink.ContentHolderLink = ContentHolderLink.ContentHolderLink.read(input);
                            value_106.push(value_107);
                        }
                        input.readListEnd();
                        _args.holderLinks = value_106;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 12:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_108: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_108;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 13:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_109: Map<string, Array<string>> = new Map<string, Array<string>>();
                        const metadata_16: thrift.TMap = input.readMapBegin();
                        const size_16: number = metadata_16.size;
                        for (let i_16: number = 0; i_16 < size_16; i_16++) {
                            const key_4: string = input.readString();
                            const value_110: Array<string> = new Array<string>();
                            const metadata_17: thrift.TList = input.readListBegin();
                            const size_17: number = metadata_17.size;
                            for (let i_17: number = 0; i_17 < size_17; i_17++) {
                                const value_111: string = input.readString();
                                value_110.push(value_111);
                            }
                            input.readListEnd();
                            value_109.set(key_4, value_110);
                        }
                        input.readMapEnd();
                        _args.addSignToAttachment = value_109;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 14:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_112: Array<string> = new Array<string>();
                        const metadata_18: thrift.TList = input.readListBegin();
                        const size_18: number = metadata_18.size;
                        for (let i_18: number = 0; i_18 < size_18; i_18++) {
                            const value_113: string = input.readString();
                            value_112.push(value_113);
                        }
                        input.readListEnd();
                        _args.attachmentsToSign = value_112;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.linkID !== undefined && _args.cardId !== undefined && _args.documentComment !== undefined && _args.force !== undefined && _args.signature !== undefined && _args.pKeyId !== undefined && _args.password !== undefined && _args.attachments !== undefined && _args.holderLinks !== undefined && _args.accessPolicy !== undefined && _args.addSignToAttachment !== undefined && _args.attachmentsToSign !== undefined) {
            return new SetDocumentDecisionByLinkIdArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetDocumentDecisionByLinkIdArgs from input");
        }
    }
}
export interface ISetDocumentDecisionUsingServerKeyStorageArgsArgs {
    token: string;
    documentId: string;
    decision: string;
    documentComment: string;
    force: boolean;
    pKeyId: string;
    password: string;
    cardId: string;
    attachments: Array<AttCreateInfo.AttCreateInfo>;
    holderLinks: Array<ContentHolderLink.ContentHolderLink>;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    attachmentsToSign: Array<string>;
}
export class SetDocumentDecisionUsingServerKeyStorageArgs {
    public token: string;
    public documentId: string;
    public decision: string;
    public documentComment: string;
    public force: boolean;
    public pKeyId: string;
    public password: string;
    public cardId: string;
    public attachments: Array<AttCreateInfo.AttCreateInfo>;
    public holderLinks: Array<ContentHolderLink.ContentHolderLink>;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public attachmentsToSign: Array<string>;
    constructor(args: ISetDocumentDecisionUsingServerKeyStorageArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.decision != null) {
            this.decision = args.decision;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[decision] is unset!");
        }
        if (args != null && args.documentComment != null) {
            this.documentComment = args.documentComment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentComment] is unset!");
        }
        if (args != null && args.force != null) {
            this.force = args.force;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[force] is unset!");
        }
        if (args != null && args.pKeyId != null) {
            this.pKeyId = args.pKeyId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[pKeyId] is unset!");
        }
        if (args != null && args.password != null) {
            this.password = args.password;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[password] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.attachments != null) {
            this.attachments = args.attachments;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachments] is unset!");
        }
        if (args != null && args.holderLinks != null) {
            this.holderLinks = args.holderLinks;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[holderLinks] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.attachmentsToSign != null) {
            this.attachmentsToSign = args.attachmentsToSign;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentsToSign] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetDocumentDecisionUsingServerKeyStorageArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.decision != null) {
            output.writeFieldBegin("decision", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.decision);
            output.writeFieldEnd();
        }
        if (this.documentComment != null) {
            output.writeFieldBegin("documentComment", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.documentComment);
            output.writeFieldEnd();
        }
        if (this.force != null) {
            output.writeFieldBegin("force", thrift.Thrift.Type.BOOL, 5);
            output.writeBool(this.force);
            output.writeFieldEnd();
        }
        if (this.pKeyId != null) {
            output.writeFieldBegin("pKeyId", thrift.Thrift.Type.STRING, 6);
            output.writeString(this.pKeyId);
            output.writeFieldEnd();
        }
        if (this.password != null) {
            output.writeFieldBegin("password", thrift.Thrift.Type.STRING, 7);
            output.writeString(this.password);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 8);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.attachments != null) {
            output.writeFieldBegin("attachments", thrift.Thrift.Type.LIST, 9);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.attachments.length);
            this.attachments.forEach((value_114: AttCreateInfo.AttCreateInfo): void => {
                value_114.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.holderLinks != null) {
            output.writeFieldBegin("holderLinks", thrift.Thrift.Type.LIST, 10);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.holderLinks.length);
            this.holderLinks.forEach((value_115: ContentHolderLink.ContentHolderLink): void => {
                value_115.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 11);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.attachmentsToSign != null) {
            output.writeFieldBegin("attachmentsToSign", thrift.Thrift.Type.LIST, 12);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.attachmentsToSign.length);
            this.attachmentsToSign.forEach((value_116: string): void => {
                output.writeString(value_116);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetDocumentDecisionUsingServerKeyStorageArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_117: string = input.readString();
                        _args.token = value_117;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_118: string = input.readString();
                        _args.documentId = value_118;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_119: string = input.readString();
                        _args.decision = value_119;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_120: string = input.readString();
                        _args.documentComment = value_120;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_121: boolean = input.readBool();
                        _args.force = value_121;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_122: string = input.readString();
                        _args.pKeyId = value_122;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_123: string = input.readString();
                        _args.password = value_123;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 8:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_124: string = input.readString();
                        _args.cardId = value_124;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 9:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_125: Array<AttCreateInfo.AttCreateInfo> = new Array<AttCreateInfo.AttCreateInfo>();
                        const metadata_19: thrift.TList = input.readListBegin();
                        const size_19: number = metadata_19.size;
                        for (let i_19: number = 0; i_19 < size_19; i_19++) {
                            const value_126: AttCreateInfo.AttCreateInfo = AttCreateInfo.AttCreateInfo.read(input);
                            value_125.push(value_126);
                        }
                        input.readListEnd();
                        _args.attachments = value_125;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 10:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_127: Array<ContentHolderLink.ContentHolderLink> = new Array<ContentHolderLink.ContentHolderLink>();
                        const metadata_20: thrift.TList = input.readListBegin();
                        const size_20: number = metadata_20.size;
                        for (let i_20: number = 0; i_20 < size_20; i_20++) {
                            const value_128: ContentHolderLink.ContentHolderLink = ContentHolderLink.ContentHolderLink.read(input);
                            value_127.push(value_128);
                        }
                        input.readListEnd();
                        _args.holderLinks = value_127;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 11:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_129: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_129;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 12:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_130: Array<string> = new Array<string>();
                        const metadata_21: thrift.TList = input.readListBegin();
                        const size_21: number = metadata_21.size;
                        for (let i_21: number = 0; i_21 < size_21; i_21++) {
                            const value_131: string = input.readString();
                            value_130.push(value_131);
                        }
                        input.readListEnd();
                        _args.attachmentsToSign = value_130;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.decision !== undefined && _args.documentComment !== undefined && _args.force !== undefined && _args.pKeyId !== undefined && _args.password !== undefined && _args.cardId !== undefined && _args.attachments !== undefined && _args.holderLinks !== undefined && _args.accessPolicy !== undefined && _args.attachmentsToSign !== undefined) {
            return new SetDocumentDecisionUsingServerKeyStorageArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetDocumentDecisionUsingServerKeyStorageArgs from input");
        }
    }
}
export interface ISetDocumentDecisionExtArgsArgs {
    token: string;
    documentId: string;
    cardId: string;
    linkID: string;
    documentComment: string;
    force: boolean;
    attachments: Array<AttCreateInfo.AttCreateInfo>;
    holderLinks: Array<ContentHolderLink.ContentHolderLink>;
    addSignToDecision: Array<string>;
    addSignToAttachment: Map<string, Array<string>>;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class SetDocumentDecisionExtArgs {
    public token: string;
    public documentId: string;
    public cardId: string;
    public linkID: string;
    public documentComment: string;
    public force: boolean;
    public attachments: Array<AttCreateInfo.AttCreateInfo>;
    public holderLinks: Array<ContentHolderLink.ContentHolderLink>;
    public addSignToDecision: Array<string>;
    public addSignToAttachment: Map<string, Array<string>>;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: ISetDocumentDecisionExtArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.linkID != null) {
            this.linkID = args.linkID;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[linkID] is unset!");
        }
        if (args != null && args.documentComment != null) {
            this.documentComment = args.documentComment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentComment] is unset!");
        }
        if (args != null && args.force != null) {
            this.force = args.force;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[force] is unset!");
        }
        if (args != null && args.attachments != null) {
            this.attachments = args.attachments;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachments] is unset!");
        }
        if (args != null && args.holderLinks != null) {
            this.holderLinks = args.holderLinks;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[holderLinks] is unset!");
        }
        if (args != null && args.addSignToDecision != null) {
            this.addSignToDecision = args.addSignToDecision;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[addSignToDecision] is unset!");
        }
        if (args != null && args.addSignToAttachment != null) {
            this.addSignToAttachment = args.addSignToAttachment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[addSignToAttachment] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetDocumentDecisionExtArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.linkID != null) {
            output.writeFieldBegin("linkID", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.linkID);
            output.writeFieldEnd();
        }
        if (this.documentComment != null) {
            output.writeFieldBegin("documentComment", thrift.Thrift.Type.STRING, 5);
            output.writeString(this.documentComment);
            output.writeFieldEnd();
        }
        if (this.force != null) {
            output.writeFieldBegin("force", thrift.Thrift.Type.BOOL, 6);
            output.writeBool(this.force);
            output.writeFieldEnd();
        }
        if (this.attachments != null) {
            output.writeFieldBegin("attachments", thrift.Thrift.Type.LIST, 7);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.attachments.length);
            this.attachments.forEach((value_132: AttCreateInfo.AttCreateInfo): void => {
                value_132.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.holderLinks != null) {
            output.writeFieldBegin("holderLinks", thrift.Thrift.Type.LIST, 8);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.holderLinks.length);
            this.holderLinks.forEach((value_133: ContentHolderLink.ContentHolderLink): void => {
                value_133.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.addSignToDecision != null) {
            output.writeFieldBegin("addSignToDecision", thrift.Thrift.Type.LIST, 9);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.addSignToDecision.length);
            this.addSignToDecision.forEach((value_134: string): void => {
                output.writeString(value_134);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.addSignToAttachment != null) {
            output.writeFieldBegin("addSignToAttachment", thrift.Thrift.Type.MAP, 10);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.LIST, this.addSignToAttachment.size);
            this.addSignToAttachment.forEach((value_135: Array<string>, key_5: string): void => {
                output.writeString(key_5);
                output.writeListBegin(thrift.Thrift.Type.STRING, value_135.length);
                value_135.forEach((value_136: string): void => {
                    output.writeString(value_136);
                });
                output.writeListEnd();
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 11);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetDocumentDecisionExtArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_137: string = input.readString();
                        _args.token = value_137;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_138: string = input.readString();
                        _args.documentId = value_138;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_139: string = input.readString();
                        _args.cardId = value_139;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_140: string = input.readString();
                        _args.linkID = value_140;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_141: string = input.readString();
                        _args.documentComment = value_141;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_142: boolean = input.readBool();
                        _args.force = value_142;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_143: Array<AttCreateInfo.AttCreateInfo> = new Array<AttCreateInfo.AttCreateInfo>();
                        const metadata_22: thrift.TList = input.readListBegin();
                        const size_22: number = metadata_22.size;
                        for (let i_22: number = 0; i_22 < size_22; i_22++) {
                            const value_144: AttCreateInfo.AttCreateInfo = AttCreateInfo.AttCreateInfo.read(input);
                            value_143.push(value_144);
                        }
                        input.readListEnd();
                        _args.attachments = value_143;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 8:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_145: Array<ContentHolderLink.ContentHolderLink> = new Array<ContentHolderLink.ContentHolderLink>();
                        const metadata_23: thrift.TList = input.readListBegin();
                        const size_23: number = metadata_23.size;
                        for (let i_23: number = 0; i_23 < size_23; i_23++) {
                            const value_146: ContentHolderLink.ContentHolderLink = ContentHolderLink.ContentHolderLink.read(input);
                            value_145.push(value_146);
                        }
                        input.readListEnd();
                        _args.holderLinks = value_145;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 9:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_147: Array<string> = new Array<string>();
                        const metadata_24: thrift.TList = input.readListBegin();
                        const size_24: number = metadata_24.size;
                        for (let i_24: number = 0; i_24 < size_24; i_24++) {
                            const value_148: string = input.readString();
                            value_147.push(value_148);
                        }
                        input.readListEnd();
                        _args.addSignToDecision = value_147;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 10:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_149: Map<string, Array<string>> = new Map<string, Array<string>>();
                        const metadata_25: thrift.TMap = input.readMapBegin();
                        const size_25: number = metadata_25.size;
                        for (let i_25: number = 0; i_25 < size_25; i_25++) {
                            const key_6: string = input.readString();
                            const value_150: Array<string> = new Array<string>();
                            const metadata_26: thrift.TList = input.readListBegin();
                            const size_26: number = metadata_26.size;
                            for (let i_26: number = 0; i_26 < size_26; i_26++) {
                                const value_151: string = input.readString();
                                value_150.push(value_151);
                            }
                            input.readListEnd();
                            value_149.set(key_6, value_150);
                        }
                        input.readMapEnd();
                        _args.addSignToAttachment = value_149;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 11:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_152: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_152;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.cardId !== undefined && _args.linkID !== undefined && _args.documentComment !== undefined && _args.force !== undefined && _args.attachments !== undefined && _args.holderLinks !== undefined && _args.addSignToDecision !== undefined && _args.addSignToAttachment !== undefined && _args.accessPolicy !== undefined) {
            return new SetDocumentDecisionExtArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetDocumentDecisionExtArgs from input");
        }
    }
}
export interface IApproveDocumentDecisionArgsArgs {
    token: string;
    executionId: string;
}
export class ApproveDocumentDecisionArgs {
    public token: string;
    public executionId: string;
    constructor(args: IApproveDocumentDecisionArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.executionId != null) {
            this.executionId = args.executionId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[executionId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ApproveDocumentDecisionArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.executionId != null) {
            output.writeFieldBegin("executionId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.executionId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ApproveDocumentDecisionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_153: string = input.readString();
                        _args.token = value_153;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_154: string = input.readString();
                        _args.executionId = value_154;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.executionId !== undefined) {
            return new ApproveDocumentDecisionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ApproveDocumentDecisionArgs from input");
        }
    }
}
export interface IShareDocumentArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    usersOrGroups: Array<core.UserOrGroup>;
}
export class ShareDocumentArgs {
    public token: string;
    public documentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public usersOrGroups: Array<core.UserOrGroup>;
    constructor(args: IShareDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.usersOrGroups != null) {
            this.usersOrGroups = args.usersOrGroups;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[usersOrGroups] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ShareDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.usersOrGroups != null) {
            output.writeFieldBegin("usersOrGroups", thrift.Thrift.Type.LIST, 4);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.usersOrGroups.length);
            this.usersOrGroups.forEach((value_155: core.UserOrGroup): void => {
                value_155.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ShareDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_156: string = input.readString();
                        _args.token = value_156;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_157: string = input.readString();
                        _args.documentId = value_157;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_158: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_158;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_159: Array<core.UserOrGroup> = new Array<core.UserOrGroup>();
                        const metadata_27: thrift.TList = input.readListBegin();
                        const size_27: number = metadata_27.size;
                        for (let i_27: number = 0; i_27 < size_27; i_27++) {
                            const value_160: core.UserOrGroup = core.UserOrGroup.read(input);
                            value_159.push(value_160);
                        }
                        input.readListEnd();
                        _args.usersOrGroups = value_159;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined && _args.usersOrGroups !== undefined) {
            return new ShareDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ShareDocumentArgs from input");
        }
    }
}
export interface IRevokeDocumentArgsArgs {
    token: string;
    documentId: string;
    usersOrGroups: Array<core.UserOrGroup>;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class RevokeDocumentArgs {
    public token: string;
    public documentId: string;
    public usersOrGroups: Array<core.UserOrGroup>;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IRevokeDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.usersOrGroups != null) {
            this.usersOrGroups = args.usersOrGroups;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[usersOrGroups] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RevokeDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.usersOrGroups != null) {
            output.writeFieldBegin("usersOrGroups", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.usersOrGroups.length);
            this.usersOrGroups.forEach((value_161: core.UserOrGroup): void => {
                value_161.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RevokeDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_162: string = input.readString();
                        _args.token = value_162;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_163: string = input.readString();
                        _args.documentId = value_163;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_164: Array<core.UserOrGroup> = new Array<core.UserOrGroup>();
                        const metadata_28: thrift.TList = input.readListBegin();
                        const size_28: number = metadata_28.size;
                        for (let i_28: number = 0; i_28 < size_28; i_28++) {
                            const value_165: core.UserOrGroup = core.UserOrGroup.read(input);
                            value_164.push(value_165);
                        }
                        input.readListEnd();
                        _args.usersOrGroups = value_164;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_166: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_166;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.usersOrGroups !== undefined && _args.accessPolicy !== undefined) {
            return new RevokeDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RevokeDocumentArgs from input");
        }
    }
}
export interface IGetAllDocumentSharingsArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    filter: core.KazFilter;
}
export class GetAllDocumentSharingsArgs {
    public token: string;
    public documentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public filter: core.KazFilter;
    constructor(args: IGetAllDocumentSharingsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentSharingsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 4);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentSharingsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_167: string = input.readString();
                        _args.token = value_167;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_168: string = input.readString();
                        _args.documentId = value_168;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_169: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_169;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_170: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_170;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined && _args.filter !== undefined) {
            return new GetAllDocumentSharingsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllDocumentSharingsArgs from input");
        }
    }
}
export interface IGetAllDocumentReassignArgsArgs {
    token: string;
    filter: core.KazFilter;
}
export class GetAllDocumentReassignArgs {
    public token: string;
    public filter: core.KazFilter;
    constructor(args: IGetAllDocumentReassignArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentReassignArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentReassignArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_171: string = input.readString();
                        _args.token = value_171;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_172: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_172;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllDocumentReassignArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllDocumentReassignArgs from input");
        }
    }
}
export interface IReassignDocumentArgsArgs {
    token: string;
    documentId: string;
    documentReassign: Array<DocumentReassign.DocumentReassign>;
    cardId: string;
    signature: string;
}
export class ReassignDocumentArgs {
    public token: string;
    public documentId: string;
    public documentReassign: Array<DocumentReassign.DocumentReassign>;
    public cardId: string;
    public signature: string;
    constructor(args: IReassignDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.documentReassign != null) {
            this.documentReassign = args.documentReassign;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentReassign] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.signature != null) {
            this.signature = args.signature;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[signature] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ReassignDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.documentReassign != null) {
            output.writeFieldBegin("documentReassign", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.documentReassign.length);
            this.documentReassign.forEach((value_173: DocumentReassign.DocumentReassign): void => {
                value_173.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.signature != null) {
            output.writeFieldBegin("signature", thrift.Thrift.Type.STRING, 5);
            output.writeString(this.signature);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ReassignDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_174: string = input.readString();
                        _args.token = value_174;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_175: string = input.readString();
                        _args.documentId = value_175;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_176: Array<DocumentReassign.DocumentReassign> = new Array<DocumentReassign.DocumentReassign>();
                        const metadata_29: thrift.TList = input.readListBegin();
                        const size_29: number = metadata_29.size;
                        for (let i_29: number = 0; i_29 < size_29; i_29++) {
                            const value_177: DocumentReassign.DocumentReassign = DocumentReassign.DocumentReassign.read(input);
                            value_176.push(value_177);
                        }
                        input.readListEnd();
                        _args.documentReassign = value_176;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_178: string = input.readString();
                        _args.cardId = value_178;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_179: string = input.readString();
                        _args.signature = value_179;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.documentReassign !== undefined && _args.cardId !== undefined && _args.signature !== undefined) {
            return new ReassignDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ReassignDocumentArgs from input");
        }
    }
}
export interface IReassignDocumentUsingServerKeyStorageArgsArgs {
    token: string;
    documentId: string;
    documentReassign: Array<DocumentReassign.DocumentReassign>;
    cardId: string;
    pKeyId: string;
    password: string;
}
export class ReassignDocumentUsingServerKeyStorageArgs {
    public token: string;
    public documentId: string;
    public documentReassign: Array<DocumentReassign.DocumentReassign>;
    public cardId: string;
    public pKeyId: string;
    public password: string;
    constructor(args: IReassignDocumentUsingServerKeyStorageArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.documentReassign != null) {
            this.documentReassign = args.documentReassign;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentReassign] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.pKeyId != null) {
            this.pKeyId = args.pKeyId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[pKeyId] is unset!");
        }
        if (args != null && args.password != null) {
            this.password = args.password;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[password] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ReassignDocumentUsingServerKeyStorageArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.documentReassign != null) {
            output.writeFieldBegin("documentReassign", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.documentReassign.length);
            this.documentReassign.forEach((value_180: DocumentReassign.DocumentReassign): void => {
                value_180.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.pKeyId != null) {
            output.writeFieldBegin("pKeyId", thrift.Thrift.Type.STRING, 5);
            output.writeString(this.pKeyId);
            output.writeFieldEnd();
        }
        if (this.password != null) {
            output.writeFieldBegin("password", thrift.Thrift.Type.STRING, 6);
            output.writeString(this.password);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ReassignDocumentUsingServerKeyStorageArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_181: string = input.readString();
                        _args.token = value_181;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_182: string = input.readString();
                        _args.documentId = value_182;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_183: Array<DocumentReassign.DocumentReassign> = new Array<DocumentReassign.DocumentReassign>();
                        const metadata_30: thrift.TList = input.readListBegin();
                        const size_30: number = metadata_30.size;
                        for (let i_30: number = 0; i_30 < size_30; i_30++) {
                            const value_184: DocumentReassign.DocumentReassign = DocumentReassign.DocumentReassign.read(input);
                            value_183.push(value_184);
                        }
                        input.readListEnd();
                        _args.documentReassign = value_183;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_185: string = input.readString();
                        _args.cardId = value_185;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_186: string = input.readString();
                        _args.pKeyId = value_186;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_187: string = input.readString();
                        _args.password = value_187;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.documentReassign !== undefined && _args.cardId !== undefined && _args.pKeyId !== undefined && _args.password !== undefined) {
            return new ReassignDocumentUsingServerKeyStorageArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ReassignDocumentUsingServerKeyStorageArgs from input");
        }
    }
}
export interface IReassignDocumentExtArgsArgs {
    token: string;
    documentId: string;
    cardId: string;
    documentReassign: Array<DocumentReassign.DocumentReassign>;
    addSignToReasign: Array<string>;
}
export class ReassignDocumentExtArgs {
    public token: string;
    public documentId: string;
    public cardId: string;
    public documentReassign: Array<DocumentReassign.DocumentReassign>;
    public addSignToReasign: Array<string>;
    constructor(args: IReassignDocumentExtArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.documentReassign != null) {
            this.documentReassign = args.documentReassign;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentReassign] is unset!");
        }
        if (args != null && args.addSignToReasign != null) {
            this.addSignToReasign = args.addSignToReasign;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[addSignToReasign] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ReassignDocumentExtArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.documentReassign != null) {
            output.writeFieldBegin("documentReassign", thrift.Thrift.Type.LIST, 4);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.documentReassign.length);
            this.documentReassign.forEach((value_188: DocumentReassign.DocumentReassign): void => {
                value_188.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.addSignToReasign != null) {
            output.writeFieldBegin("addSignToReasign", thrift.Thrift.Type.LIST, 5);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.addSignToReasign.length);
            this.addSignToReasign.forEach((value_189: string): void => {
                output.writeString(value_189);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ReassignDocumentExtArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_190: string = input.readString();
                        _args.token = value_190;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_191: string = input.readString();
                        _args.documentId = value_191;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_192: string = input.readString();
                        _args.cardId = value_192;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_193: Array<DocumentReassign.DocumentReassign> = new Array<DocumentReassign.DocumentReassign>();
                        const metadata_31: thrift.TList = input.readListBegin();
                        const size_31: number = metadata_31.size;
                        for (let i_31: number = 0; i_31 < size_31; i_31++) {
                            const value_194: DocumentReassign.DocumentReassign = DocumentReassign.DocumentReassign.read(input);
                            value_193.push(value_194);
                        }
                        input.readListEnd();
                        _args.documentReassign = value_193;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_195: Array<string> = new Array<string>();
                        const metadata_32: thrift.TList = input.readListBegin();
                        const size_32: number = metadata_32.size;
                        for (let i_32: number = 0; i_32 < size_32; i_32++) {
                            const value_196: string = input.readString();
                            value_195.push(value_196);
                        }
                        input.readListEnd();
                        _args.addSignToReasign = value_195;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.cardId !== undefined && _args.documentReassign !== undefined && _args.addSignToReasign !== undefined) {
            return new ReassignDocumentExtArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ReassignDocumentExtArgs from input");
        }
    }
}
export interface IRevokeChildCardsArgsArgs {
    token: string;
    cardId: string;
    deleteCard: boolean;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class RevokeChildCardsArgs {
    public token: string;
    public cardId: string;
    public deleteCard: boolean;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IRevokeChildCardsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.deleteCard != null) {
            this.deleteCard = args.deleteCard;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[deleteCard] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RevokeChildCardsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.deleteCard != null) {
            output.writeFieldBegin("deleteCard", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.deleteCard);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RevokeChildCardsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_197: string = input.readString();
                        _args.token = value_197;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_198: string = input.readString();
                        _args.cardId = value_198;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_199: boolean = input.readBool();
                        _args.deleteCard = value_199;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_200: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_200;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.cardId !== undefined && _args.deleteCard !== undefined && _args.accessPolicy !== undefined) {
            return new RevokeChildCardsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RevokeChildCardsArgs from input");
        }
    }
}
export interface ICreateOrUpdateAutomaticDocumentReassignArgsArgs {
    token: string;
    documentReassign: DocumentReassign.DocumentReassign;
}
export class CreateOrUpdateAutomaticDocumentReassignArgs {
    public token: string;
    public documentReassign: DocumentReassign.DocumentReassign;
    constructor(args: ICreateOrUpdateAutomaticDocumentReassignArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentReassign != null) {
            this.documentReassign = args.documentReassign;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentReassign] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateAutomaticDocumentReassignArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentReassign != null) {
            output.writeFieldBegin("documentReassign", thrift.Thrift.Type.STRUCT, 2);
            this.documentReassign.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateAutomaticDocumentReassignArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_201: string = input.readString();
                        _args.token = value_201;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_202: DocumentReassign.DocumentReassign = DocumentReassign.DocumentReassign.read(input);
                        _args.documentReassign = value_202;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentReassign !== undefined) {
            return new CreateOrUpdateAutomaticDocumentReassignArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateOrUpdateAutomaticDocumentReassignArgs from input");
        }
    }
}
export interface IDeleteAutomaticDocumentReassignArgsArgs {
    token: string;
    documentReassignId: string;
}
export class DeleteAutomaticDocumentReassignArgs {
    public token: string;
    public documentReassignId: string;
    constructor(args: IDeleteAutomaticDocumentReassignArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentReassignId != null) {
            this.documentReassignId = args.documentReassignId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentReassignId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteAutomaticDocumentReassignArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentReassignId != null) {
            output.writeFieldBegin("documentReassignId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentReassignId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteAutomaticDocumentReassignArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_203: string = input.readString();
                        _args.token = value_203;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_204: string = input.readString();
                        _args.documentReassignId = value_204;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentReassignId !== undefined) {
            return new DeleteAutomaticDocumentReassignArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteAutomaticDocumentReassignArgs from input");
        }
    }
}
export interface IChangeReassignControlArgsArgs {
    token: string;
    documentExecutionId: string;
    userId: string;
    reassignType: ExecutionReassignType.ExecutionReassignType;
}
export class ChangeReassignControlArgs {
    public token: string;
    public documentExecutionId: string;
    public userId: string;
    public reassignType: ExecutionReassignType.ExecutionReassignType;
    constructor(args: IChangeReassignControlArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentExecutionId != null) {
            this.documentExecutionId = args.documentExecutionId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentExecutionId] is unset!");
        }
        if (args != null && args.userId != null) {
            this.userId = args.userId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userId] is unset!");
        }
        if (args != null && args.reassignType != null) {
            this.reassignType = args.reassignType;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[reassignType] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeReassignControlArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentExecutionId != null) {
            output.writeFieldBegin("documentExecutionId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentExecutionId);
            output.writeFieldEnd();
        }
        if (this.userId != null) {
            output.writeFieldBegin("userId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.userId);
            output.writeFieldEnd();
        }
        if (this.reassignType != null) {
            output.writeFieldBegin("reassignType", thrift.Thrift.Type.I32, 4);
            output.writeI32(this.reassignType);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeReassignControlArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_205: string = input.readString();
                        _args.token = value_205;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_206: string = input.readString();
                        _args.documentExecutionId = value_206;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_207: string = input.readString();
                        _args.userId = value_207;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_208: ExecutionReassignType.ExecutionReassignType = input.readI32();
                        _args.reassignType = value_208;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentExecutionId !== undefined && _args.userId !== undefined && _args.reassignType !== undefined) {
            return new ChangeReassignControlArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeReassignControlArgs from input");
        }
    }
}
export interface IGetAllDocumentExecutionsArgsArgs {
    token: string;
    documentId: string;
    stageId: string;
    typeLink: DocumentExecutionTypeLink.DocumentExecutionTypeLink;
    filter: core.KazFilter;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class GetAllDocumentExecutionsArgs {
    public token: string;
    public documentId: string;
    public stageId: string;
    public typeLink: DocumentExecutionTypeLink.DocumentExecutionTypeLink;
    public filter: core.KazFilter;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IGetAllDocumentExecutionsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.stageId != null) {
            this.stageId = args.stageId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[stageId] is unset!");
        }
        if (args != null && args.typeLink != null) {
            this.typeLink = args.typeLink;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[typeLink] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentExecutionsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.stageId != null) {
            output.writeFieldBegin("stageId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.stageId);
            output.writeFieldEnd();
        }
        if (this.typeLink != null) {
            output.writeFieldBegin("typeLink", thrift.Thrift.Type.I32, 4);
            output.writeI32(this.typeLink);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 5);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 6);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentExecutionsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_209: string = input.readString();
                        _args.token = value_209;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_210: string = input.readString();
                        _args.documentId = value_210;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_211: string = input.readString();
                        _args.stageId = value_211;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_212: DocumentExecutionTypeLink.DocumentExecutionTypeLink = input.readI32();
                        _args.typeLink = value_212;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_213: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_213;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_214: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_214;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.stageId !== undefined && _args.typeLink !== undefined && _args.filter !== undefined && _args.accessPolicy !== undefined) {
            return new GetAllDocumentExecutionsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllDocumentExecutionsArgs from input");
        }
    }
}
export interface IGetDocumentExecutionArgsArgs {
    token: string;
    docExecutionId: string;
}
export class GetDocumentExecutionArgs {
    public token: string;
    public docExecutionId: string;
    constructor(args: IGetDocumentExecutionArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docExecutionId != null) {
            this.docExecutionId = args.docExecutionId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docExecutionId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentExecutionArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docExecutionId != null) {
            output.writeFieldBegin("docExecutionId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.docExecutionId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentExecutionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_215: string = input.readString();
                        _args.token = value_215;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_216: string = input.readString();
                        _args.docExecutionId = value_216;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docExecutionId !== undefined) {
            return new GetDocumentExecutionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetDocumentExecutionArgs from input");
        }
    }
}
export interface IChangeExecutorsForDocumentArgsArgs {
    token: string;
    docId: string;
    toAdd: Array<DocumentReassign.DocumentReassign>;
    toClose: Array<string>;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class ChangeExecutorsForDocumentArgs {
    public token: string;
    public docId: string;
    public toAdd: Array<DocumentReassign.DocumentReassign>;
    public toClose: Array<string>;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IChangeExecutorsForDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docId != null) {
            this.docId = args.docId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docId] is unset!");
        }
        if (args != null && args.toAdd != null) {
            this.toAdd = args.toAdd;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toAdd] is unset!");
        }
        if (args != null && args.toClose != null) {
            this.toClose = args.toClose;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toClose] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeExecutorsForDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docId != null) {
            output.writeFieldBegin("docId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.docId);
            output.writeFieldEnd();
        }
        if (this.toAdd != null) {
            output.writeFieldBegin("toAdd", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.toAdd.length);
            this.toAdd.forEach((value_217: DocumentReassign.DocumentReassign): void => {
                value_217.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.toClose != null) {
            output.writeFieldBegin("toClose", thrift.Thrift.Type.LIST, 4);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.toClose.length);
            this.toClose.forEach((value_218: string): void => {
                output.writeString(value_218);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 5);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeExecutorsForDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_219: string = input.readString();
                        _args.token = value_219;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_220: string = input.readString();
                        _args.docId = value_220;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_221: Array<DocumentReassign.DocumentReassign> = new Array<DocumentReassign.DocumentReassign>();
                        const metadata_33: thrift.TList = input.readListBegin();
                        const size_33: number = metadata_33.size;
                        for (let i_33: number = 0; i_33 < size_33; i_33++) {
                            const value_222: DocumentReassign.DocumentReassign = DocumentReassign.DocumentReassign.read(input);
                            value_221.push(value_222);
                        }
                        input.readListEnd();
                        _args.toAdd = value_221;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_223: Array<string> = new Array<string>();
                        const metadata_34: thrift.TList = input.readListBegin();
                        const size_34: number = metadata_34.size;
                        for (let i_34: number = 0; i_34 < size_34; i_34++) {
                            const value_224: string = input.readString();
                            value_223.push(value_224);
                        }
                        input.readListEnd();
                        _args.toClose = value_223;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_225: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_225;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docId !== undefined && _args.toAdd !== undefined && _args.toClose !== undefined && _args.accessPolicy !== undefined) {
            return new ChangeExecutorsForDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeExecutorsForDocumentArgs from input");
        }
    }
}
export interface ICreateAttachmentFromArgsArgs {
    token: string;
    documentId: string;
    cardId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    attCreateInfoList: Array<AttCreateInfo.AttCreateInfo>;
    processingType: AttachmentProcessingType.AttachmentProcessingType;
}
export class CreateAttachmentFromArgs {
    public token: string;
    public documentId: string;
    public cardId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public attCreateInfoList: Array<AttCreateInfo.AttCreateInfo>;
    public processingType: AttachmentProcessingType.AttachmentProcessingType;
    constructor(args: ICreateAttachmentFromArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.attCreateInfoList != null) {
            this.attCreateInfoList = args.attCreateInfoList;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attCreateInfoList] is unset!");
        }
        if (args != null && args.processingType != null) {
            this.processingType = args.processingType;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[processingType] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateAttachmentFromArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.attCreateInfoList != null) {
            output.writeFieldBegin("attCreateInfoList", thrift.Thrift.Type.LIST, 5);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.attCreateInfoList.length);
            this.attCreateInfoList.forEach((value_226: AttCreateInfo.AttCreateInfo): void => {
                value_226.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.processingType != null) {
            output.writeFieldBegin("processingType", thrift.Thrift.Type.I32, 6);
            output.writeI32(this.processingType);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateAttachmentFromArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_227: string = input.readString();
                        _args.token = value_227;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_228: string = input.readString();
                        _args.documentId = value_228;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_229: string = input.readString();
                        _args.cardId = value_229;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_230: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_230;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_231: Array<AttCreateInfo.AttCreateInfo> = new Array<AttCreateInfo.AttCreateInfo>();
                        const metadata_35: thrift.TList = input.readListBegin();
                        const size_35: number = metadata_35.size;
                        for (let i_35: number = 0; i_35 < size_35; i_35++) {
                            const value_232: AttCreateInfo.AttCreateInfo = AttCreateInfo.AttCreateInfo.read(input);
                            value_231.push(value_232);
                        }
                        input.readListEnd();
                        _args.attCreateInfoList = value_231;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_233: AttachmentProcessingType.AttachmentProcessingType = input.readI32();
                        _args.processingType = value_233;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.cardId !== undefined && _args.accessPolicy !== undefined && _args.attCreateInfoList !== undefined && _args.processingType !== undefined) {
            return new CreateAttachmentFromArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateAttachmentFromArgs from input");
        }
    }
}
export interface ICreateLoadableAttachmentArgsArgs {
    token: string;
    documentId: string;
    fileName: string;
    totalSize: number | Int64;
    countPortions: number;
    cardId: string;
    attachmmentId: string;
    forDraft: boolean;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    editMode: core.AttachmentEditMode;
    extStatus: core.AttachmentExtStatus;
}
export class CreateLoadableAttachmentArgs {
    public token: string;
    public documentId: string;
    public fileName: string;
    public totalSize: Int64;
    public countPortions: number;
    public cardId: string;
    public attachmmentId: string;
    public forDraft: boolean;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public editMode: core.AttachmentEditMode;
    public extStatus: core.AttachmentExtStatus;
    constructor(args: ICreateLoadableAttachmentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.fileName != null) {
            this.fileName = args.fileName;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[fileName] is unset!");
        }
        if (args != null && args.totalSize != null) {
            if (typeof args.totalSize === "number") {
                this.totalSize = new Int64(args.totalSize);
            }
            else {
                this.totalSize = args.totalSize;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[totalSize] is unset!");
        }
        if (args != null && args.countPortions != null) {
            this.countPortions = args.countPortions;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[countPortions] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.attachmmentId != null) {
            this.attachmmentId = args.attachmmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmmentId] is unset!");
        }
        if (args != null && args.forDraft != null) {
            this.forDraft = args.forDraft;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[forDraft] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.editMode != null) {
            this.editMode = args.editMode;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[editMode] is unset!");
        }
        if (args != null && args.extStatus != null) {
            this.extStatus = args.extStatus;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[extStatus] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateLoadableAttachmentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.fileName != null) {
            output.writeFieldBegin("fileName", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.fileName);
            output.writeFieldEnd();
        }
        if (this.totalSize != null) {
            output.writeFieldBegin("totalSize", thrift.Thrift.Type.I64, 4);
            output.writeI64(this.totalSize);
            output.writeFieldEnd();
        }
        if (this.countPortions != null) {
            output.writeFieldBegin("countPortions", thrift.Thrift.Type.I32, 5);
            output.writeI32(this.countPortions);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 6);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.attachmmentId != null) {
            output.writeFieldBegin("attachmmentId", thrift.Thrift.Type.STRING, 7);
            output.writeString(this.attachmmentId);
            output.writeFieldEnd();
        }
        if (this.forDraft != null) {
            output.writeFieldBegin("forDraft", thrift.Thrift.Type.BOOL, 8);
            output.writeBool(this.forDraft);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 9);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.editMode != null) {
            output.writeFieldBegin("editMode", thrift.Thrift.Type.I32, 10);
            output.writeI32(this.editMode);
            output.writeFieldEnd();
        }
        if (this.extStatus != null) {
            output.writeFieldBegin("extStatus", thrift.Thrift.Type.I32, 12);
            output.writeI32(this.extStatus);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateLoadableAttachmentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_234: string = input.readString();
                        _args.token = value_234;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_235: string = input.readString();
                        _args.documentId = value_235;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_236: string = input.readString();
                        _args.fileName = value_236;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_237: Int64 = input.readI64();
                        _args.totalSize = value_237;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_238: number = input.readI32();
                        _args.countPortions = value_238;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_239: string = input.readString();
                        _args.cardId = value_239;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_240: string = input.readString();
                        _args.attachmmentId = value_240;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 8:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_241: boolean = input.readBool();
                        _args.forDraft = value_241;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 9:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_242: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_242;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 10:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_243: core.AttachmentEditMode = input.readI32();
                        _args.editMode = value_243;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 12:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_244: core.AttachmentExtStatus = input.readI32();
                        _args.extStatus = value_244;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.fileName !== undefined && _args.totalSize !== undefined && _args.countPortions !== undefined && _args.cardId !== undefined && _args.attachmmentId !== undefined && _args.forDraft !== undefined && _args.accessPolicy !== undefined && _args.editMode !== undefined && _args.extStatus !== undefined) {
            return new CreateLoadableAttachmentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateLoadableAttachmentArgs from input");
        }
    }
}
export interface IUploadDocumentAttachmentPortionsArgsArgs {
    token: string;
    attachmentId: string;
    numberPortion: number;
    fileContentBytes: Buffer;
}
export class UploadDocumentAttachmentPortionsArgs {
    public token: string;
    public attachmentId: string;
    public numberPortion: number;
    public fileContentBytes: Buffer;
    constructor(args: IUploadDocumentAttachmentPortionsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId != null) {
            this.attachmentId = args.attachmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId] is unset!");
        }
        if (args != null && args.numberPortion != null) {
            this.numberPortion = args.numberPortion;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[numberPortion] is unset!");
        }
        if (args != null && args.fileContentBytes != null) {
            this.fileContentBytes = args.fileContentBytes;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[fileContentBytes] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UploadDocumentAttachmentPortionsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId != null) {
            output.writeFieldBegin("attachmentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId);
            output.writeFieldEnd();
        }
        if (this.numberPortion != null) {
            output.writeFieldBegin("numberPortion", thrift.Thrift.Type.I32, 3);
            output.writeI32(this.numberPortion);
            output.writeFieldEnd();
        }
        if (this.fileContentBytes != null) {
            output.writeFieldBegin("fileContentBytes", thrift.Thrift.Type.STRING, 4);
            output.writeBinary(this.fileContentBytes);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UploadDocumentAttachmentPortionsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_245: string = input.readString();
                        _args.token = value_245;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_246: string = input.readString();
                        _args.attachmentId = value_246;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_247: number = input.readI32();
                        _args.numberPortion = value_247;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_248: Buffer = input.readBinary();
                        _args.fileContentBytes = value_248;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId !== undefined && _args.numberPortion !== undefined && _args.fileContentBytes !== undefined) {
            return new UploadDocumentAttachmentPortionsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UploadDocumentAttachmentPortionsArgs from input");
        }
    }
}
export interface IAddPreviewToAttachmentArgsArgs {
    token: string;
    attachmentId: string;
    previewContent: Buffer;
    attachmentType: AttachmentType.AttachmentType;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class AddPreviewToAttachmentArgs {
    public token: string;
    public attachmentId: string;
    public previewContent: Buffer;
    public attachmentType: AttachmentType.AttachmentType;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IAddPreviewToAttachmentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId != null) {
            this.attachmentId = args.attachmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId] is unset!");
        }
        if (args != null && args.previewContent != null) {
            this.previewContent = args.previewContent;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[previewContent] is unset!");
        }
        if (args != null && args.attachmentType != null) {
            this.attachmentType = args.attachmentType;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentType] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddPreviewToAttachmentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId != null) {
            output.writeFieldBegin("attachmentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId);
            output.writeFieldEnd();
        }
        if (this.previewContent != null) {
            output.writeFieldBegin("previewContent", thrift.Thrift.Type.STRING, 3);
            output.writeBinary(this.previewContent);
            output.writeFieldEnd();
        }
        if (this.attachmentType != null) {
            output.writeFieldBegin("attachmentType", thrift.Thrift.Type.I32, 4);
            output.writeI32(this.attachmentType);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 5);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddPreviewToAttachmentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_249: string = input.readString();
                        _args.token = value_249;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_250: string = input.readString();
                        _args.attachmentId = value_250;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_251: Buffer = input.readBinary();
                        _args.previewContent = value_251;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_252: AttachmentType.AttachmentType = input.readI32();
                        _args.attachmentType = value_252;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_253: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_253;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId !== undefined && _args.previewContent !== undefined && _args.attachmentType !== undefined && _args.accessPolicy !== undefined) {
            return new AddPreviewToAttachmentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddPreviewToAttachmentArgs from input");
        }
    }
}
export interface IWriteHistoryOpenAttachmentArgsArgs {
    token: string;
    attachmentId: string;
    attachmentType: AttachmentType.AttachmentType;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class WriteHistoryOpenAttachmentArgs {
    public token: string;
    public attachmentId: string;
    public attachmentType: AttachmentType.AttachmentType;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IWriteHistoryOpenAttachmentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId != null) {
            this.attachmentId = args.attachmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId] is unset!");
        }
        if (args != null && args.attachmentType != null) {
            this.attachmentType = args.attachmentType;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentType] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("WriteHistoryOpenAttachmentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId != null) {
            output.writeFieldBegin("attachmentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId);
            output.writeFieldEnd();
        }
        if (this.attachmentType != null) {
            output.writeFieldBegin("attachmentType", thrift.Thrift.Type.I32, 3);
            output.writeI32(this.attachmentType);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): WriteHistoryOpenAttachmentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_254: string = input.readString();
                        _args.token = value_254;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_255: string = input.readString();
                        _args.attachmentId = value_255;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_256: AttachmentType.AttachmentType = input.readI32();
                        _args.attachmentType = value_256;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_257: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_257;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId !== undefined && _args.attachmentType !== undefined && _args.accessPolicy !== undefined) {
            return new WriteHistoryOpenAttachmentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read WriteHistoryOpenAttachmentArgs from input");
        }
    }
}
export interface IDownloadDocumentAttachmentArgsArgs {
    token: string;
    attachmentId: string;
    attachmentType: AttachmentType.AttachmentType;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class DownloadDocumentAttachmentArgs {
    public token: string;
    public attachmentId: string;
    public attachmentType: AttachmentType.AttachmentType;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IDownloadDocumentAttachmentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId != null) {
            this.attachmentId = args.attachmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId] is unset!");
        }
        if (args != null && args.attachmentType != null) {
            this.attachmentType = args.attachmentType;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentType] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DownloadDocumentAttachmentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId != null) {
            output.writeFieldBegin("attachmentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId);
            output.writeFieldEnd();
        }
        if (this.attachmentType != null) {
            output.writeFieldBegin("attachmentType", thrift.Thrift.Type.I32, 3);
            output.writeI32(this.attachmentType);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DownloadDocumentAttachmentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_258: string = input.readString();
                        _args.token = value_258;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_259: string = input.readString();
                        _args.attachmentId = value_259;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_260: AttachmentType.AttachmentType = input.readI32();
                        _args.attachmentType = value_260;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_261: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_261;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId !== undefined && _args.attachmentType !== undefined && _args.accessPolicy !== undefined) {
            return new DownloadDocumentAttachmentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DownloadDocumentAttachmentArgs from input");
        }
    }
}
export interface IRotatePdfPagesArgsArgs {
    token: string;
    attachmentId: string;
    pages: string;
    angle: number;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class RotatePdfPagesArgs {
    public token: string;
    public attachmentId: string;
    public pages: string;
    public angle: number;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IRotatePdfPagesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId != null) {
            this.attachmentId = args.attachmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId] is unset!");
        }
        if (args != null && args.pages != null) {
            this.pages = args.pages;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[pages] is unset!");
        }
        if (args != null && args.angle != null) {
            this.angle = args.angle;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[angle] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RotatePdfPagesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId != null) {
            output.writeFieldBegin("attachmentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId);
            output.writeFieldEnd();
        }
        if (this.pages != null) {
            output.writeFieldBegin("pages", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.pages);
            output.writeFieldEnd();
        }
        if (this.angle != null) {
            output.writeFieldBegin("angle", thrift.Thrift.Type.I32, 4);
            output.writeI32(this.angle);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 5);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RotatePdfPagesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_262: string = input.readString();
                        _args.token = value_262;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_263: string = input.readString();
                        _args.attachmentId = value_263;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_264: string = input.readString();
                        _args.pages = value_264;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_265: number = input.readI32();
                        _args.angle = value_265;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_266: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_266;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId !== undefined && _args.pages !== undefined && _args.angle !== undefined && _args.accessPolicy !== undefined) {
            return new RotatePdfPagesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RotatePdfPagesArgs from input");
        }
    }
}
export interface IAddAttachmentsToDocumentArgsArgs {
    token: string;
    documentId: string;
    attachments: Array<AttCreateInfo.AttCreateInfo>;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class AddAttachmentsToDocumentArgs {
    public token: string;
    public documentId: string;
    public attachments: Array<AttCreateInfo.AttCreateInfo>;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IAddAttachmentsToDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.attachments != null) {
            this.attachments = args.attachments;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachments] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddAttachmentsToDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.attachments != null) {
            output.writeFieldBegin("attachments", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.attachments.length);
            this.attachments.forEach((value_267: AttCreateInfo.AttCreateInfo): void => {
                value_267.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddAttachmentsToDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_268: string = input.readString();
                        _args.token = value_268;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_269: string = input.readString();
                        _args.documentId = value_269;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_270: Array<AttCreateInfo.AttCreateInfo> = new Array<AttCreateInfo.AttCreateInfo>();
                        const metadata_36: thrift.TList = input.readListBegin();
                        const size_36: number = metadata_36.size;
                        for (let i_36: number = 0; i_36 < size_36; i_36++) {
                            const value_271: AttCreateInfo.AttCreateInfo = AttCreateInfo.AttCreateInfo.read(input);
                            value_270.push(value_271);
                        }
                        input.readListEnd();
                        _args.attachments = value_270;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_272: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_272;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.attachments !== undefined && _args.accessPolicy !== undefined) {
            return new AddAttachmentsToDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddAttachmentsToDocumentArgs from input");
        }
    }
}
export interface IRemoveDocumentAttachmentArgsArgs {
    token: string;
    attachmentId: string;
    removeOldVersions: boolean;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class RemoveDocumentAttachmentArgs {
    public token: string;
    public attachmentId: string;
    public removeOldVersions: boolean;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IRemoveDocumentAttachmentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId != null) {
            this.attachmentId = args.attachmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId] is unset!");
        }
        if (args != null && args.removeOldVersions != null) {
            this.removeOldVersions = args.removeOldVersions;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[removeOldVersions] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveDocumentAttachmentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId != null) {
            output.writeFieldBegin("attachmentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId);
            output.writeFieldEnd();
        }
        if (this.removeOldVersions != null) {
            output.writeFieldBegin("removeOldVersions", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.removeOldVersions);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveDocumentAttachmentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_273: string = input.readString();
                        _args.token = value_273;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_274: string = input.readString();
                        _args.attachmentId = value_274;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_275: boolean = input.readBool();
                        _args.removeOldVersions = value_275;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_276: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_276;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId !== undefined && _args.removeOldVersions !== undefined && _args.accessPolicy !== undefined) {
            return new RemoveDocumentAttachmentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveDocumentAttachmentArgs from input");
        }
    }
}
export interface IMarkAsWaitForPublishArgsArgs {
    token: string;
    attachmentId: string;
}
export class MarkAsWaitForPublishArgs {
    public token: string;
    public attachmentId: string;
    constructor(args: IMarkAsWaitForPublishArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId != null) {
            this.attachmentId = args.attachmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MarkAsWaitForPublishArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId != null) {
            output.writeFieldBegin("attachmentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MarkAsWaitForPublishArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_277: string = input.readString();
                        _args.token = value_277;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_278: string = input.readString();
                        _args.attachmentId = value_278;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId !== undefined) {
            return new MarkAsWaitForPublishArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read MarkAsWaitForPublishArgs from input");
        }
    }
}
export interface IChangeAttachmentEditModeArgsArgs {
    token: string;
    attachmentId: string;
    editMode: core.AttachmentEditMode;
}
export class ChangeAttachmentEditModeArgs {
    public token: string;
    public attachmentId: string;
    public editMode: core.AttachmentEditMode;
    constructor(args: IChangeAttachmentEditModeArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId != null) {
            this.attachmentId = args.attachmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId] is unset!");
        }
        if (args != null && args.editMode != null) {
            this.editMode = args.editMode;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[editMode] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeAttachmentEditModeArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId != null) {
            output.writeFieldBegin("attachmentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId);
            output.writeFieldEnd();
        }
        if (this.editMode != null) {
            output.writeFieldBegin("editMode", thrift.Thrift.Type.I32, 3);
            output.writeI32(this.editMode);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeAttachmentEditModeArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_279: string = input.readString();
                        _args.token = value_279;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_280: string = input.readString();
                        _args.attachmentId = value_280;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_281: core.AttachmentEditMode = input.readI32();
                        _args.editMode = value_281;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId !== undefined && _args.editMode !== undefined) {
            return new ChangeAttachmentEditModeArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeAttachmentEditModeArgs from input");
        }
    }
}
export interface IGetDocumentAttachmentsArgsArgs {
    token: string;
    documentId: string;
    latestOnly: boolean;
    filter: core.KazFilter;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class GetDocumentAttachmentsArgs {
    public token: string;
    public documentId: string;
    public latestOnly: boolean;
    public filter: core.KazFilter;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IGetDocumentAttachmentsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.latestOnly != null) {
            this.latestOnly = args.latestOnly;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[latestOnly] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentAttachmentsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.latestOnly != null) {
            output.writeFieldBegin("latestOnly", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.latestOnly);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 4);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 5);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentAttachmentsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_282: string = input.readString();
                        _args.token = value_282;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_283: string = input.readString();
                        _args.documentId = value_283;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_284: boolean = input.readBool();
                        _args.latestOnly = value_284;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_285: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_285;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_286: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_286;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.latestOnly !== undefined && _args.filter !== undefined && _args.accessPolicy !== undefined) {
            return new GetDocumentAttachmentsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetDocumentAttachmentsArgs from input");
        }
    }
}
export interface IGetDocumentAttachmentByIdArgsArgs {
    token: string;
    attachmentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class GetDocumentAttachmentByIdArgs {
    public token: string;
    public attachmentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IGetDocumentAttachmentByIdArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId != null) {
            this.attachmentId = args.attachmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentAttachmentByIdArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId != null) {
            output.writeFieldBegin("attachmentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentAttachmentByIdArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_287: string = input.readString();
                        _args.token = value_287;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_288: string = input.readString();
                        _args.attachmentId = value_288;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_289: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_289;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId !== undefined && _args.accessPolicy !== undefined) {
            return new GetDocumentAttachmentByIdArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetDocumentAttachmentByIdArgs from input");
        }
    }
}
export interface IGetAllDocumentAttachmentVersionsArgsArgs {
    token: string;
    attachmentId: string;
    filter: core.KazFilter;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class GetAllDocumentAttachmentVersionsArgs {
    public token: string;
    public attachmentId: string;
    public filter: core.KazFilter;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IGetAllDocumentAttachmentVersionsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId != null) {
            this.attachmentId = args.attachmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentAttachmentVersionsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId != null) {
            output.writeFieldBegin("attachmentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 3);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentAttachmentVersionsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_290: string = input.readString();
                        _args.token = value_290;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_291: string = input.readString();
                        _args.attachmentId = value_291;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_292: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_292;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_293: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_293;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId !== undefined && _args.filter !== undefined && _args.accessPolicy !== undefined) {
            return new GetAllDocumentAttachmentVersionsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllDocumentAttachmentVersionsArgs from input");
        }
    }
}
export interface IChangeAttachmentsVisibilityArgsArgs {
    token: string;
    toHideList: Array<string>;
    toShowList: Array<string>;
}
export class ChangeAttachmentsVisibilityArgs {
    public token: string;
    public toHideList: Array<string>;
    public toShowList: Array<string>;
    constructor(args: IChangeAttachmentsVisibilityArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.toHideList != null) {
            this.toHideList = args.toHideList;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toHideList] is unset!");
        }
        if (args != null && args.toShowList != null) {
            this.toShowList = args.toShowList;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toShowList] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeAttachmentsVisibilityArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.toHideList != null) {
            output.writeFieldBegin("toHideList", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.toHideList.length);
            this.toHideList.forEach((value_294: string): void => {
                output.writeString(value_294);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.toShowList != null) {
            output.writeFieldBegin("toShowList", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.toShowList.length);
            this.toShowList.forEach((value_295: string): void => {
                output.writeString(value_295);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeAttachmentsVisibilityArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_296: string = input.readString();
                        _args.token = value_296;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_297: Array<string> = new Array<string>();
                        const metadata_37: thrift.TList = input.readListBegin();
                        const size_37: number = metadata_37.size;
                        for (let i_37: number = 0; i_37 < size_37; i_37++) {
                            const value_298: string = input.readString();
                            value_297.push(value_298);
                        }
                        input.readListEnd();
                        _args.toHideList = value_297;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_299: Array<string> = new Array<string>();
                        const metadata_38: thrift.TList = input.readListBegin();
                        const size_38: number = metadata_38.size;
                        for (let i_38: number = 0; i_38 < size_38; i_38++) {
                            const value_300: string = input.readString();
                            value_299.push(value_300);
                        }
                        input.readListEnd();
                        _args.toShowList = value_299;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.toHideList !== undefined && _args.toShowList !== undefined) {
            return new ChangeAttachmentsVisibilityArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeAttachmentsVisibilityArgs from input");
        }
    }
}
export interface ICreateOrUpdateDocumentCommentArgsArgs {
    token: string;
    documentComment: DocumentComment.DocumentComment;
    addToComment: string;
    changeType: ChangeType.ChangeType;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class CreateOrUpdateDocumentCommentArgs {
    public token: string;
    public documentComment: DocumentComment.DocumentComment;
    public addToComment: string;
    public changeType: ChangeType.ChangeType;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: ICreateOrUpdateDocumentCommentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentComment != null) {
            this.documentComment = args.documentComment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentComment] is unset!");
        }
        if (args != null && args.addToComment != null) {
            this.addToComment = args.addToComment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[addToComment] is unset!");
        }
        if (args != null && args.changeType != null) {
            this.changeType = args.changeType;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[changeType] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateDocumentCommentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentComment != null) {
            output.writeFieldBegin("documentComment", thrift.Thrift.Type.STRUCT, 2);
            this.documentComment.write(output);
            output.writeFieldEnd();
        }
        if (this.addToComment != null) {
            output.writeFieldBegin("addToComment", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.addToComment);
            output.writeFieldEnd();
        }
        if (this.changeType != null) {
            output.writeFieldBegin("changeType", thrift.Thrift.Type.I32, 4);
            output.writeI32(this.changeType);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 5);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateDocumentCommentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_301: string = input.readString();
                        _args.token = value_301;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_302: DocumentComment.DocumentComment = DocumentComment.DocumentComment.read(input);
                        _args.documentComment = value_302;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_303: string = input.readString();
                        _args.addToComment = value_303;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_304: ChangeType.ChangeType = input.readI32();
                        _args.changeType = value_304;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_305: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_305;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentComment !== undefined && _args.addToComment !== undefined && _args.changeType !== undefined && _args.accessPolicy !== undefined) {
            return new CreateOrUpdateDocumentCommentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateOrUpdateDocumentCommentArgs from input");
        }
    }
}
export interface IGetAllDocumentCommentsArgsArgs {
    token: string;
    documentId: string;
    filter: core.KazFilter;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class GetAllDocumentCommentsArgs {
    public token: string;
    public documentId: string;
    public filter: core.KazFilter;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IGetAllDocumentCommentsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentCommentsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 3);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentCommentsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_306: string = input.readString();
                        _args.token = value_306;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_307: string = input.readString();
                        _args.documentId = value_307;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_308: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_308;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_309: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_309;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.filter !== undefined && _args.accessPolicy !== undefined) {
            return new GetAllDocumentCommentsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllDocumentCommentsArgs from input");
        }
    }
}
export interface IDeleteDocumentCommentArgsArgs {
    token: string;
    documentCommentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class DeleteDocumentCommentArgs {
    public token: string;
    public documentCommentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IDeleteDocumentCommentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentCommentId != null) {
            this.documentCommentId = args.documentCommentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentCommentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteDocumentCommentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentCommentId != null) {
            output.writeFieldBegin("documentCommentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentCommentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteDocumentCommentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_310: string = input.readString();
                        _args.token = value_310;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_311: string = input.readString();
                        _args.documentCommentId = value_311;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_312: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_312;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentCommentId !== undefined && _args.accessPolicy !== undefined) {
            return new DeleteDocumentCommentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteDocumentCommentArgs from input");
        }
    }
}
export interface ICreateOrUpdateDocumentContentHolderLinkArgsArgs {
    token: string;
    documentId: string;
    holderLinks: Array<ContentHolderLink.ContentHolderLink>;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class CreateOrUpdateDocumentContentHolderLinkArgs {
    public token: string;
    public documentId: string;
    public holderLinks: Array<ContentHolderLink.ContentHolderLink>;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: ICreateOrUpdateDocumentContentHolderLinkArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.holderLinks != null) {
            this.holderLinks = args.holderLinks;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[holderLinks] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateDocumentContentHolderLinkArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.holderLinks != null) {
            output.writeFieldBegin("holderLinks", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.holderLinks.length);
            this.holderLinks.forEach((value_313: ContentHolderLink.ContentHolderLink): void => {
                value_313.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateDocumentContentHolderLinkArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_314: string = input.readString();
                        _args.token = value_314;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_315: string = input.readString();
                        _args.documentId = value_315;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_316: Array<ContentHolderLink.ContentHolderLink> = new Array<ContentHolderLink.ContentHolderLink>();
                        const metadata_39: thrift.TList = input.readListBegin();
                        const size_39: number = metadata_39.size;
                        for (let i_39: number = 0; i_39 < size_39; i_39++) {
                            const value_317: ContentHolderLink.ContentHolderLink = ContentHolderLink.ContentHolderLink.read(input);
                            value_316.push(value_317);
                        }
                        input.readListEnd();
                        _args.holderLinks = value_316;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_318: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_318;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.holderLinks !== undefined && _args.accessPolicy !== undefined) {
            return new CreateOrUpdateDocumentContentHolderLinkArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateOrUpdateDocumentContentHolderLinkArgs from input");
        }
    }
}
export interface IDocumentToArchiveArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class DocumentToArchiveArgs {
    public token: string;
    public documentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IDocumentToArchiveArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DocumentToArchiveArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DocumentToArchiveArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_319: string = input.readString();
                        _args.token = value_319;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_320: string = input.readString();
                        _args.documentId = value_320;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_321: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_321;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined) {
            return new DocumentToArchiveArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DocumentToArchiveArgs from input");
        }
    }
}
export interface IGetAllResponsibleForDocumentArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    filter: core.KazFilter;
}
export class GetAllResponsibleForDocumentArgs {
    public token: string;
    public documentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public filter: core.KazFilter;
    constructor(args: IGetAllResponsibleForDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllResponsibleForDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 4);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllResponsibleForDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_322: string = input.readString();
                        _args.token = value_322;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_323: string = input.readString();
                        _args.documentId = value_323;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_324: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_324;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_325: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_325;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined && _args.filter !== undefined) {
            return new GetAllResponsibleForDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllResponsibleForDocumentArgs from input");
        }
    }
}
export interface IAddResponsibleForDocumentArgsArgs {
    token: string;
    documentId: string;
    users: Array<core.UserOrGroup>;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class AddResponsibleForDocumentArgs {
    public token: string;
    public documentId: string;
    public users: Array<core.UserOrGroup>;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IAddResponsibleForDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.users != null) {
            this.users = args.users;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[users] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddResponsibleForDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.users != null) {
            output.writeFieldBegin("users", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.users.length);
            this.users.forEach((value_326: core.UserOrGroup): void => {
                value_326.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddResponsibleForDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_327: string = input.readString();
                        _args.token = value_327;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_328: string = input.readString();
                        _args.documentId = value_328;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_329: Array<core.UserOrGroup> = new Array<core.UserOrGroup>();
                        const metadata_40: thrift.TList = input.readListBegin();
                        const size_40: number = metadata_40.size;
                        for (let i_40: number = 0; i_40 < size_40; i_40++) {
                            const value_330: core.UserOrGroup = core.UserOrGroup.read(input);
                            value_329.push(value_330);
                        }
                        input.readListEnd();
                        _args.users = value_329;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_331: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_331;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.users !== undefined && _args.accessPolicy !== undefined) {
            return new AddResponsibleForDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddResponsibleForDocumentArgs from input");
        }
    }
}
export interface IRemoveResponsibleForDocumentArgsArgs {
    token: string;
    documentId: string;
    users: Array<core.UserOrGroup>;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class RemoveResponsibleForDocumentArgs {
    public token: string;
    public documentId: string;
    public users: Array<core.UserOrGroup>;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IRemoveResponsibleForDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.users != null) {
            this.users = args.users;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[users] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveResponsibleForDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.users != null) {
            output.writeFieldBegin("users", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.users.length);
            this.users.forEach((value_332: core.UserOrGroup): void => {
                value_332.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveResponsibleForDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_333: string = input.readString();
                        _args.token = value_333;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_334: string = input.readString();
                        _args.documentId = value_334;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_335: Array<core.UserOrGroup> = new Array<core.UserOrGroup>();
                        const metadata_41: thrift.TList = input.readListBegin();
                        const size_41: number = metadata_41.size;
                        for (let i_41: number = 0; i_41 < size_41; i_41++) {
                            const value_336: core.UserOrGroup = core.UserOrGroup.read(input);
                            value_335.push(value_336);
                        }
                        input.readListEnd();
                        _args.users = value_335;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_337: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_337;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.users !== undefined && _args.accessPolicy !== undefined) {
            return new RemoveResponsibleForDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveResponsibleForDocumentArgs from input");
        }
    }
}
export interface IGetDocHistoryPageArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    filter: core.KazFilter;
}
export class GetDocHistoryPageArgs {
    public token: string;
    public documentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public filter: core.KazFilter;
    constructor(args: IGetDocHistoryPageArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocHistoryPageArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 4);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocHistoryPageArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_338: string = input.readString();
                        _args.token = value_338;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_339: string = input.readString();
                        _args.documentId = value_339;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_340: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_340;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_341: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_341;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined && _args.filter !== undefined) {
            return new GetDocHistoryPageArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetDocHistoryPageArgs from input");
        }
    }
}
export interface IGetAllNewsArgsArgs {
    token: string;
    filter: core.KazFilter;
}
export class GetAllNewsArgs {
    public token: string;
    public filter: core.KazFilter;
    constructor(args: IGetAllNewsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllNewsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllNewsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_342: string = input.readString();
                        _args.token = value_342;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_343: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_343;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllNewsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllNewsArgs from input");
        }
    }
}
export interface IGetTasksByDateArgsArgs {
    token: string;
    date: number | Int64;
}
export class GetTasksByDateArgs {
    public token: string;
    public date: Int64;
    constructor(args: IGetTasksByDateArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.date != null) {
            if (typeof args.date === "number") {
                this.date = new Int64(args.date);
            }
            else {
                this.date = args.date;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[date] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetTasksByDateArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.date != null) {
            output.writeFieldBegin("date", thrift.Thrift.Type.I64, 2);
            output.writeI64(this.date);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetTasksByDateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_344: string = input.readString();
                        _args.token = value_344;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_345: Int64 = input.readI64();
                        _args.date = value_345;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.date !== undefined) {
            return new GetTasksByDateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetTasksByDateArgs from input");
        }
    }
}
export interface IGenerateDocumentNumberArgsArgs {
    token: string;
    documentId: string;
    docNumber: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class GenerateDocumentNumberArgs {
    public token: string;
    public documentId: string;
    public docNumber: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IGenerateDocumentNumberArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.docNumber != null) {
            this.docNumber = args.docNumber;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docNumber] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GenerateDocumentNumberArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.docNumber != null) {
            output.writeFieldBegin("docNumber", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.docNumber);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GenerateDocumentNumberArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_346: string = input.readString();
                        _args.token = value_346;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_347: string = input.readString();
                        _args.documentId = value_347;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_348: string = input.readString();
                        _args.docNumber = value_348;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_349: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_349;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.docNumber !== undefined && _args.accessPolicy !== undefined) {
            return new GenerateDocumentNumberArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GenerateDocumentNumberArgs from input");
        }
    }
}
export interface ISetDocumentViewedArgsArgs {
    token: string;
    documentId: string;
    viewed: boolean;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class SetDocumentViewedArgs {
    public token: string;
    public documentId: string;
    public viewed: boolean;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: ISetDocumentViewedArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.viewed != null) {
            this.viewed = args.viewed;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[viewed] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetDocumentViewedArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.viewed != null) {
            output.writeFieldBegin("viewed", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.viewed);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetDocumentViewedArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_350: string = input.readString();
                        _args.token = value_350;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_351: string = input.readString();
                        _args.documentId = value_351;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_352: boolean = input.readBool();
                        _args.viewed = value_352;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_353: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_353;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.viewed !== undefined && _args.accessPolicy !== undefined) {
            return new SetDocumentViewedArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetDocumentViewedArgs from input");
        }
    }
}
export interface IGetAllDocumentRelationsArgsArgs {
    token: string;
    documentId: string;
    filter: core.KazFilter;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class GetAllDocumentRelationsArgs {
    public token: string;
    public documentId: string;
    public filter: core.KazFilter;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IGetAllDocumentRelationsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentRelationsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 3);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentRelationsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_354: string = input.readString();
                        _args.token = value_354;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_355: string = input.readString();
                        _args.documentId = value_355;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_356: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_356;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_357: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_357;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.filter !== undefined && _args.accessPolicy !== undefined) {
            return new GetAllDocumentRelationsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllDocumentRelationsArgs from input");
        }
    }
}
export interface IChangeRelationsArgsArgs {
    token: string;
    toCreate: Array<DocumentRelation.DocumentRelation>;
    toRemove: Array<string>;
}
export class ChangeRelationsArgs {
    public token: string;
    public toCreate: Array<DocumentRelation.DocumentRelation>;
    public toRemove: Array<string>;
    constructor(args: IChangeRelationsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.toCreate != null) {
            this.toCreate = args.toCreate;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toCreate] is unset!");
        }
        if (args != null && args.toRemove != null) {
            this.toRemove = args.toRemove;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toRemove] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeRelationsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.toCreate != null) {
            output.writeFieldBegin("toCreate", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.toCreate.length);
            this.toCreate.forEach((value_358: DocumentRelation.DocumentRelation): void => {
                value_358.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.toRemove != null) {
            output.writeFieldBegin("toRemove", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.toRemove.length);
            this.toRemove.forEach((value_359: string): void => {
                output.writeString(value_359);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeRelationsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_360: string = input.readString();
                        _args.token = value_360;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_361: Array<DocumentRelation.DocumentRelation> = new Array<DocumentRelation.DocumentRelation>();
                        const metadata_42: thrift.TList = input.readListBegin();
                        const size_42: number = metadata_42.size;
                        for (let i_42: number = 0; i_42 < size_42; i_42++) {
                            const value_362: DocumentRelation.DocumentRelation = DocumentRelation.DocumentRelation.read(input);
                            value_361.push(value_362);
                        }
                        input.readListEnd();
                        _args.toCreate = value_361;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_363: Array<string> = new Array<string>();
                        const metadata_43: thrift.TList = input.readListBegin();
                        const size_43: number = metadata_43.size;
                        for (let i_43: number = 0; i_43 < size_43; i_43++) {
                            const value_364: string = input.readString();
                            value_363.push(value_364);
                        }
                        input.readListEnd();
                        _args.toRemove = value_363;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.toCreate !== undefined && _args.toRemove !== undefined) {
            return new ChangeRelationsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeRelationsArgs from input");
        }
    }
}
export interface IChangeSubStatusArgsArgs {
    token: string;
    documentId: string;
    subStatus: DocPatternStageSubStatus.DocPatternStageSubStatus;
    comment: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class ChangeSubStatusArgs {
    public token: string;
    public documentId: string;
    public subStatus: DocPatternStageSubStatus.DocPatternStageSubStatus;
    public comment: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IChangeSubStatusArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.subStatus != null) {
            this.subStatus = args.subStatus;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[subStatus] is unset!");
        }
        if (args != null && args.comment != null) {
            this.comment = args.comment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[comment] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeSubStatusArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.subStatus != null) {
            output.writeFieldBegin("subStatus", thrift.Thrift.Type.I32, 3);
            output.writeI32(this.subStatus);
            output.writeFieldEnd();
        }
        if (this.comment != null) {
            output.writeFieldBegin("comment", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.comment);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 5);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeSubStatusArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_365: string = input.readString();
                        _args.token = value_365;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_366: string = input.readString();
                        _args.documentId = value_366;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_367: DocPatternStageSubStatus.DocPatternStageSubStatus = input.readI32();
                        _args.subStatus = value_367;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_368: string = input.readString();
                        _args.comment = value_368;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_369: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_369;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.subStatus !== undefined && _args.comment !== undefined && _args.accessPolicy !== undefined) {
            return new ChangeSubStatusArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeSubStatusArgs from input");
        }
    }
}
export interface IRevertSubStatusArgsArgs {
    token: string;
    documentId: string;
    subStatus: DocPatternStageSubStatus.DocPatternStageSubStatus;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class RevertSubStatusArgs {
    public token: string;
    public documentId: string;
    public subStatus: DocPatternStageSubStatus.DocPatternStageSubStatus;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IRevertSubStatusArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.subStatus != null) {
            this.subStatus = args.subStatus;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[subStatus] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RevertSubStatusArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.subStatus != null) {
            output.writeFieldBegin("subStatus", thrift.Thrift.Type.I32, 3);
            output.writeI32(this.subStatus);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RevertSubStatusArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_370: string = input.readString();
                        _args.token = value_370;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_371: string = input.readString();
                        _args.documentId = value_371;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_372: DocPatternStageSubStatus.DocPatternStageSubStatus = input.readI32();
                        _args.subStatus = value_372;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_373: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_373;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.subStatus !== undefined && _args.accessPolicy !== undefined) {
            return new RevertSubStatusArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RevertSubStatusArgs from input");
        }
    }
}
export interface IIncreaseDeadlineForDocumentOrDocumentExecutionArgsArgs {
    token: string;
    documentId: string;
    documentExecution: string;
    deadlineTime: number | Int64;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class IncreaseDeadlineForDocumentOrDocumentExecutionArgs {
    public token: string;
    public documentId: string;
    public documentExecution: string;
    public deadlineTime: Int64;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IIncreaseDeadlineForDocumentOrDocumentExecutionArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.documentExecution != null) {
            this.documentExecution = args.documentExecution;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentExecution] is unset!");
        }
        if (args != null && args.deadlineTime != null) {
            if (typeof args.deadlineTime === "number") {
                this.deadlineTime = new Int64(args.deadlineTime);
            }
            else {
                this.deadlineTime = args.deadlineTime;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[deadlineTime] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("IncreaseDeadlineForDocumentOrDocumentExecutionArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.documentExecution != null) {
            output.writeFieldBegin("documentExecution", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.documentExecution);
            output.writeFieldEnd();
        }
        if (this.deadlineTime != null) {
            output.writeFieldBegin("deadlineTime", thrift.Thrift.Type.I64, 4);
            output.writeI64(this.deadlineTime);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 5);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): IncreaseDeadlineForDocumentOrDocumentExecutionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_374: string = input.readString();
                        _args.token = value_374;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_375: string = input.readString();
                        _args.documentId = value_375;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_376: string = input.readString();
                        _args.documentExecution = value_376;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_377: Int64 = input.readI64();
                        _args.deadlineTime = value_377;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_378: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_378;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.documentExecution !== undefined && _args.deadlineTime !== undefined && _args.accessPolicy !== undefined) {
            return new IncreaseDeadlineForDocumentOrDocumentExecutionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read IncreaseDeadlineForDocumentOrDocumentExecutionArgs from input");
        }
    }
}
export interface IAddAdditionalConfirmersArgsArgs {
    token: string;
    cardId: string;
    users: Array<string>;
    deadlineDate: number | Int64;
    comment: string;
    requireMyParticipation: boolean;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class AddAdditionalConfirmersArgs {
    public token: string;
    public cardId: string;
    public users: Array<string>;
    public deadlineDate: Int64;
    public comment: string;
    public requireMyParticipation: boolean;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IAddAdditionalConfirmersArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.users != null) {
            this.users = args.users;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[users] is unset!");
        }
        if (args != null && args.deadlineDate != null) {
            if (typeof args.deadlineDate === "number") {
                this.deadlineDate = new Int64(args.deadlineDate);
            }
            else {
                this.deadlineDate = args.deadlineDate;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[deadlineDate] is unset!");
        }
        if (args != null && args.comment != null) {
            this.comment = args.comment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[comment] is unset!");
        }
        if (args != null && args.requireMyParticipation != null) {
            this.requireMyParticipation = args.requireMyParticipation;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[requireMyParticipation] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddAdditionalConfirmersArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.users != null) {
            output.writeFieldBegin("users", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.users.length);
            this.users.forEach((value_379: string): void => {
                output.writeString(value_379);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.deadlineDate != null) {
            output.writeFieldBegin("deadlineDate", thrift.Thrift.Type.I64, 4);
            output.writeI64(this.deadlineDate);
            output.writeFieldEnd();
        }
        if (this.comment != null) {
            output.writeFieldBegin("comment", thrift.Thrift.Type.STRING, 5);
            output.writeString(this.comment);
            output.writeFieldEnd();
        }
        if (this.requireMyParticipation != null) {
            output.writeFieldBegin("requireMyParticipation", thrift.Thrift.Type.BOOL, 6);
            output.writeBool(this.requireMyParticipation);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 7);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddAdditionalConfirmersArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_380: string = input.readString();
                        _args.token = value_380;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_381: string = input.readString();
                        _args.cardId = value_381;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_382: Array<string> = new Array<string>();
                        const metadata_44: thrift.TList = input.readListBegin();
                        const size_44: number = metadata_44.size;
                        for (let i_44: number = 0; i_44 < size_44; i_44++) {
                            const value_383: string = input.readString();
                            value_382.push(value_383);
                        }
                        input.readListEnd();
                        _args.users = value_382;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_384: Int64 = input.readI64();
                        _args.deadlineDate = value_384;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_385: string = input.readString();
                        _args.comment = value_385;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_386: boolean = input.readBool();
                        _args.requireMyParticipation = value_386;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_387: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_387;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.cardId !== undefined && _args.users !== undefined && _args.deadlineDate !== undefined && _args.comment !== undefined && _args.requireMyParticipation !== undefined && _args.accessPolicy !== undefined) {
            return new AddAdditionalConfirmersArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddAdditionalConfirmersArgs from input");
        }
    }
}
export interface ISetAdditionalDecisionArgsArgs {
    token: string;
    userDecision: Map<string, string>;
    cardId: string;
    comment: string;
    returnToParentStage: boolean;
    signature: string;
}
export class SetAdditionalDecisionArgs {
    public token: string;
    public userDecision: Map<string, string>;
    public cardId: string;
    public comment: string;
    public returnToParentStage: boolean;
    public signature: string;
    constructor(args: ISetAdditionalDecisionArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.userDecision != null) {
            this.userDecision = args.userDecision;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userDecision] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.comment != null) {
            this.comment = args.comment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[comment] is unset!");
        }
        if (args != null && args.returnToParentStage != null) {
            this.returnToParentStage = args.returnToParentStage;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[returnToParentStage] is unset!");
        }
        if (args != null && args.signature != null) {
            this.signature = args.signature;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[signature] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetAdditionalDecisionArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.userDecision != null) {
            output.writeFieldBegin("userDecision", thrift.Thrift.Type.MAP, 2);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.STRING, this.userDecision.size);
            this.userDecision.forEach((value_388: string, key_7: string): void => {
                output.writeString(key_7);
                output.writeString(value_388);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.comment != null) {
            output.writeFieldBegin("comment", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.comment);
            output.writeFieldEnd();
        }
        if (this.returnToParentStage != null) {
            output.writeFieldBegin("returnToParentStage", thrift.Thrift.Type.BOOL, 5);
            output.writeBool(this.returnToParentStage);
            output.writeFieldEnd();
        }
        if (this.signature != null) {
            output.writeFieldBegin("signature", thrift.Thrift.Type.STRING, 6);
            output.writeString(this.signature);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetAdditionalDecisionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_389: string = input.readString();
                        _args.token = value_389;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_390: Map<string, string> = new Map<string, string>();
                        const metadata_45: thrift.TMap = input.readMapBegin();
                        const size_45: number = metadata_45.size;
                        for (let i_45: number = 0; i_45 < size_45; i_45++) {
                            const key_8: string = input.readString();
                            const value_391: string = input.readString();
                            value_390.set(key_8, value_391);
                        }
                        input.readMapEnd();
                        _args.userDecision = value_390;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_392: string = input.readString();
                        _args.cardId = value_392;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_393: string = input.readString();
                        _args.comment = value_393;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_394: boolean = input.readBool();
                        _args.returnToParentStage = value_394;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_395: string = input.readString();
                        _args.signature = value_395;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.userDecision !== undefined && _args.cardId !== undefined && _args.comment !== undefined && _args.returnToParentStage !== undefined && _args.signature !== undefined) {
            return new SetAdditionalDecisionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetAdditionalDecisionArgs from input");
        }
    }
}
export interface ISetAdditionalDecisionUsingServerKeyStorageArgsArgs {
    token: string;
    userDecision: Map<string, string>;
    cardId: string;
    comment: string;
    returnToParentStage: boolean;
    pKeyId: string;
    password: string;
}
export class SetAdditionalDecisionUsingServerKeyStorageArgs {
    public token: string;
    public userDecision: Map<string, string>;
    public cardId: string;
    public comment: string;
    public returnToParentStage: boolean;
    public pKeyId: string;
    public password: string;
    constructor(args: ISetAdditionalDecisionUsingServerKeyStorageArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.userDecision != null) {
            this.userDecision = args.userDecision;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userDecision] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.comment != null) {
            this.comment = args.comment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[comment] is unset!");
        }
        if (args != null && args.returnToParentStage != null) {
            this.returnToParentStage = args.returnToParentStage;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[returnToParentStage] is unset!");
        }
        if (args != null && args.pKeyId != null) {
            this.pKeyId = args.pKeyId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[pKeyId] is unset!");
        }
        if (args != null && args.password != null) {
            this.password = args.password;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[password] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetAdditionalDecisionUsingServerKeyStorageArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.userDecision != null) {
            output.writeFieldBegin("userDecision", thrift.Thrift.Type.MAP, 2);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.STRING, this.userDecision.size);
            this.userDecision.forEach((value_396: string, key_9: string): void => {
                output.writeString(key_9);
                output.writeString(value_396);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.comment != null) {
            output.writeFieldBegin("comment", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.comment);
            output.writeFieldEnd();
        }
        if (this.returnToParentStage != null) {
            output.writeFieldBegin("returnToParentStage", thrift.Thrift.Type.BOOL, 5);
            output.writeBool(this.returnToParentStage);
            output.writeFieldEnd();
        }
        if (this.pKeyId != null) {
            output.writeFieldBegin("pKeyId", thrift.Thrift.Type.STRING, 6);
            output.writeString(this.pKeyId);
            output.writeFieldEnd();
        }
        if (this.password != null) {
            output.writeFieldBegin("password", thrift.Thrift.Type.STRING, 7);
            output.writeString(this.password);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetAdditionalDecisionUsingServerKeyStorageArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_397: string = input.readString();
                        _args.token = value_397;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_398: Map<string, string> = new Map<string, string>();
                        const metadata_46: thrift.TMap = input.readMapBegin();
                        const size_46: number = metadata_46.size;
                        for (let i_46: number = 0; i_46 < size_46; i_46++) {
                            const key_10: string = input.readString();
                            const value_399: string = input.readString();
                            value_398.set(key_10, value_399);
                        }
                        input.readMapEnd();
                        _args.userDecision = value_398;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_400: string = input.readString();
                        _args.cardId = value_400;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_401: string = input.readString();
                        _args.comment = value_401;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_402: boolean = input.readBool();
                        _args.returnToParentStage = value_402;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_403: string = input.readString();
                        _args.pKeyId = value_403;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_404: string = input.readString();
                        _args.password = value_404;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.userDecision !== undefined && _args.cardId !== undefined && _args.comment !== undefined && _args.returnToParentStage !== undefined && _args.pKeyId !== undefined && _args.password !== undefined) {
            return new SetAdditionalDecisionUsingServerKeyStorageArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetAdditionalDecisionUsingServerKeyStorageArgs from input");
        }
    }
}
export interface ISetAdditionalDecisionExtArgsArgs {
    token: string;
    userMap: Map<string, string>;
    cardId: string;
    comment: string;
    returnToParentStage: boolean;
    signatures: Array<string>;
}
export class SetAdditionalDecisionExtArgs {
    public token: string;
    public userMap: Map<string, string>;
    public cardId: string;
    public comment: string;
    public returnToParentStage: boolean;
    public signatures: Array<string>;
    constructor(args: ISetAdditionalDecisionExtArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.userMap != null) {
            this.userMap = args.userMap;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userMap] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.comment != null) {
            this.comment = args.comment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[comment] is unset!");
        }
        if (args != null && args.returnToParentStage != null) {
            this.returnToParentStage = args.returnToParentStage;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[returnToParentStage] is unset!");
        }
        if (args != null && args.signatures != null) {
            this.signatures = args.signatures;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[signatures] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetAdditionalDecisionExtArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.userMap != null) {
            output.writeFieldBegin("userMap", thrift.Thrift.Type.MAP, 2);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.STRING, this.userMap.size);
            this.userMap.forEach((value_405: string, key_11: string): void => {
                output.writeString(key_11);
                output.writeString(value_405);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.comment != null) {
            output.writeFieldBegin("comment", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.comment);
            output.writeFieldEnd();
        }
        if (this.returnToParentStage != null) {
            output.writeFieldBegin("returnToParentStage", thrift.Thrift.Type.BOOL, 5);
            output.writeBool(this.returnToParentStage);
            output.writeFieldEnd();
        }
        if (this.signatures != null) {
            output.writeFieldBegin("signatures", thrift.Thrift.Type.LIST, 6);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.signatures.length);
            this.signatures.forEach((value_406: string): void => {
                output.writeString(value_406);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetAdditionalDecisionExtArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_407: string = input.readString();
                        _args.token = value_407;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_408: Map<string, string> = new Map<string, string>();
                        const metadata_47: thrift.TMap = input.readMapBegin();
                        const size_47: number = metadata_47.size;
                        for (let i_47: number = 0; i_47 < size_47; i_47++) {
                            const key_12: string = input.readString();
                            const value_409: string = input.readString();
                            value_408.set(key_12, value_409);
                        }
                        input.readMapEnd();
                        _args.userMap = value_408;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_410: string = input.readString();
                        _args.cardId = value_410;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_411: string = input.readString();
                        _args.comment = value_411;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_412: boolean = input.readBool();
                        _args.returnToParentStage = value_412;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_413: Array<string> = new Array<string>();
                        const metadata_48: thrift.TList = input.readListBegin();
                        const size_48: number = metadata_48.size;
                        for (let i_48: number = 0; i_48 < size_48; i_48++) {
                            const value_414: string = input.readString();
                            value_413.push(value_414);
                        }
                        input.readListEnd();
                        _args.signatures = value_413;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.userMap !== undefined && _args.cardId !== undefined && _args.comment !== undefined && _args.returnToParentStage !== undefined && _args.signatures !== undefined) {
            return new SetAdditionalDecisionExtArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetAdditionalDecisionExtArgs from input");
        }
    }
}
export interface IRevokeDecisionArgsArgs {
    token: string;
    documentReassign: Array<DocumentReassign.DocumentReassign>;
    cardId: string;
    comment: string;
}
export class RevokeDecisionArgs {
    public token: string;
    public documentReassign: Array<DocumentReassign.DocumentReassign>;
    public cardId: string;
    public comment: string;
    constructor(args: IRevokeDecisionArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentReassign != null) {
            this.documentReassign = args.documentReassign;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentReassign] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.comment != null) {
            this.comment = args.comment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[comment] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RevokeDecisionArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentReassign != null) {
            output.writeFieldBegin("documentReassign", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.documentReassign.length);
            this.documentReassign.forEach((value_415: DocumentReassign.DocumentReassign): void => {
                value_415.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.comment != null) {
            output.writeFieldBegin("comment", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.comment);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RevokeDecisionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_416: string = input.readString();
                        _args.token = value_416;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_417: Array<DocumentReassign.DocumentReassign> = new Array<DocumentReassign.DocumentReassign>();
                        const metadata_49: thrift.TList = input.readListBegin();
                        const size_49: number = metadata_49.size;
                        for (let i_49: number = 0; i_49 < size_49; i_49++) {
                            const value_418: DocumentReassign.DocumentReassign = DocumentReassign.DocumentReassign.read(input);
                            value_417.push(value_418);
                        }
                        input.readListEnd();
                        _args.documentReassign = value_417;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_419: string = input.readString();
                        _args.cardId = value_419;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_420: string = input.readString();
                        _args.comment = value_420;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentReassign !== undefined && _args.cardId !== undefined && _args.comment !== undefined) {
            return new RevokeDecisionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RevokeDecisionArgs from input");
        }
    }
}
export interface IMarkDecisionAsRemovedArgsArgs {
    token: string;
    documentId: string;
    cardId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class MarkDecisionAsRemovedArgs {
    public token: string;
    public documentId: string;
    public cardId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IMarkDecisionAsRemovedArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MarkDecisionAsRemovedArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MarkDecisionAsRemovedArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_421: string = input.readString();
                        _args.token = value_421;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_422: string = input.readString();
                        _args.documentId = value_422;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_423: string = input.readString();
                        _args.cardId = value_423;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_424: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_424;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.cardId !== undefined && _args.accessPolicy !== undefined) {
            return new MarkDecisionAsRemovedArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read MarkDecisionAsRemovedArgs from input");
        }
    }
}
export interface IGetAllOpenDocumentExecutionsStatisticArgsArgs {
    token: string;
    userId: string;
}
export class GetAllOpenDocumentExecutionsStatisticArgs {
    public token: string;
    public userId: string;
    constructor(args: IGetAllOpenDocumentExecutionsStatisticArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.userId != null) {
            this.userId = args.userId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllOpenDocumentExecutionsStatisticArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.userId != null) {
            output.writeFieldBegin("userId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.userId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllOpenDocumentExecutionsStatisticArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_425: string = input.readString();
                        _args.token = value_425;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_426: string = input.readString();
                        _args.userId = value_426;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.userId !== undefined) {
            return new GetAllOpenDocumentExecutionsStatisticArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllOpenDocumentExecutionsStatisticArgs from input");
        }
    }
}
export interface IChangeControlForDocumentArgsArgs {
    token: string;
    documentId: string;
    control: boolean;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class ChangeControlForDocumentArgs {
    public token: string;
    public documentId: string;
    public control: boolean;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IChangeControlForDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.control != null) {
            this.control = args.control;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[control] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeControlForDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.control != null) {
            output.writeFieldBegin("control", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.control);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeControlForDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_427: string = input.readString();
                        _args.token = value_427;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_428: string = input.readString();
                        _args.documentId = value_428;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_429: boolean = input.readBool();
                        _args.control = value_429;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_430: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_430;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.control !== undefined && _args.accessPolicy !== undefined) {
            return new ChangeControlForDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeControlForDocumentArgs from input");
        }
    }
}
export interface IAddTagsToDocumentArgsArgs {
    token: string;
    docId: string;
    tags: Array<string>;
}
export class AddTagsToDocumentArgs {
    public token: string;
    public docId: string;
    public tags: Array<string>;
    constructor(args: IAddTagsToDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docId != null) {
            this.docId = args.docId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docId] is unset!");
        }
        if (args != null && args.tags != null) {
            this.tags = args.tags;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[tags] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddTagsToDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docId != null) {
            output.writeFieldBegin("docId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.docId);
            output.writeFieldEnd();
        }
        if (this.tags != null) {
            output.writeFieldBegin("tags", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.tags.length);
            this.tags.forEach((value_431: string): void => {
                output.writeString(value_431);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddTagsToDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_432: string = input.readString();
                        _args.token = value_432;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_433: string = input.readString();
                        _args.docId = value_433;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_434: Array<string> = new Array<string>();
                        const metadata_50: thrift.TList = input.readListBegin();
                        const size_50: number = metadata_50.size;
                        for (let i_50: number = 0; i_50 < size_50; i_50++) {
                            const value_435: string = input.readString();
                            value_434.push(value_435);
                        }
                        input.readListEnd();
                        _args.tags = value_434;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docId !== undefined && _args.tags !== undefined) {
            return new AddTagsToDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddTagsToDocumentArgs from input");
        }
    }
}
export interface IRemoveTagsToDocumentArgsArgs {
    token: string;
    docId: string;
    tags: Array<string>;
}
export class RemoveTagsToDocumentArgs {
    public token: string;
    public docId: string;
    public tags: Array<string>;
    constructor(args: IRemoveTagsToDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docId != null) {
            this.docId = args.docId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docId] is unset!");
        }
        if (args != null && args.tags != null) {
            this.tags = args.tags;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[tags] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveTagsToDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docId != null) {
            output.writeFieldBegin("docId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.docId);
            output.writeFieldEnd();
        }
        if (this.tags != null) {
            output.writeFieldBegin("tags", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.tags.length);
            this.tags.forEach((value_436: string): void => {
                output.writeString(value_436);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveTagsToDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_437: string = input.readString();
                        _args.token = value_437;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_438: string = input.readString();
                        _args.docId = value_438;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_439: Array<string> = new Array<string>();
                        const metadata_51: thrift.TList = input.readListBegin();
                        const size_51: number = metadata_51.size;
                        for (let i_51: number = 0; i_51 < size_51; i_51++) {
                            const value_440: string = input.readString();
                            value_439.push(value_440);
                        }
                        input.readListEnd();
                        _args.tags = value_439;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docId !== undefined && _args.tags !== undefined) {
            return new RemoveTagsToDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveTagsToDocumentArgs from input");
        }
    }
}
export interface IAddExecutorsToStageArgsArgs {
    token: string;
    docId: string;
    documentReassign: Array<DocumentReassign.DocumentReassign>;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class AddExecutorsToStageArgs {
    public token: string;
    public docId: string;
    public documentReassign: Array<DocumentReassign.DocumentReassign>;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IAddExecutorsToStageArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docId != null) {
            this.docId = args.docId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docId] is unset!");
        }
        if (args != null && args.documentReassign != null) {
            this.documentReassign = args.documentReassign;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentReassign] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddExecutorsToStageArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docId != null) {
            output.writeFieldBegin("docId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.docId);
            output.writeFieldEnd();
        }
        if (this.documentReassign != null) {
            output.writeFieldBegin("documentReassign", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.documentReassign.length);
            this.documentReassign.forEach((value_441: DocumentReassign.DocumentReassign): void => {
                value_441.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddExecutorsToStageArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_442: string = input.readString();
                        _args.token = value_442;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_443: string = input.readString();
                        _args.docId = value_443;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_444: Array<DocumentReassign.DocumentReassign> = new Array<DocumentReassign.DocumentReassign>();
                        const metadata_52: thrift.TList = input.readListBegin();
                        const size_52: number = metadata_52.size;
                        for (let i_52: number = 0; i_52 < size_52; i_52++) {
                            const value_445: DocumentReassign.DocumentReassign = DocumentReassign.DocumentReassign.read(input);
                            value_444.push(value_445);
                        }
                        input.readListEnd();
                        _args.documentReassign = value_444;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_446: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_446;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docId !== undefined && _args.documentReassign !== undefined && _args.accessPolicy !== undefined) {
            return new AddExecutorsToStageArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddExecutorsToStageArgs from input");
        }
    }
}
export interface IGetCountDocsByFilterNoPermissionArgsArgs {
    token: string;
    patternGroupId: string;
    filter: core.KazFilter;
}
export class GetCountDocsByFilterNoPermissionArgs {
    public token: string;
    public patternGroupId: string;
    public filter: core.KazFilter;
    constructor(args: IGetCountDocsByFilterNoPermissionArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.patternGroupId != null) {
            this.patternGroupId = args.patternGroupId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[patternGroupId] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountDocsByFilterNoPermissionArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.patternGroupId != null) {
            output.writeFieldBegin("patternGroupId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.patternGroupId);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 3);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountDocsByFilterNoPermissionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_447: string = input.readString();
                        _args.token = value_447;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_448: string = input.readString();
                        _args.patternGroupId = value_448;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_449: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_449;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.patternGroupId !== undefined && _args.filter !== undefined) {
            return new GetCountDocsByFilterNoPermissionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetCountDocsByFilterNoPermissionArgs from input");
        }
    }
}
export interface IGetTinyDocsByFilterNoPermissionArgsArgs {
    token: string;
    filter: core.KazFilter;
}
export class GetTinyDocsByFilterNoPermissionArgs {
    public token: string;
    public filter: core.KazFilter;
    constructor(args: IGetTinyDocsByFilterNoPermissionArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetTinyDocsByFilterNoPermissionArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetTinyDocsByFilterNoPermissionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_450: string = input.readString();
                        _args.token = value_450;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_451: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_451;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetTinyDocsByFilterNoPermissionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetTinyDocsByFilterNoPermissionArgs from input");
        }
    }
}
export interface IChangeRegistrationInfoForDocumentArgsArgs {
    token: string;
    documentId: string;
    newRegistrationDate: number | Int64;
    newRegistrationNumber: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class ChangeRegistrationInfoForDocumentArgs {
    public token: string;
    public documentId: string;
    public newRegistrationDate: Int64;
    public newRegistrationNumber: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IChangeRegistrationInfoForDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.newRegistrationDate != null) {
            if (typeof args.newRegistrationDate === "number") {
                this.newRegistrationDate = new Int64(args.newRegistrationDate);
            }
            else {
                this.newRegistrationDate = args.newRegistrationDate;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[newRegistrationDate] is unset!");
        }
        if (args != null && args.newRegistrationNumber != null) {
            this.newRegistrationNumber = args.newRegistrationNumber;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[newRegistrationNumber] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeRegistrationInfoForDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.newRegistrationDate != null) {
            output.writeFieldBegin("newRegistrationDate", thrift.Thrift.Type.I64, 3);
            output.writeI64(this.newRegistrationDate);
            output.writeFieldEnd();
        }
        if (this.newRegistrationNumber != null) {
            output.writeFieldBegin("newRegistrationNumber", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.newRegistrationNumber);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 5);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeRegistrationInfoForDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_452: string = input.readString();
                        _args.token = value_452;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_453: string = input.readString();
                        _args.documentId = value_453;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_454: Int64 = input.readI64();
                        _args.newRegistrationDate = value_454;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_455: string = input.readString();
                        _args.newRegistrationNumber = value_455;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_456: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_456;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.newRegistrationDate !== undefined && _args.newRegistrationNumber !== undefined && _args.accessPolicy !== undefined) {
            return new ChangeRegistrationInfoForDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeRegistrationInfoForDocumentArgs from input");
        }
    }
}
export interface ICreateChatForDocumentArgsArgs {
    token: string;
    documentId: string;
}
export class CreateChatForDocumentArgs {
    public token: string;
    public documentId: string;
    constructor(args: ICreateChatForDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateChatForDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateChatForDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_457: string = input.readString();
                        _args.token = value_457;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_458: string = input.readString();
                        _args.documentId = value_458;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined) {
            return new CreateChatForDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateChatForDocumentArgs from input");
        }
    }
}
export interface IGetDocumentExtShareListArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    filter: core.KazFilter;
}
export class GetDocumentExtShareListArgs {
    public token: string;
    public documentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public filter: core.KazFilter;
    constructor(args: IGetDocumentExtShareListArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentExtShareListArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 4);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentExtShareListArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_459: string = input.readString();
                        _args.token = value_459;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_460: string = input.readString();
                        _args.documentId = value_460;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_461: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_461;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_462: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_462;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined && _args.filter !== undefined) {
            return new GetDocumentExtShareListArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetDocumentExtShareListArgs from input");
        }
    }
}
export interface IChangeDocumentExtShareArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    toAdd: Array<DocumentExtShare.DocumentExtShare>;
    toRemove: Array<string>;
}
export class ChangeDocumentExtShareArgs {
    public token: string;
    public documentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public toAdd: Array<DocumentExtShare.DocumentExtShare>;
    public toRemove: Array<string>;
    constructor(args: IChangeDocumentExtShareArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.toAdd != null) {
            this.toAdd = args.toAdd;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toAdd] is unset!");
        }
        if (args != null && args.toRemove != null) {
            this.toRemove = args.toRemove;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toRemove] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeDocumentExtShareArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.toAdd != null) {
            output.writeFieldBegin("toAdd", thrift.Thrift.Type.LIST, 4);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.toAdd.length);
            this.toAdd.forEach((value_463: DocumentExtShare.DocumentExtShare): void => {
                value_463.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.toRemove != null) {
            output.writeFieldBegin("toRemove", thrift.Thrift.Type.LIST, 5);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.toRemove.length);
            this.toRemove.forEach((value_464: string): void => {
                output.writeString(value_464);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeDocumentExtShareArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_465: string = input.readString();
                        _args.token = value_465;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_466: string = input.readString();
                        _args.documentId = value_466;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_467: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_467;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_468: Array<DocumentExtShare.DocumentExtShare> = new Array<DocumentExtShare.DocumentExtShare>();
                        const metadata_53: thrift.TList = input.readListBegin();
                        const size_53: number = metadata_53.size;
                        for (let i_53: number = 0; i_53 < size_53; i_53++) {
                            const value_469: DocumentExtShare.DocumentExtShare = DocumentExtShare.DocumentExtShare.read(input);
                            value_468.push(value_469);
                        }
                        input.readListEnd();
                        _args.toAdd = value_468;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_470: Array<string> = new Array<string>();
                        const metadata_54: thrift.TList = input.readListBegin();
                        const size_54: number = metadata_54.size;
                        for (let i_54: number = 0; i_54 < size_54; i_54++) {
                            const value_471: string = input.readString();
                            value_470.push(value_471);
                        }
                        input.readListEnd();
                        _args.toRemove = value_470;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined && _args.toAdd !== undefined && _args.toRemove !== undefined) {
            return new ChangeDocumentExtShareArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeDocumentExtShareArgs from input");
        }
    }
}
export interface IChangeAttachmentExtStatusArgsArgs {
    token: string;
    statusMap: Map<string, core.AttachmentExtStatus>;
}
export class ChangeAttachmentExtStatusArgs {
    public token: string;
    public statusMap: Map<string, core.AttachmentExtStatus>;
    constructor(args: IChangeAttachmentExtStatusArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.statusMap != null) {
            this.statusMap = args.statusMap;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[statusMap] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeAttachmentExtStatusArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.statusMap != null) {
            output.writeFieldBegin("statusMap", thrift.Thrift.Type.MAP, 2);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.I32, this.statusMap.size);
            this.statusMap.forEach((value_472: core.AttachmentExtStatus, key_13: string): void => {
                output.writeString(key_13);
                output.writeI32(value_472);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeAttachmentExtStatusArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_473: string = input.readString();
                        _args.token = value_473;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_474: Map<string, core.AttachmentExtStatus> = new Map<string, core.AttachmentExtStatus>();
                        const metadata_55: thrift.TMap = input.readMapBegin();
                        const size_55: number = metadata_55.size;
                        for (let i_55: number = 0; i_55 < size_55; i_55++) {
                            const key_14: string = input.readString();
                            const value_475: core.AttachmentExtStatus = input.readI32();
                            value_474.set(key_14, value_475);
                        }
                        input.readMapEnd();
                        _args.statusMap = value_474;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.statusMap !== undefined) {
            return new ChangeAttachmentExtStatusArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeAttachmentExtStatusArgs from input");
        }
    }
}
export interface IRemindDocumentExecutorArgsArgs {
    token: string;
    cardId: string;
    comment: string;
    policy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class RemindDocumentExecutorArgs {
    public token: string;
    public cardId: string;
    public comment: string;
    public policy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IRemindDocumentExecutorArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.comment != null) {
            this.comment = args.comment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[comment] is unset!");
        }
        if (args != null && args.policy != null) {
            this.policy = args.policy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[policy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemindDocumentExecutorArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.comment != null) {
            output.writeFieldBegin("comment", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.comment);
            output.writeFieldEnd();
        }
        if (this.policy != null) {
            output.writeFieldBegin("policy", thrift.Thrift.Type.STRUCT, 4);
            this.policy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemindDocumentExecutorArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_476: string = input.readString();
                        _args.token = value_476;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_477: string = input.readString();
                        _args.cardId = value_477;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_478: string = input.readString();
                        _args.comment = value_478;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_479: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.policy = value_479;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.cardId !== undefined && _args.comment !== undefined && _args.policy !== undefined) {
            return new RemindDocumentExecutorArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemindDocumentExecutorArgs from input");
        }
    }
}
export interface IUpdateReassignResolutionArgsArgs {
    token: string;
    cardId: string;
    resolution: string;
    policy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class UpdateReassignResolutionArgs {
    public token: string;
    public cardId: string;
    public resolution: string;
    public policy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IUpdateReassignResolutionArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.resolution != null) {
            this.resolution = args.resolution;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[resolution] is unset!");
        }
        if (args != null && args.policy != null) {
            this.policy = args.policy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[policy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateReassignResolutionArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.resolution != null) {
            output.writeFieldBegin("resolution", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.resolution);
            output.writeFieldEnd();
        }
        if (this.policy != null) {
            output.writeFieldBegin("policy", thrift.Thrift.Type.STRUCT, 4);
            this.policy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateReassignResolutionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_480: string = input.readString();
                        _args.token = value_480;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_481: string = input.readString();
                        _args.cardId = value_481;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_482: string = input.readString();
                        _args.resolution = value_482;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_483: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.policy = value_483;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.cardId !== undefined && _args.resolution !== undefined && _args.policy !== undefined) {
            return new UpdateReassignResolutionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateReassignResolutionArgs from input");
        }
    }
}
export interface IUpdateSubStatusCommentArgsArgs {
    token: string;
    docCommentId: string;
    comment: string;
    policy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class UpdateSubStatusCommentArgs {
    public token: string;
    public docCommentId: string;
    public comment: string;
    public policy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IUpdateSubStatusCommentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docCommentId != null) {
            this.docCommentId = args.docCommentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docCommentId] is unset!");
        }
        if (args != null && args.comment != null) {
            this.comment = args.comment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[comment] is unset!");
        }
        if (args != null && args.policy != null) {
            this.policy = args.policy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[policy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateSubStatusCommentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docCommentId != null) {
            output.writeFieldBegin("docCommentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.docCommentId);
            output.writeFieldEnd();
        }
        if (this.comment != null) {
            output.writeFieldBegin("comment", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.comment);
            output.writeFieldEnd();
        }
        if (this.policy != null) {
            output.writeFieldBegin("policy", thrift.Thrift.Type.STRUCT, 4);
            this.policy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateSubStatusCommentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_484: string = input.readString();
                        _args.token = value_484;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_485: string = input.readString();
                        _args.docCommentId = value_485;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_486: string = input.readString();
                        _args.comment = value_486;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_487: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.policy = value_487;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docCommentId !== undefined && _args.comment !== undefined && _args.policy !== undefined) {
            return new UpdateSubStatusCommentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateSubStatusCommentArgs from input");
        }
    }
}
export interface IRemoveSubStatusCommentArgsArgs {
    token: string;
    docCommentId: string;
    policy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class RemoveSubStatusCommentArgs {
    public token: string;
    public docCommentId: string;
    public policy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IRemoveSubStatusCommentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docCommentId != null) {
            this.docCommentId = args.docCommentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docCommentId] is unset!");
        }
        if (args != null && args.policy != null) {
            this.policy = args.policy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[policy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveSubStatusCommentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docCommentId != null) {
            output.writeFieldBegin("docCommentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.docCommentId);
            output.writeFieldEnd();
        }
        if (this.policy != null) {
            output.writeFieldBegin("policy", thrift.Thrift.Type.STRUCT, 3);
            this.policy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveSubStatusCommentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_488: string = input.readString();
                        _args.token = value_488;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_489: string = input.readString();
                        _args.docCommentId = value_489;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_490: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.policy = value_490;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docCommentId !== undefined && _args.policy !== undefined) {
            return new RemoveSubStatusCommentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveSubStatusCommentArgs from input");
        }
    }
}
export interface IChangeDocumentTypeArgsArgs {
    token: string;
    docId: string;
    startStageId: string;
    stages: Array<DocumentPatternStage.DocumentPatternStage>;
    contentItems: Array<ContentItem.ContentItem>;
    roles: Array<PatternProcessRole.PatternProcessRole>;
    patternVariables: Array<PatternVariable.PatternVariable>;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    newRegNumber: string;
    patternId: string;
}
export class ChangeDocumentTypeArgs {
    public token: string;
    public docId: string;
    public startStageId: string;
    public stages: Array<DocumentPatternStage.DocumentPatternStage>;
    public contentItems: Array<ContentItem.ContentItem>;
    public roles: Array<PatternProcessRole.PatternProcessRole>;
    public patternVariables: Array<PatternVariable.PatternVariable>;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public newRegNumber: string;
    public patternId: string;
    constructor(args: IChangeDocumentTypeArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docId != null) {
            this.docId = args.docId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docId] is unset!");
        }
        if (args != null && args.startStageId != null) {
            this.startStageId = args.startStageId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[startStageId] is unset!");
        }
        if (args != null && args.stages != null) {
            this.stages = args.stages;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[stages] is unset!");
        }
        if (args != null && args.contentItems != null) {
            this.contentItems = args.contentItems;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[contentItems] is unset!");
        }
        if (args != null && args.roles != null) {
            this.roles = args.roles;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[roles] is unset!");
        }
        if (args != null && args.patternVariables != null) {
            this.patternVariables = args.patternVariables;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[patternVariables] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.newRegNumber != null) {
            this.newRegNumber = args.newRegNumber;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[newRegNumber] is unset!");
        }
        if (args != null && args.patternId != null) {
            this.patternId = args.patternId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[patternId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeDocumentTypeArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docId != null) {
            output.writeFieldBegin("docId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.docId);
            output.writeFieldEnd();
        }
        if (this.startStageId != null) {
            output.writeFieldBegin("startStageId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.startStageId);
            output.writeFieldEnd();
        }
        if (this.stages != null) {
            output.writeFieldBegin("stages", thrift.Thrift.Type.LIST, 4);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.stages.length);
            this.stages.forEach((value_491: DocumentPatternStage.DocumentPatternStage): void => {
                value_491.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.contentItems != null) {
            output.writeFieldBegin("contentItems", thrift.Thrift.Type.LIST, 5);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.contentItems.length);
            this.contentItems.forEach((value_492: ContentItem.ContentItem): void => {
                value_492.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.roles != null) {
            output.writeFieldBegin("roles", thrift.Thrift.Type.LIST, 6);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.roles.length);
            this.roles.forEach((value_493: PatternProcessRole.PatternProcessRole): void => {
                value_493.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.patternVariables != null) {
            output.writeFieldBegin("patternVariables", thrift.Thrift.Type.LIST, 7);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.patternVariables.length);
            this.patternVariables.forEach((value_494: PatternVariable.PatternVariable): void => {
                value_494.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 8);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.newRegNumber != null) {
            output.writeFieldBegin("newRegNumber", thrift.Thrift.Type.STRING, 9);
            output.writeString(this.newRegNumber);
            output.writeFieldEnd();
        }
        if (this.patternId != null) {
            output.writeFieldBegin("patternId", thrift.Thrift.Type.STRING, 10);
            output.writeString(this.patternId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeDocumentTypeArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_495: string = input.readString();
                        _args.token = value_495;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_496: string = input.readString();
                        _args.docId = value_496;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_497: string = input.readString();
                        _args.startStageId = value_497;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_498: Array<DocumentPatternStage.DocumentPatternStage> = new Array<DocumentPatternStage.DocumentPatternStage>();
                        const metadata_56: thrift.TList = input.readListBegin();
                        const size_56: number = metadata_56.size;
                        for (let i_56: number = 0; i_56 < size_56; i_56++) {
                            const value_499: DocumentPatternStage.DocumentPatternStage = DocumentPatternStage.DocumentPatternStage.read(input);
                            value_498.push(value_499);
                        }
                        input.readListEnd();
                        _args.stages = value_498;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_500: Array<ContentItem.ContentItem> = new Array<ContentItem.ContentItem>();
                        const metadata_57: thrift.TList = input.readListBegin();
                        const size_57: number = metadata_57.size;
                        for (let i_57: number = 0; i_57 < size_57; i_57++) {
                            const value_501: ContentItem.ContentItem = ContentItem.ContentItem.read(input);
                            value_500.push(value_501);
                        }
                        input.readListEnd();
                        _args.contentItems = value_500;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_502: Array<PatternProcessRole.PatternProcessRole> = new Array<PatternProcessRole.PatternProcessRole>();
                        const metadata_58: thrift.TList = input.readListBegin();
                        const size_58: number = metadata_58.size;
                        for (let i_58: number = 0; i_58 < size_58; i_58++) {
                            const value_503: PatternProcessRole.PatternProcessRole = PatternProcessRole.PatternProcessRole.read(input);
                            value_502.push(value_503);
                        }
                        input.readListEnd();
                        _args.roles = value_502;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_504: Array<PatternVariable.PatternVariable> = new Array<PatternVariable.PatternVariable>();
                        const metadata_59: thrift.TList = input.readListBegin();
                        const size_59: number = metadata_59.size;
                        for (let i_59: number = 0; i_59 < size_59; i_59++) {
                            const value_505: PatternVariable.PatternVariable = PatternVariable.PatternVariable.read(input);
                            value_504.push(value_505);
                        }
                        input.readListEnd();
                        _args.patternVariables = value_504;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 8:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_506: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_506;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 9:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_507: string = input.readString();
                        _args.newRegNumber = value_507;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 10:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_508: string = input.readString();
                        _args.patternId = value_508;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docId !== undefined && _args.startStageId !== undefined && _args.stages !== undefined && _args.contentItems !== undefined && _args.roles !== undefined && _args.patternVariables !== undefined && _args.accessPolicy !== undefined && _args.newRegNumber !== undefined && _args.patternId !== undefined) {
            return new ChangeDocumentTypeArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeDocumentTypeArgs from input");
        }
    }
}
export interface IGetDocumentRelationModelArgsArgs {
    token: string;
    docId: string;
    filter: core.KazFilter;
}
export class GetDocumentRelationModelArgs {
    public token: string;
    public docId: string;
    public filter: core.KazFilter;
    constructor(args: IGetDocumentRelationModelArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docId != null) {
            this.docId = args.docId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docId] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentRelationModelArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docId != null) {
            output.writeFieldBegin("docId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.docId);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 3);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentRelationModelArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_509: string = input.readString();
                        _args.token = value_509;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_510: string = input.readString();
                        _args.docId = value_510;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_511: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_511;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docId !== undefined && _args.filter !== undefined) {
            return new GetDocumentRelationModelArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetDocumentRelationModelArgs from input");
        }
    }
}
export interface IGetNewConvertedAttachmentVersionArgsArgs {
    token: string;
    prevAttId: string;
}
export class GetNewConvertedAttachmentVersionArgs {
    public token: string;
    public prevAttId: string;
    constructor(args: IGetNewConvertedAttachmentVersionArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.prevAttId != null) {
            this.prevAttId = args.prevAttId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[prevAttId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetNewConvertedAttachmentVersionArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.prevAttId != null) {
            output.writeFieldBegin("prevAttId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.prevAttId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetNewConvertedAttachmentVersionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_512: string = input.readString();
                        _args.token = value_512;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_513: string = input.readString();
                        _args.prevAttId = value_513;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.prevAttId !== undefined) {
            return new GetNewConvertedAttachmentVersionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetNewConvertedAttachmentVersionArgs from input");
        }
    }
}
export interface IExportAsXMLArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    allowedAttachmentFileExt: string;
    allowedAttachmentType: string;
}
export class ExportAsXMLArgs {
    public token: string;
    public documentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public allowedAttachmentFileExt: string;
    public allowedAttachmentType: string;
    constructor(args: IExportAsXMLArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.allowedAttachmentFileExt != null) {
            this.allowedAttachmentFileExt = args.allowedAttachmentFileExt;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[allowedAttachmentFileExt] is unset!");
        }
        if (args != null && args.allowedAttachmentType != null) {
            this.allowedAttachmentType = args.allowedAttachmentType;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[allowedAttachmentType] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExportAsXMLArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.allowedAttachmentFileExt != null) {
            output.writeFieldBegin("allowedAttachmentFileExt", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.allowedAttachmentFileExt);
            output.writeFieldEnd();
        }
        if (this.allowedAttachmentType != null) {
            output.writeFieldBegin("allowedAttachmentType", thrift.Thrift.Type.STRING, 5);
            output.writeString(this.allowedAttachmentType);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExportAsXMLArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_514: string = input.readString();
                        _args.token = value_514;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_515: string = input.readString();
                        _args.documentId = value_515;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_516: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_516;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_517: string = input.readString();
                        _args.allowedAttachmentFileExt = value_517;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_518: string = input.readString();
                        _args.allowedAttachmentType = value_518;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined && _args.allowedAttachmentFileExt !== undefined && _args.allowedAttachmentType !== undefined) {
            return new ExportAsXMLArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExportAsXMLArgs from input");
        }
    }
}
export interface IExportAsXMLv2ArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    allowedAttachmentFileExt: string;
    allowedAttachmentType: string;
}
export class ExportAsXMLv2Args {
    public token: string;
    public documentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public allowedAttachmentFileExt: string;
    public allowedAttachmentType: string;
    constructor(args: IExportAsXMLv2ArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.allowedAttachmentFileExt != null) {
            this.allowedAttachmentFileExt = args.allowedAttachmentFileExt;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[allowedAttachmentFileExt] is unset!");
        }
        if (args != null && args.allowedAttachmentType != null) {
            this.allowedAttachmentType = args.allowedAttachmentType;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[allowedAttachmentType] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExportAsXMLv2Args");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.allowedAttachmentFileExt != null) {
            output.writeFieldBegin("allowedAttachmentFileExt", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.allowedAttachmentFileExt);
            output.writeFieldEnd();
        }
        if (this.allowedAttachmentType != null) {
            output.writeFieldBegin("allowedAttachmentType", thrift.Thrift.Type.STRING, 5);
            output.writeString(this.allowedAttachmentType);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExportAsXMLv2Args {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_519: string = input.readString();
                        _args.token = value_519;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_520: string = input.readString();
                        _args.documentId = value_520;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_521: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_521;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_522: string = input.readString();
                        _args.allowedAttachmentFileExt = value_522;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_523: string = input.readString();
                        _args.allowedAttachmentType = value_523;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined && _args.allowedAttachmentFileExt !== undefined && _args.allowedAttachmentType !== undefined) {
            return new ExportAsXMLv2Args(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExportAsXMLv2Args from input");
        }
    }
}
export interface IImportFromXMLArgsArgs {
    token: string;
    xml: Buffer;
}
export class ImportFromXMLArgs {
    public token: string;
    public xml: Buffer;
    constructor(args: IImportFromXMLArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.xml != null) {
            this.xml = args.xml;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[xml] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ImportFromXMLArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.xml != null) {
            output.writeFieldBegin("xml", thrift.Thrift.Type.STRING, 2);
            output.writeBinary(this.xml);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ImportFromXMLArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_524: string = input.readString();
                        _args.token = value_524;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_525: Buffer = input.readBinary();
                        _args.xml = value_525;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.xml !== undefined) {
            return new ImportFromXMLArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ImportFromXMLArgs from input");
        }
    }
}
export interface IGetDocContentItemsForChangeTypeArgsArgs {
    token: string;
    documentId: string;
}
export class GetDocContentItemsForChangeTypeArgs {
    public token: string;
    public documentId: string;
    constructor(args: IGetDocContentItemsForChangeTypeArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocContentItemsForChangeTypeArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocContentItemsForChangeTypeArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_526: string = input.readString();
                        _args.token = value_526;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_527: string = input.readString();
                        _args.documentId = value_527;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined) {
            return new GetDocContentItemsForChangeTypeArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetDocContentItemsForChangeTypeArgs from input");
        }
    }
}
export interface IDownloadDocumentTemplateArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    pdfPostDecorators: Array<core.PDFPostDecorator>;
}
export class DownloadDocumentTemplateArgs {
    public token: string;
    public documentId: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    public pdfPostDecorators: Array<core.PDFPostDecorator>;
    constructor(args: IDownloadDocumentTemplateArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.pdfPostDecorators != null) {
            this.pdfPostDecorators = args.pdfPostDecorators;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[pdfPostDecorators] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DownloadDocumentTemplateArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.pdfPostDecorators != null) {
            output.writeFieldBegin("pdfPostDecorators", thrift.Thrift.Type.LIST, 4);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.pdfPostDecorators.length);
            this.pdfPostDecorators.forEach((value_528: core.PDFPostDecorator): void => {
                value_528.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DownloadDocumentTemplateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_529: string = input.readString();
                        _args.token = value_529;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_530: string = input.readString();
                        _args.documentId = value_530;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_531: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_531;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_532: Array<core.PDFPostDecorator> = new Array<core.PDFPostDecorator>();
                        const metadata_60: thrift.TList = input.readListBegin();
                        const size_60: number = metadata_60.size;
                        for (let i_60: number = 0; i_60 < size_60; i_60++) {
                            const value_533: core.PDFPostDecorator = core.PDFPostDecorator.read(input);
                            value_532.push(value_533);
                        }
                        input.readListEnd();
                        _args.pdfPostDecorators = value_532;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined && _args.pdfPostDecorators !== undefined) {
            return new DownloadDocumentTemplateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DownloadDocumentTemplateArgs from input");
        }
    }
}
export interface IGetAllDocumentExecutionsByFilterArgsArgs {
    token: string;
    documentId: string;
    filter: core.KazFilter;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class GetAllDocumentExecutionsByFilterArgs {
    public token: string;
    public documentId: string;
    public filter: core.KazFilter;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IGetAllDocumentExecutionsByFilterArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentExecutionsByFilterArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 3);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentExecutionsByFilterArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_534: string = input.readString();
                        _args.token = value_534;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_535: string = input.readString();
                        _args.documentId = value_535;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_536: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_536;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_537: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_537;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.filter !== undefined && _args.accessPolicy !== undefined) {
            return new GetAllDocumentExecutionsByFilterArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllDocumentExecutionsByFilterArgs from input");
        }
    }
}
export interface IGetDocumentIdArgsArgs {
    token: string;
    sType: DocumentSearchType.DocumentSearchType;
    value: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class GetDocumentIdArgs {
    public token: string;
    public sType: DocumentSearchType.DocumentSearchType;
    public value: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IGetDocumentIdArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.sType != null) {
            this.sType = args.sType;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[sType] is unset!");
        }
        if (args != null && args.value != null) {
            this.value = args.value;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[value] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentIdArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.sType != null) {
            output.writeFieldBegin("sType", thrift.Thrift.Type.I32, 2);
            output.writeI32(this.sType);
            output.writeFieldEnd();
        }
        if (this.value != null) {
            output.writeFieldBegin("value", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.value);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentIdArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_538: string = input.readString();
                        _args.token = value_538;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_539: DocumentSearchType.DocumentSearchType = input.readI32();
                        _args.sType = value_539;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_540: string = input.readString();
                        _args.value = value_540;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_541: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_541;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.sType !== undefined && _args.value !== undefined && _args.accessPolicy !== undefined) {
            return new GetDocumentIdArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetDocumentIdArgs from input");
        }
    }
}
export interface IChangeDocumentNameArgsArgs {
    token: string;
    docId: string;
    docName: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class ChangeDocumentNameArgs {
    public token: string;
    public docId: string;
    public docName: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IChangeDocumentNameArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docId != null) {
            this.docId = args.docId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docId] is unset!");
        }
        if (args != null && args.docName != null) {
            this.docName = args.docName;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docName] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeDocumentNameArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docId != null) {
            output.writeFieldBegin("docId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.docId);
            output.writeFieldEnd();
        }
        if (this.docName != null) {
            output.writeFieldBegin("docName", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.docName);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeDocumentNameArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_542: string = input.readString();
                        _args.token = value_542;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_543: string = input.readString();
                        _args.docId = value_543;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_544: string = input.readString();
                        _args.docName = value_544;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_545: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_545;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docId !== undefined && _args.docName !== undefined && _args.accessPolicy !== undefined) {
            return new ChangeDocumentNameArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeDocumentNameArgs from input");
        }
    }
}
export interface IChangeAttachmentOrderArgsArgs {
    token: string;
    documentId: string;
    orderMap: Map<string, number>;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class ChangeAttachmentOrderArgs {
    public token: string;
    public documentId: string;
    public orderMap: Map<string, number>;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IChangeAttachmentOrderArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.orderMap != null) {
            this.orderMap = args.orderMap;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[orderMap] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeAttachmentOrderArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.orderMap != null) {
            output.writeFieldBegin("orderMap", thrift.Thrift.Type.MAP, 3);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.I32, this.orderMap.size);
            this.orderMap.forEach((value_546: number, key_15: string): void => {
                output.writeString(key_15);
                output.writeI32(value_546);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeAttachmentOrderArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_547: string = input.readString();
                        _args.token = value_547;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_548: string = input.readString();
                        _args.documentId = value_548;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_549: Map<string, number> = new Map<string, number>();
                        const metadata_61: thrift.TMap = input.readMapBegin();
                        const size_61: number = metadata_61.size;
                        for (let i_61: number = 0; i_61 < size_61; i_61++) {
                            const key_16: string = input.readString();
                            const value_550: number = input.readI32();
                            value_549.set(key_16, value_550);
                        }
                        input.readMapEnd();
                        _args.orderMap = value_549;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_551: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_551;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.orderMap !== undefined && _args.accessPolicy !== undefined) {
            return new ChangeAttachmentOrderArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeAttachmentOrderArgs from input");
        }
    }
}
export interface ICompareAttachmentsURLArgsArgs {
    token: string;
    attachmentId1: string;
    attachmentId2: string;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class CompareAttachmentsURLArgs {
    public token: string;
    public attachmentId1: string;
    public attachmentId2: string;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: ICompareAttachmentsURLArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId1 != null) {
            this.attachmentId1 = args.attachmentId1;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId1] is unset!");
        }
        if (args != null && args.attachmentId2 != null) {
            this.attachmentId2 = args.attachmentId2;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId2] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CompareAttachmentsURLArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId1 != null) {
            output.writeFieldBegin("attachmentId1", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId1);
            output.writeFieldEnd();
        }
        if (this.attachmentId2 != null) {
            output.writeFieldBegin("attachmentId2", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.attachmentId2);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 4);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CompareAttachmentsURLArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_552: string = input.readString();
                        _args.token = value_552;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_553: string = input.readString();
                        _args.attachmentId1 = value_553;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_554: string = input.readString();
                        _args.attachmentId2 = value_554;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_555: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_555;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId1 !== undefined && _args.attachmentId2 !== undefined && _args.accessPolicy !== undefined) {
            return new CompareAttachmentsURLArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CompareAttachmentsURLArgs from input");
        }
    }
}
export interface IGetDocumentDecisionXmlArgsArgs {
    token: string;
    documentId: string;
    linkId: string;
    cardId: string;
    comment: string;
}
export class GetDocumentDecisionXmlArgs {
    public token: string;
    public documentId: string;
    public linkId: string;
    public cardId: string;
    public comment: string;
    constructor(args: IGetDocumentDecisionXmlArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.linkId != null) {
            this.linkId = args.linkId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[linkId] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.comment != null) {
            this.comment = args.comment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[comment] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentDecisionXmlArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.linkId != null) {
            output.writeFieldBegin("linkId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.linkId);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.comment != null) {
            output.writeFieldBegin("comment", thrift.Thrift.Type.STRING, 5);
            output.writeString(this.comment);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentDecisionXmlArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_556: string = input.readString();
                        _args.token = value_556;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_557: string = input.readString();
                        _args.documentId = value_557;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_558: string = input.readString();
                        _args.linkId = value_558;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_559: string = input.readString();
                        _args.cardId = value_559;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_560: string = input.readString();
                        _args.comment = value_560;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.linkId !== undefined && _args.cardId !== undefined && _args.comment !== undefined) {
            return new GetDocumentDecisionXmlArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetDocumentDecisionXmlArgs from input");
        }
    }
}
export interface IGetReassignDocXmlArgsArgs {
    token: string;
    documentId: string;
    cardId: string;
    documentReassign: Array<DocumentReassign.DocumentReassign>;
}
export class GetReassignDocXmlArgs {
    public token: string;
    public documentId: string;
    public cardId: string;
    public documentReassign: Array<DocumentReassign.DocumentReassign>;
    constructor(args: IGetReassignDocXmlArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.documentReassign != null) {
            this.documentReassign = args.documentReassign;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentReassign] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetReassignDocXmlArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.documentReassign != null) {
            output.writeFieldBegin("documentReassign", thrift.Thrift.Type.LIST, 4);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.documentReassign.length);
            this.documentReassign.forEach((value_561: DocumentReassign.DocumentReassign): void => {
                value_561.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetReassignDocXmlArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_562: string = input.readString();
                        _args.token = value_562;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_563: string = input.readString();
                        _args.documentId = value_563;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_564: string = input.readString();
                        _args.cardId = value_564;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_565: Array<DocumentReassign.DocumentReassign> = new Array<DocumentReassign.DocumentReassign>();
                        const metadata_62: thrift.TList = input.readListBegin();
                        const size_62: number = metadata_62.size;
                        for (let i_62: number = 0; i_62 < size_62; i_62++) {
                            const value_566: DocumentReassign.DocumentReassign = DocumentReassign.DocumentReassign.read(input);
                            value_565.push(value_566);
                        }
                        input.readListEnd();
                        _args.documentReassign = value_565;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.cardId !== undefined && _args.documentReassign !== undefined) {
            return new GetReassignDocXmlArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetReassignDocXmlArgs from input");
        }
    }
}
export interface IAddAnswerersArgsArgs {
    token: string;
    cardId: string;
    users: Array<string>;
    deadlineDate: number | Int64;
    comment: string;
    requireMyParticipation: boolean;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class AddAnswerersArgs {
    public token: string;
    public cardId: string;
    public users: Array<string>;
    public deadlineDate: Int64;
    public comment: string;
    public requireMyParticipation: boolean;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IAddAnswerersArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.users != null) {
            this.users = args.users;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[users] is unset!");
        }
        if (args != null && args.deadlineDate != null) {
            if (typeof args.deadlineDate === "number") {
                this.deadlineDate = new Int64(args.deadlineDate);
            }
            else {
                this.deadlineDate = args.deadlineDate;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[deadlineDate] is unset!");
        }
        if (args != null && args.comment != null) {
            this.comment = args.comment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[comment] is unset!");
        }
        if (args != null && args.requireMyParticipation != null) {
            this.requireMyParticipation = args.requireMyParticipation;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[requireMyParticipation] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddAnswerersArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.users != null) {
            output.writeFieldBegin("users", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.users.length);
            this.users.forEach((value_567: string): void => {
                output.writeString(value_567);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.deadlineDate != null) {
            output.writeFieldBegin("deadlineDate", thrift.Thrift.Type.I64, 4);
            output.writeI64(this.deadlineDate);
            output.writeFieldEnd();
        }
        if (this.comment != null) {
            output.writeFieldBegin("comment", thrift.Thrift.Type.STRING, 5);
            output.writeString(this.comment);
            output.writeFieldEnd();
        }
        if (this.requireMyParticipation != null) {
            output.writeFieldBegin("requireMyParticipation", thrift.Thrift.Type.BOOL, 6);
            output.writeBool(this.requireMyParticipation);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 7);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddAnswerersArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_568: string = input.readString();
                        _args.token = value_568;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_569: string = input.readString();
                        _args.cardId = value_569;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_570: Array<string> = new Array<string>();
                        const metadata_63: thrift.TList = input.readListBegin();
                        const size_63: number = metadata_63.size;
                        for (let i_63: number = 0; i_63 < size_63; i_63++) {
                            const value_571: string = input.readString();
                            value_570.push(value_571);
                        }
                        input.readListEnd();
                        _args.users = value_570;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_572: Int64 = input.readI64();
                        _args.deadlineDate = value_572;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_573: string = input.readString();
                        _args.comment = value_573;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_574: boolean = input.readBool();
                        _args.requireMyParticipation = value_574;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_575: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_575;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.cardId !== undefined && _args.users !== undefined && _args.deadlineDate !== undefined && _args.comment !== undefined && _args.requireMyParticipation !== undefined && _args.accessPolicy !== undefined) {
            return new AddAnswerersArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddAnswerersArgs from input");
        }
    }
}
export interface IAddAnswerersToLinkedDocumentArgsArgs {
    token: string;
    docId: string;
    users: Array<core.UserOrGroup>;
    deadlineDate: number | Int64;
    comment: string;
    requireMyParticipation: boolean;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class AddAnswerersToLinkedDocumentArgs {
    public token: string;
    public docId: string;
    public users: Array<core.UserOrGroup>;
    public deadlineDate: Int64;
    public comment: string;
    public requireMyParticipation: boolean;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IAddAnswerersToLinkedDocumentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docId != null) {
            this.docId = args.docId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docId] is unset!");
        }
        if (args != null && args.users != null) {
            this.users = args.users;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[users] is unset!");
        }
        if (args != null && args.deadlineDate != null) {
            if (typeof args.deadlineDate === "number") {
                this.deadlineDate = new Int64(args.deadlineDate);
            }
            else {
                this.deadlineDate = args.deadlineDate;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[deadlineDate] is unset!");
        }
        if (args != null && args.comment != null) {
            this.comment = args.comment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[comment] is unset!");
        }
        if (args != null && args.requireMyParticipation != null) {
            this.requireMyParticipation = args.requireMyParticipation;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[requireMyParticipation] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddAnswerersToLinkedDocumentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docId != null) {
            output.writeFieldBegin("docId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.docId);
            output.writeFieldEnd();
        }
        if (this.users != null) {
            output.writeFieldBegin("users", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.users.length);
            this.users.forEach((value_576: core.UserOrGroup): void => {
                value_576.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.deadlineDate != null) {
            output.writeFieldBegin("deadlineDate", thrift.Thrift.Type.I64, 4);
            output.writeI64(this.deadlineDate);
            output.writeFieldEnd();
        }
        if (this.comment != null) {
            output.writeFieldBegin("comment", thrift.Thrift.Type.STRING, 5);
            output.writeString(this.comment);
            output.writeFieldEnd();
        }
        if (this.requireMyParticipation != null) {
            output.writeFieldBegin("requireMyParticipation", thrift.Thrift.Type.BOOL, 6);
            output.writeBool(this.requireMyParticipation);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 7);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddAnswerersToLinkedDocumentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_577: string = input.readString();
                        _args.token = value_577;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_578: string = input.readString();
                        _args.docId = value_578;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_579: Array<core.UserOrGroup> = new Array<core.UserOrGroup>();
                        const metadata_64: thrift.TList = input.readListBegin();
                        const size_64: number = metadata_64.size;
                        for (let i_64: number = 0; i_64 < size_64; i_64++) {
                            const value_580: core.UserOrGroup = core.UserOrGroup.read(input);
                            value_579.push(value_580);
                        }
                        input.readListEnd();
                        _args.users = value_579;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_581: Int64 = input.readI64();
                        _args.deadlineDate = value_581;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_582: string = input.readString();
                        _args.comment = value_582;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_583: boolean = input.readBool();
                        _args.requireMyParticipation = value_583;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_584: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_584;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docId !== undefined && _args.users !== undefined && _args.deadlineDate !== undefined && _args.comment !== undefined && _args.requireMyParticipation !== undefined && _args.accessPolicy !== undefined) {
            return new AddAnswerersToLinkedDocumentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddAnswerersToLinkedDocumentArgs from input");
        }
    }
}
export interface ICreateMeetingQuestionArgsArgs {
    token: string;
    document: Document.Document;
    users: Array<core.UserOrGroup>;
    holderLinks: Array<ContentHolderLink.ContentHolderLink>;
    securityClassificationsId: Set<string>;
    attachments: Array<AttCreateInfo.AttCreateInfo>;
    docRelations: Array<DocumentRelation.DocumentRelation>;
    meetingDocumentId: string;
}
export class CreateMeetingQuestionArgs {
    public token: string;
    public document: Document.Document;
    public users: Array<core.UserOrGroup>;
    public holderLinks: Array<ContentHolderLink.ContentHolderLink>;
    public securityClassificationsId: Set<string>;
    public attachments: Array<AttCreateInfo.AttCreateInfo>;
    public docRelations: Array<DocumentRelation.DocumentRelation>;
    public meetingDocumentId: string;
    constructor(args: ICreateMeetingQuestionArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.document != null) {
            this.document = args.document;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[document] is unset!");
        }
        if (args != null && args.users != null) {
            this.users = args.users;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[users] is unset!");
        }
        if (args != null && args.holderLinks != null) {
            this.holderLinks = args.holderLinks;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[holderLinks] is unset!");
        }
        if (args != null && args.securityClassificationsId != null) {
            this.securityClassificationsId = args.securityClassificationsId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[securityClassificationsId] is unset!");
        }
        if (args != null && args.attachments != null) {
            this.attachments = args.attachments;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachments] is unset!");
        }
        if (args != null && args.docRelations != null) {
            this.docRelations = args.docRelations;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docRelations] is unset!");
        }
        if (args != null && args.meetingDocumentId != null) {
            this.meetingDocumentId = args.meetingDocumentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[meetingDocumentId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateMeetingQuestionArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.document != null) {
            output.writeFieldBegin("document", thrift.Thrift.Type.STRUCT, 2);
            this.document.write(output);
            output.writeFieldEnd();
        }
        if (this.users != null) {
            output.writeFieldBegin("users", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.users.length);
            this.users.forEach((value_585: core.UserOrGroup): void => {
                value_585.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.holderLinks != null) {
            output.writeFieldBegin("holderLinks", thrift.Thrift.Type.LIST, 4);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.holderLinks.length);
            this.holderLinks.forEach((value_586: ContentHolderLink.ContentHolderLink): void => {
                value_586.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.securityClassificationsId != null) {
            output.writeFieldBegin("securityClassificationsId", thrift.Thrift.Type.SET, 5);
            output.writeSetBegin(thrift.Thrift.Type.STRING, this.securityClassificationsId.size);
            this.securityClassificationsId.forEach((value_587: string): void => {
                output.writeString(value_587);
            });
            output.writeSetEnd();
            output.writeFieldEnd();
        }
        if (this.attachments != null) {
            output.writeFieldBegin("attachments", thrift.Thrift.Type.LIST, 6);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.attachments.length);
            this.attachments.forEach((value_588: AttCreateInfo.AttCreateInfo): void => {
                value_588.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.docRelations != null) {
            output.writeFieldBegin("docRelations", thrift.Thrift.Type.LIST, 7);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.docRelations.length);
            this.docRelations.forEach((value_589: DocumentRelation.DocumentRelation): void => {
                value_589.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.meetingDocumentId != null) {
            output.writeFieldBegin("meetingDocumentId", thrift.Thrift.Type.STRING, 8);
            output.writeString(this.meetingDocumentId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateMeetingQuestionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_590: string = input.readString();
                        _args.token = value_590;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_591: Document.Document = Document.Document.read(input);
                        _args.document = value_591;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_592: Array<core.UserOrGroup> = new Array<core.UserOrGroup>();
                        const metadata_65: thrift.TList = input.readListBegin();
                        const size_65: number = metadata_65.size;
                        for (let i_65: number = 0; i_65 < size_65; i_65++) {
                            const value_593: core.UserOrGroup = core.UserOrGroup.read(input);
                            value_592.push(value_593);
                        }
                        input.readListEnd();
                        _args.users = value_592;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_594: Array<ContentHolderLink.ContentHolderLink> = new Array<ContentHolderLink.ContentHolderLink>();
                        const metadata_66: thrift.TList = input.readListBegin();
                        const size_66: number = metadata_66.size;
                        for (let i_66: number = 0; i_66 < size_66; i_66++) {
                            const value_595: ContentHolderLink.ContentHolderLink = ContentHolderLink.ContentHolderLink.read(input);
                            value_594.push(value_595);
                        }
                        input.readListEnd();
                        _args.holderLinks = value_594;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.SET) {
                        const value_596: Set<string> = new Set<string>();
                        const metadata_67: thrift.TSet = input.readSetBegin();
                        const size_67: number = metadata_67.size;
                        for (let i_67: number = 0; i_67 < size_67; i_67++) {
                            const value_597: string = input.readString();
                            value_596.add(value_597);
                        }
                        input.readSetEnd();
                        _args.securityClassificationsId = value_596;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_598: Array<AttCreateInfo.AttCreateInfo> = new Array<AttCreateInfo.AttCreateInfo>();
                        const metadata_68: thrift.TList = input.readListBegin();
                        const size_68: number = metadata_68.size;
                        for (let i_68: number = 0; i_68 < size_68; i_68++) {
                            const value_599: AttCreateInfo.AttCreateInfo = AttCreateInfo.AttCreateInfo.read(input);
                            value_598.push(value_599);
                        }
                        input.readListEnd();
                        _args.attachments = value_598;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_600: Array<DocumentRelation.DocumentRelation> = new Array<DocumentRelation.DocumentRelation>();
                        const metadata_69: thrift.TList = input.readListBegin();
                        const size_69: number = metadata_69.size;
                        for (let i_69: number = 0; i_69 < size_69; i_69++) {
                            const value_601: DocumentRelation.DocumentRelation = DocumentRelation.DocumentRelation.read(input);
                            value_600.push(value_601);
                        }
                        input.readListEnd();
                        _args.docRelations = value_600;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 8:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_602: string = input.readString();
                        _args.meetingDocumentId = value_602;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.document !== undefined && _args.users !== undefined && _args.holderLinks !== undefined && _args.securityClassificationsId !== undefined && _args.attachments !== undefined && _args.docRelations !== undefined && _args.meetingDocumentId !== undefined) {
            return new CreateMeetingQuestionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateMeetingQuestionArgs from input");
        }
    }
}
export interface IChangeExternalNumberArgsArgs {
    token: string;
    documentId: string;
    externalId: string;
    externalNumber: string;
    externalRegDate: number | Int64;
    accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
}
export class ChangeExternalNumberArgs {
    public token: string;
    public documentId: string;
    public externalId: string;
    public externalNumber: string;
    public externalRegDate: Int64;
    public accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy;
    constructor(args: IChangeExternalNumberArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.externalId != null) {
            this.externalId = args.externalId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[externalId] is unset!");
        }
        if (args != null && args.externalNumber != null) {
            this.externalNumber = args.externalNumber;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[externalNumber] is unset!");
        }
        if (args != null && args.externalRegDate != null) {
            if (typeof args.externalRegDate === "number") {
                this.externalRegDate = new Int64(args.externalRegDate);
            }
            else {
                this.externalRegDate = args.externalRegDate;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[externalRegDate] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeExternalNumberArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.externalId != null) {
            output.writeFieldBegin("externalId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.externalId);
            output.writeFieldEnd();
        }
        if (this.externalNumber != null) {
            output.writeFieldBegin("externalNumber", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.externalNumber);
            output.writeFieldEnd();
        }
        if (this.externalRegDate != null) {
            output.writeFieldBegin("externalRegDate", thrift.Thrift.Type.I64, 5);
            output.writeI64(this.externalRegDate);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 6);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeExternalNumberArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_603: string = input.readString();
                        _args.token = value_603;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_604: string = input.readString();
                        _args.documentId = value_604;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_605: string = input.readString();
                        _args.externalId = value_605;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_606: string = input.readString();
                        _args.externalNumber = value_606;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_607: Int64 = input.readI64();
                        _args.externalRegDate = value_607;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_608: DocumentAccessPolicy.DocumentAccessPolicy = DocumentAccessPolicy.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_608;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.externalId !== undefined && _args.externalNumber !== undefined && _args.externalRegDate !== undefined && _args.accessPolicy !== undefined) {
            return new ChangeExternalNumberArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeExternalNumberArgs from input");
        }
    }
}
export interface IGetAvailableSubStatusesArgsArgs {
    token: string;
    documentId: string;
}
export class GetAvailableSubStatusesArgs {
    public token: string;
    public documentId: string;
    constructor(args: IGetAvailableSubStatusesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAvailableSubStatusesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAvailableSubStatusesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_609: string = input.readString();
                        _args.token = value_609;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_610: string = input.readString();
                        _args.documentId = value_610;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined) {
            return new GetAvailableSubStatusesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAvailableSubStatusesArgs from input");
        }
    }
}
export interface ICardWorkingStartArgsArgs {
    token: string;
    cardId: string;
    workComment: string;
}
export class CardWorkingStartArgs {
    public token: string;
    public cardId: string;
    public workComment: string;
    constructor(args: ICardWorkingStartArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.workComment != null) {
            this.workComment = args.workComment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[workComment] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CardWorkingStartArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.workComment != null) {
            output.writeFieldBegin("workComment", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.workComment);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CardWorkingStartArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_611: string = input.readString();
                        _args.token = value_611;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_612: string = input.readString();
                        _args.cardId = value_612;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_613: string = input.readString();
                        _args.workComment = value_613;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.cardId !== undefined && _args.workComment !== undefined) {
            return new CardWorkingStartArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CardWorkingStartArgs from input");
        }
    }
}
export interface ICardWorkingLogArgsArgs {
    token: string;
    cardId: string;
    workComment: string;
}
export class CardWorkingLogArgs {
    public token: string;
    public cardId: string;
    public workComment: string;
    constructor(args: ICardWorkingLogArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.workComment != null) {
            this.workComment = args.workComment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[workComment] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CardWorkingLogArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.workComment != null) {
            output.writeFieldBegin("workComment", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.workComment);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CardWorkingLogArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_614: string = input.readString();
                        _args.token = value_614;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_615: string = input.readString();
                        _args.cardId = value_615;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_616: string = input.readString();
                        _args.workComment = value_616;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.cardId !== undefined && _args.workComment !== undefined) {
            return new CardWorkingLogArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CardWorkingLogArgs from input");
        }
    }
}
export interface ICardWorkingStopArgsArgs {
    token: string;
    cardId: string;
    workComment: string;
}
export class CardWorkingStopArgs {
    public token: string;
    public cardId: string;
    public workComment: string;
    constructor(args: ICardWorkingStopArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.cardId != null) {
            this.cardId = args.cardId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cardId] is unset!");
        }
        if (args != null && args.workComment != null) {
            this.workComment = args.workComment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[workComment] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CardWorkingStopArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.cardId != null) {
            output.writeFieldBegin("cardId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.cardId);
            output.writeFieldEnd();
        }
        if (this.workComment != null) {
            output.writeFieldBegin("workComment", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.workComment);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CardWorkingStopArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_617: string = input.readString();
                        _args.token = value_617;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_618: string = input.readString();
                        _args.cardId = value_618;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_619: string = input.readString();
                        _args.workComment = value_619;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.cardId !== undefined && _args.workComment !== undefined) {
            return new CardWorkingStopArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CardWorkingStopArgs from input");
        }
    }
}
export interface IGetEnabledSubStatusesArgsArgs {
    token: string;
    documentId: string;
}
export class GetEnabledSubStatusesArgs {
    public token: string;
    public documentId: string;
    constructor(args: IGetEnabledSubStatusesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetEnabledSubStatusesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetEnabledSubStatusesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_620: string = input.readString();
                        _args.token = value_620;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_621: string = input.readString();
                        _args.documentId = value_621;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined) {
            return new GetEnabledSubStatusesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetEnabledSubStatusesArgs from input");
        }
    }
}
export interface IUpdateUserTagArgsArgs {
    token: string;
    docTag: DocumentTag.DocumentTag;
    fdelete: boolean;
}
export class UpdateUserTagArgs {
    public token: string;
    public docTag: DocumentTag.DocumentTag;
    public fdelete: boolean;
    constructor(args: IUpdateUserTagArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docTag != null) {
            this.docTag = args.docTag;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docTag] is unset!");
        }
        if (args != null && args.fdelete != null) {
            this.fdelete = args.fdelete;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[fdelete] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateUserTagArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docTag != null) {
            output.writeFieldBegin("docTag", thrift.Thrift.Type.STRUCT, 2);
            this.docTag.write(output);
            output.writeFieldEnd();
        }
        if (this.fdelete != null) {
            output.writeFieldBegin("fdelete", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.fdelete);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateUserTagArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_622: string = input.readString();
                        _args.token = value_622;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_623: DocumentTag.DocumentTag = DocumentTag.DocumentTag.read(input);
                        _args.docTag = value_623;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_624: boolean = input.readBool();
                        _args.fdelete = value_624;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docTag !== undefined && _args.fdelete !== undefined) {
            return new UpdateUserTagArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateUserTagArgs from input");
        }
    }
}
export interface IGetUserTagsArgsArgs {
    token: string;
    filter: core.KazFilter;
}
export class GetUserTagsArgs {
    public token: string;
    public filter: core.KazFilter;
    constructor(args: IGetUserTagsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetUserTagsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetUserTagsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_625: string = input.readString();
                        _args.token = value_625;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_626: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_626;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetUserTagsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetUserTagsArgs from input");
        }
    }
}
export interface IUpdateTagOrdersArgsArgs {
    token: string;
    oredrMap: Map<string, number>;
}
export class UpdateTagOrdersArgs {
    public token: string;
    public oredrMap: Map<string, number>;
    constructor(args: IUpdateTagOrdersArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.oredrMap != null) {
            this.oredrMap = args.oredrMap;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[oredrMap] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateTagOrdersArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.oredrMap != null) {
            output.writeFieldBegin("oredrMap", thrift.Thrift.Type.MAP, 2);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.I32, this.oredrMap.size);
            this.oredrMap.forEach((value_627: number, key_17: string): void => {
                output.writeString(key_17);
                output.writeI32(value_627);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateTagOrdersArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_628: string = input.readString();
                        _args.token = value_628;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_629: Map<string, number> = new Map<string, number>();
                        const metadata_70: thrift.TMap = input.readMapBegin();
                        const size_70: number = metadata_70.size;
                        for (let i_70: number = 0; i_70 < size_70; i_70++) {
                            const key_18: string = input.readString();
                            const value_630: number = input.readI32();
                            value_629.set(key_18, value_630);
                        }
                        input.readMapEnd();
                        _args.oredrMap = value_629;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.oredrMap !== undefined) {
            return new UpdateTagOrdersArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateTagOrdersArgs from input");
        }
    }
}
export interface IDocumentFieldByKeyArgsArgs {
    token: string;
    documentId: string;
    key: string;
    keyType: DocKeyType.DocKeyType;
}
export class DocumentFieldByKeyArgs {
    public token: string;
    public documentId: string;
    public key: string;
    public keyType: DocKeyType.DocKeyType;
    constructor(args: IDocumentFieldByKeyArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.key != null) {
            this.key = args.key;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[key] is unset!");
        }
        if (args != null && args.keyType != null) {
            this.keyType = args.keyType;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[keyType] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DocumentFieldByKeyArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.key != null) {
            output.writeFieldBegin("key", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.key);
            output.writeFieldEnd();
        }
        if (this.keyType != null) {
            output.writeFieldBegin("keyType", thrift.Thrift.Type.I32, 4);
            output.writeI32(this.keyType);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DocumentFieldByKeyArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_631: string = input.readString();
                        _args.token = value_631;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_632: string = input.readString();
                        _args.documentId = value_632;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_633: string = input.readString();
                        _args.key = value_633;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_634: DocKeyType.DocKeyType = input.readI32();
                        _args.keyType = value_634;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.key !== undefined && _args.keyType !== undefined) {
            return new DocumentFieldByKeyArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DocumentFieldByKeyArgs from input");
        }
    }
}
export interface IAddDecorationArgsArgs {
    token: string;
    attachmentId: string;
    decoratorKeys: Array<string>;
}
export class AddDecorationArgs {
    public token: string;
    public attachmentId: string;
    public decoratorKeys: Array<string>;
    constructor(args: IAddDecorationArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId != null) {
            this.attachmentId = args.attachmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId] is unset!");
        }
        if (args != null && args.decoratorKeys != null) {
            this.decoratorKeys = args.decoratorKeys;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[decoratorKeys] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddDecorationArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId != null) {
            output.writeFieldBegin("attachmentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId);
            output.writeFieldEnd();
        }
        if (this.decoratorKeys != null) {
            output.writeFieldBegin("decoratorKeys", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.decoratorKeys.length);
            this.decoratorKeys.forEach((value_635: string): void => {
                output.writeString(value_635);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddDecorationArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_636: string = input.readString();
                        _args.token = value_636;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_637: string = input.readString();
                        _args.attachmentId = value_637;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_638: Array<string> = new Array<string>();
                        const metadata_71: thrift.TList = input.readListBegin();
                        const size_71: number = metadata_71.size;
                        for (let i_71: number = 0; i_71 < size_71; i_71++) {
                            const value_639: string = input.readString();
                            value_638.push(value_639);
                        }
                        input.readListEnd();
                        _args.decoratorKeys = value_638;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId !== undefined && _args.decoratorKeys !== undefined) {
            return new AddDecorationArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddDecorationArgs from input");
        }
    }
}
export interface ICalculatePermissionsResultArgs {
    success?: DocPermissions.DocPermissions;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CalculatePermissionsResult {
    public success?: DocPermissions.DocPermissions;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICalculatePermissionsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CalculatePermissionsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CalculatePermissionsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_640: DocPermissions.DocPermissions = DocPermissions.DocPermissions.read(input);
                        _args.success = value_640;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_641: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_641;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_642: core.ServerException = core.ServerException.read(input);
                        _args.error = value_642;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CalculatePermissionsResult(_args);
    }
}
export interface ICreateOrUpdateDocumentResultArgs {
    success?: Document.Document;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CreateOrUpdateDocumentResult {
    public success?: Document.Document;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICreateOrUpdateDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_643: Document.Document = Document.Document.read(input);
                        _args.success = value_643;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_644: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_644;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_645: core.ServerException = core.ServerException.read(input);
                        _args.error = value_645;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateOrUpdateDocumentResult(_args);
    }
}
export interface IUpdateDocumentResultArgs {
    success?: Document.Document;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class UpdateDocumentResult {
    public success?: Document.Document;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IUpdateDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_646: Document.Document = Document.Document.read(input);
                        _args.success = value_646;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_647: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_647;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_648: core.ServerException = core.ServerException.read(input);
                        _args.error = value_648;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new UpdateDocumentResult(_args);
    }
}
export interface ICreateDocumentResultArgs {
    success?: Document.Document;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CreateDocumentResult {
    public success?: Document.Document;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICreateDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_649: Document.Document = Document.Document.read(input);
                        _args.success = value_649;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_650: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_650;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_651: core.ServerException = core.ServerException.read(input);
                        _args.error = value_651;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateDocumentResult(_args);
    }
}
export interface ICreateDocumentFromXMLResultArgs {
    success?: Document.Document;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CreateDocumentFromXMLResult {
    public success?: Document.Document;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICreateDocumentFromXMLResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateDocumentFromXMLResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateDocumentFromXMLResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_652: Document.Document = Document.Document.read(input);
                        _args.success = value_652;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_653: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_653;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_654: core.ServerException = core.ServerException.read(input);
                        _args.error = value_654;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateDocumentFromXMLResult(_args);
    }
}
export interface IGetDocumentResultArgs {
    success?: Document.Document;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetDocumentResult {
    public success?: Document.Document;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_655: Document.Document = Document.Document.read(input);
                        _args.success = value_655;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_656: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_656;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_657: core.ServerException = core.ServerException.read(input);
                        _args.error = value_657;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetDocumentResult(_args);
    }
}
export interface IGetAllDocumentsResultArgs {
    success?: Array<Document.Document>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllDocumentsResult {
    public success?: Array<Document.Document>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllDocumentsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_658: Document.Document): void => {
                value_658.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_659: Array<Document.Document> = new Array<Document.Document>();
                        const metadata_72: thrift.TList = input.readListBegin();
                        const size_72: number = metadata_72.size;
                        for (let i_72: number = 0; i_72 < size_72; i_72++) {
                            const value_660: Document.Document = Document.Document.read(input);
                            value_659.push(value_660);
                        }
                        input.readListEnd();
                        _args.success = value_659;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_661: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_661;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_662: core.ServerException = core.ServerException.read(input);
                        _args.error = value_662;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllDocumentsResult(_args);
    }
}
export interface IGetCountAllDocumentsResultArgs {
    success?: number;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetCountAllDocumentsResult {
    public success?: number;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetCountAllDocumentsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllDocumentsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
            output.writeI32(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllDocumentsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_663: number = input.readI32();
                        _args.success = value_663;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_664: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_664;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_665: core.ServerException = core.ServerException.read(input);
                        _args.error = value_665;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetCountAllDocumentsResult(_args);
    }
}
export interface IDeleteDocumentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class DeleteDocumentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IDeleteDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_666: boolean = input.readBool();
                        _args.success = value_666;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_667: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_667;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_668: core.ServerException = core.ServerException.read(input);
                        _args.error = value_668;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteDocumentResult(_args);
    }
}
export interface IGetAllPassedStagesResultArgs {
    success?: Array<PassedStage.PassedStage>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllPassedStagesResult {
    public success?: Array<PassedStage.PassedStage>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllPassedStagesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllPassedStagesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_669: PassedStage.PassedStage): void => {
                value_669.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllPassedStagesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_670: Array<PassedStage.PassedStage> = new Array<PassedStage.PassedStage>();
                        const metadata_73: thrift.TList = input.readListBegin();
                        const size_73: number = metadata_73.size;
                        for (let i_73: number = 0; i_73 < size_73; i_73++) {
                            const value_671: PassedStage.PassedStage = PassedStage.PassedStage.read(input);
                            value_670.push(value_671);
                        }
                        input.readListEnd();
                        _args.success = value_670;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_672: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_672;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_673: core.ServerException = core.ServerException.read(input);
                        _args.error = value_673;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllPassedStagesResult(_args);
    }
}
export interface IGetExecutionTreeResultArgs {
    success?: Array<ExecutionTree.ExecutionTree>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetExecutionTreeResult {
    public success?: Array<ExecutionTree.ExecutionTree>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetExecutionTreeResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetExecutionTreeResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_674: ExecutionTree.ExecutionTree): void => {
                value_674.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetExecutionTreeResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_675: Array<ExecutionTree.ExecutionTree> = new Array<ExecutionTree.ExecutionTree>();
                        const metadata_74: thrift.TList = input.readListBegin();
                        const size_74: number = metadata_74.size;
                        for (let i_74: number = 0; i_74 < size_74; i_74++) {
                            const value_676: ExecutionTree.ExecutionTree = ExecutionTree.ExecutionTree.read(input);
                            value_675.push(value_676);
                        }
                        input.readListEnd();
                        _args.success = value_675;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_677: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_677;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_678: core.ServerException = core.ServerException.read(input);
                        _args.error = value_678;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetExecutionTreeResult(_args);
    }
}
export interface IGetActiveStagesResultArgs {
    success?: Array<DocumentPatternStage.DocumentPatternStage>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetActiveStagesResult {
    public success?: Array<DocumentPatternStage.DocumentPatternStage>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetActiveStagesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetActiveStagesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_679: DocumentPatternStage.DocumentPatternStage): void => {
                value_679.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetActiveStagesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_680: Array<DocumentPatternStage.DocumentPatternStage> = new Array<DocumentPatternStage.DocumentPatternStage>();
                        const metadata_75: thrift.TList = input.readListBegin();
                        const size_75: number = metadata_75.size;
                        for (let i_75: number = 0; i_75 < size_75; i_75++) {
                            const value_681: DocumentPatternStage.DocumentPatternStage = DocumentPatternStage.DocumentPatternStage.read(input);
                            value_680.push(value_681);
                        }
                        input.readListEnd();
                        _args.success = value_680;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_682: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_682;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_683: core.ServerException = core.ServerException.read(input);
                        _args.error = value_683;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetActiveStagesResult(_args);
    }
}
export interface IGetCountPeoplesWhenRenderedDecisionResultArgs {
    success?: Map<string, number>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetCountPeoplesWhenRenderedDecisionResult {
    public success?: Map<string, number>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetCountPeoplesWhenRenderedDecisionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountPeoplesWhenRenderedDecisionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.MAP, 0);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.I32, this.success.size);
            this.success.forEach((value_684: number, key_19: string): void => {
                output.writeString(key_19);
                output.writeI32(value_684);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountPeoplesWhenRenderedDecisionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_685: Map<string, number> = new Map<string, number>();
                        const metadata_76: thrift.TMap = input.readMapBegin();
                        const size_76: number = metadata_76.size;
                        for (let i_76: number = 0; i_76 < size_76; i_76++) {
                            const key_20: string = input.readString();
                            const value_686: number = input.readI32();
                            value_685.set(key_20, value_686);
                        }
                        input.readMapEnd();
                        _args.success = value_685;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_687: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_687;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_688: core.ServerException = core.ServerException.read(input);
                        _args.error = value_688;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetCountPeoplesWhenRenderedDecisionResult(_args);
    }
}
export interface ISetDocumentDecisionResultArgs {
    success?: Document.Document;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class SetDocumentDecisionResult {
    public success?: Document.Document;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ISetDocumentDecisionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetDocumentDecisionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetDocumentDecisionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_689: Document.Document = Document.Document.read(input);
                        _args.success = value_689;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_690: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_690;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_691: core.ServerException = core.ServerException.read(input);
                        _args.error = value_691;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetDocumentDecisionResult(_args);
    }
}
export interface ISetDocumentDecisionByLinkIdResultArgs {
    success?: Document.Document;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class SetDocumentDecisionByLinkIdResult {
    public success?: Document.Document;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ISetDocumentDecisionByLinkIdResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetDocumentDecisionByLinkIdResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetDocumentDecisionByLinkIdResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_692: Document.Document = Document.Document.read(input);
                        _args.success = value_692;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_693: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_693;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_694: core.ServerException = core.ServerException.read(input);
                        _args.error = value_694;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetDocumentDecisionByLinkIdResult(_args);
    }
}
export interface ISetDocumentDecisionUsingServerKeyStorageResultArgs {
    success?: Document.Document;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class SetDocumentDecisionUsingServerKeyStorageResult {
    public success?: Document.Document;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ISetDocumentDecisionUsingServerKeyStorageResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetDocumentDecisionUsingServerKeyStorageResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetDocumentDecisionUsingServerKeyStorageResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_695: Document.Document = Document.Document.read(input);
                        _args.success = value_695;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_696: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_696;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_697: core.ServerException = core.ServerException.read(input);
                        _args.error = value_697;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetDocumentDecisionUsingServerKeyStorageResult(_args);
    }
}
export interface ISetDocumentDecisionExtResultArgs {
    success?: Document.Document;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class SetDocumentDecisionExtResult {
    public success?: Document.Document;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ISetDocumentDecisionExtResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetDocumentDecisionExtResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetDocumentDecisionExtResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_698: Document.Document = Document.Document.read(input);
                        _args.success = value_698;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_699: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_699;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_700: core.ServerException = core.ServerException.read(input);
                        _args.error = value_700;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetDocumentDecisionExtResult(_args);
    }
}
export interface IApproveDocumentDecisionResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ApproveDocumentDecisionResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IApproveDocumentDecisionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ApproveDocumentDecisionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ApproveDocumentDecisionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_701: boolean = input.readBool();
                        _args.success = value_701;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_702: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_702;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_703: core.ServerException = core.ServerException.read(input);
                        _args.error = value_703;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ApproveDocumentDecisionResult(_args);
    }
}
export interface IShareDocumentResultArgs {
    success?: Array<DocumentExecution.DocumentExecution>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ShareDocumentResult {
    public success?: Array<DocumentExecution.DocumentExecution>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IShareDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ShareDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_704: DocumentExecution.DocumentExecution): void => {
                value_704.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ShareDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_705: Array<DocumentExecution.DocumentExecution> = new Array<DocumentExecution.DocumentExecution>();
                        const metadata_77: thrift.TList = input.readListBegin();
                        const size_77: number = metadata_77.size;
                        for (let i_77: number = 0; i_77 < size_77; i_77++) {
                            const value_706: DocumentExecution.DocumentExecution = DocumentExecution.DocumentExecution.read(input);
                            value_705.push(value_706);
                        }
                        input.readListEnd();
                        _args.success = value_705;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_707: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_707;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_708: core.ServerException = core.ServerException.read(input);
                        _args.error = value_708;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ShareDocumentResult(_args);
    }
}
export interface IRevokeDocumentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class RevokeDocumentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IRevokeDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RevokeDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RevokeDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_709: boolean = input.readBool();
                        _args.success = value_709;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_710: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_710;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_711: core.ServerException = core.ServerException.read(input);
                        _args.error = value_711;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RevokeDocumentResult(_args);
    }
}
export interface IGetAllDocumentSharingsResultArgs {
    success?: Array<core.UserOrGroup>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllDocumentSharingsResult {
    public success?: Array<core.UserOrGroup>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllDocumentSharingsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentSharingsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_712: core.UserOrGroup): void => {
                value_712.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentSharingsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_713: Array<core.UserOrGroup> = new Array<core.UserOrGroup>();
                        const metadata_78: thrift.TList = input.readListBegin();
                        const size_78: number = metadata_78.size;
                        for (let i_78: number = 0; i_78 < size_78; i_78++) {
                            const value_714: core.UserOrGroup = core.UserOrGroup.read(input);
                            value_713.push(value_714);
                        }
                        input.readListEnd();
                        _args.success = value_713;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_715: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_715;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_716: core.ServerException = core.ServerException.read(input);
                        _args.error = value_716;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllDocumentSharingsResult(_args);
    }
}
export interface IGetAllDocumentReassignResultArgs {
    success?: Array<DocumentReassign.DocumentReassign>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllDocumentReassignResult {
    public success?: Array<DocumentReassign.DocumentReassign>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllDocumentReassignResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentReassignResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_717: DocumentReassign.DocumentReassign): void => {
                value_717.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentReassignResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_718: Array<DocumentReassign.DocumentReassign> = new Array<DocumentReassign.DocumentReassign>();
                        const metadata_79: thrift.TList = input.readListBegin();
                        const size_79: number = metadata_79.size;
                        for (let i_79: number = 0; i_79 < size_79; i_79++) {
                            const value_719: DocumentReassign.DocumentReassign = DocumentReassign.DocumentReassign.read(input);
                            value_718.push(value_719);
                        }
                        input.readListEnd();
                        _args.success = value_718;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_720: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_720;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_721: core.ServerException = core.ServerException.read(input);
                        _args.error = value_721;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllDocumentReassignResult(_args);
    }
}
export interface IReassignDocumentResultArgs {
    success?: Array<DocumentExecution.DocumentExecution>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ReassignDocumentResult {
    public success?: Array<DocumentExecution.DocumentExecution>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IReassignDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ReassignDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_722: DocumentExecution.DocumentExecution): void => {
                value_722.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ReassignDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_723: Array<DocumentExecution.DocumentExecution> = new Array<DocumentExecution.DocumentExecution>();
                        const metadata_80: thrift.TList = input.readListBegin();
                        const size_80: number = metadata_80.size;
                        for (let i_80: number = 0; i_80 < size_80; i_80++) {
                            const value_724: DocumentExecution.DocumentExecution = DocumentExecution.DocumentExecution.read(input);
                            value_723.push(value_724);
                        }
                        input.readListEnd();
                        _args.success = value_723;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_725: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_725;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_726: core.ServerException = core.ServerException.read(input);
                        _args.error = value_726;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ReassignDocumentResult(_args);
    }
}
export interface IReassignDocumentUsingServerKeyStorageResultArgs {
    success?: Array<DocumentExecution.DocumentExecution>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ReassignDocumentUsingServerKeyStorageResult {
    public success?: Array<DocumentExecution.DocumentExecution>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IReassignDocumentUsingServerKeyStorageResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ReassignDocumentUsingServerKeyStorageResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_727: DocumentExecution.DocumentExecution): void => {
                value_727.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ReassignDocumentUsingServerKeyStorageResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_728: Array<DocumentExecution.DocumentExecution> = new Array<DocumentExecution.DocumentExecution>();
                        const metadata_81: thrift.TList = input.readListBegin();
                        const size_81: number = metadata_81.size;
                        for (let i_81: number = 0; i_81 < size_81; i_81++) {
                            const value_729: DocumentExecution.DocumentExecution = DocumentExecution.DocumentExecution.read(input);
                            value_728.push(value_729);
                        }
                        input.readListEnd();
                        _args.success = value_728;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_730: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_730;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_731: core.ServerException = core.ServerException.read(input);
                        _args.error = value_731;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ReassignDocumentUsingServerKeyStorageResult(_args);
    }
}
export interface IReassignDocumentExtResultArgs {
    success?: Array<DocumentExecution.DocumentExecution>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ReassignDocumentExtResult {
    public success?: Array<DocumentExecution.DocumentExecution>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IReassignDocumentExtResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ReassignDocumentExtResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_732: DocumentExecution.DocumentExecution): void => {
                value_732.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ReassignDocumentExtResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_733: Array<DocumentExecution.DocumentExecution> = new Array<DocumentExecution.DocumentExecution>();
                        const metadata_82: thrift.TList = input.readListBegin();
                        const size_82: number = metadata_82.size;
                        for (let i_82: number = 0; i_82 < size_82; i_82++) {
                            const value_734: DocumentExecution.DocumentExecution = DocumentExecution.DocumentExecution.read(input);
                            value_733.push(value_734);
                        }
                        input.readListEnd();
                        _args.success = value_733;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_735: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_735;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_736: core.ServerException = core.ServerException.read(input);
                        _args.error = value_736;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ReassignDocumentExtResult(_args);
    }
}
export interface IRevokeChildCardsResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class RevokeChildCardsResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IRevokeChildCardsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RevokeChildCardsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RevokeChildCardsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_737: boolean = input.readBool();
                        _args.success = value_737;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_738: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_738;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_739: core.ServerException = core.ServerException.read(input);
                        _args.error = value_739;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RevokeChildCardsResult(_args);
    }
}
export interface ICreateOrUpdateAutomaticDocumentReassignResultArgs {
    success?: DocumentReassign.DocumentReassign;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CreateOrUpdateAutomaticDocumentReassignResult {
    public success?: DocumentReassign.DocumentReassign;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICreateOrUpdateAutomaticDocumentReassignResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateAutomaticDocumentReassignResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateAutomaticDocumentReassignResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_740: DocumentReassign.DocumentReassign = DocumentReassign.DocumentReassign.read(input);
                        _args.success = value_740;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_741: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_741;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_742: core.ServerException = core.ServerException.read(input);
                        _args.error = value_742;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateOrUpdateAutomaticDocumentReassignResult(_args);
    }
}
export interface IDeleteAutomaticDocumentReassignResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class DeleteAutomaticDocumentReassignResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IDeleteAutomaticDocumentReassignResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteAutomaticDocumentReassignResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteAutomaticDocumentReassignResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_743: boolean = input.readBool();
                        _args.success = value_743;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_744: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_744;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_745: core.ServerException = core.ServerException.read(input);
                        _args.error = value_745;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteAutomaticDocumentReassignResult(_args);
    }
}
export interface IChangeReassignControlResultArgs {
    success?: DocumentExecution.DocumentExecution;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeReassignControlResult {
    public success?: DocumentExecution.DocumentExecution;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeReassignControlResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeReassignControlResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeReassignControlResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_746: DocumentExecution.DocumentExecution = DocumentExecution.DocumentExecution.read(input);
                        _args.success = value_746;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_747: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_747;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_748: core.ServerException = core.ServerException.read(input);
                        _args.error = value_748;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeReassignControlResult(_args);
    }
}
export interface IGetAllDocumentExecutionsResultArgs {
    success?: Array<DocumentExecution.DocumentExecution>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllDocumentExecutionsResult {
    public success?: Array<DocumentExecution.DocumentExecution>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllDocumentExecutionsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentExecutionsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_749: DocumentExecution.DocumentExecution): void => {
                value_749.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentExecutionsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_750: Array<DocumentExecution.DocumentExecution> = new Array<DocumentExecution.DocumentExecution>();
                        const metadata_83: thrift.TList = input.readListBegin();
                        const size_83: number = metadata_83.size;
                        for (let i_83: number = 0; i_83 < size_83; i_83++) {
                            const value_751: DocumentExecution.DocumentExecution = DocumentExecution.DocumentExecution.read(input);
                            value_750.push(value_751);
                        }
                        input.readListEnd();
                        _args.success = value_750;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_752: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_752;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_753: core.ServerException = core.ServerException.read(input);
                        _args.error = value_753;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllDocumentExecutionsResult(_args);
    }
}
export interface IGetDocumentExecutionResultArgs {
    success?: DocumentExecution.DocumentExecution;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetDocumentExecutionResult {
    public success?: DocumentExecution.DocumentExecution;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetDocumentExecutionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentExecutionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentExecutionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_754: DocumentExecution.DocumentExecution = DocumentExecution.DocumentExecution.read(input);
                        _args.success = value_754;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_755: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_755;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_756: core.ServerException = core.ServerException.read(input);
                        _args.error = value_756;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetDocumentExecutionResult(_args);
    }
}
export interface IChangeExecutorsForDocumentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeExecutorsForDocumentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeExecutorsForDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeExecutorsForDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeExecutorsForDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_757: boolean = input.readBool();
                        _args.success = value_757;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_758: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_758;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_759: core.ServerException = core.ServerException.read(input);
                        _args.error = value_759;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeExecutorsForDocumentResult(_args);
    }
}
export interface ICreateAttachmentFromResultArgs {
    success?: Array<Attachment.Attachment>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CreateAttachmentFromResult {
    public success?: Array<Attachment.Attachment>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICreateAttachmentFromResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateAttachmentFromResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_760: Attachment.Attachment): void => {
                value_760.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateAttachmentFromResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_761: Array<Attachment.Attachment> = new Array<Attachment.Attachment>();
                        const metadata_84: thrift.TList = input.readListBegin();
                        const size_84: number = metadata_84.size;
                        for (let i_84: number = 0; i_84 < size_84; i_84++) {
                            const value_762: Attachment.Attachment = Attachment.Attachment.read(input);
                            value_761.push(value_762);
                        }
                        input.readListEnd();
                        _args.success = value_761;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_763: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_763;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_764: core.ServerException = core.ServerException.read(input);
                        _args.error = value_764;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateAttachmentFromResult(_args);
    }
}
export interface ICreateLoadableAttachmentResultArgs {
    success?: string;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CreateLoadableAttachmentResult {
    public success?: string;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICreateLoadableAttachmentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateLoadableAttachmentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateLoadableAttachmentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_765: string = input.readString();
                        _args.success = value_765;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_766: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_766;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_767: core.ServerException = core.ServerException.read(input);
                        _args.error = value_767;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateLoadableAttachmentResult(_args);
    }
}
export interface IUploadDocumentAttachmentPortionsResultArgs {
    success?: Attachment.Attachment;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class UploadDocumentAttachmentPortionsResult {
    public success?: Attachment.Attachment;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IUploadDocumentAttachmentPortionsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UploadDocumentAttachmentPortionsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UploadDocumentAttachmentPortionsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_768: Attachment.Attachment = Attachment.Attachment.read(input);
                        _args.success = value_768;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_769: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_769;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_770: core.ServerException = core.ServerException.read(input);
                        _args.error = value_770;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new UploadDocumentAttachmentPortionsResult(_args);
    }
}
export interface IAddPreviewToAttachmentResultArgs {
    success?: Attachment.Attachment;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class AddPreviewToAttachmentResult {
    public success?: Attachment.Attachment;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IAddPreviewToAttachmentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddPreviewToAttachmentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddPreviewToAttachmentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_771: Attachment.Attachment = Attachment.Attachment.read(input);
                        _args.success = value_771;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_772: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_772;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_773: core.ServerException = core.ServerException.read(input);
                        _args.error = value_773;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AddPreviewToAttachmentResult(_args);
    }
}
export interface IWriteHistoryOpenAttachmentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class WriteHistoryOpenAttachmentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IWriteHistoryOpenAttachmentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("WriteHistoryOpenAttachmentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): WriteHistoryOpenAttachmentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_774: boolean = input.readBool();
                        _args.success = value_774;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_775: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_775;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_776: core.ServerException = core.ServerException.read(input);
                        _args.error = value_776;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new WriteHistoryOpenAttachmentResult(_args);
    }
}
export interface IDownloadDocumentAttachmentResultArgs {
    success?: Buffer;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class DownloadDocumentAttachmentResult {
    public success?: Buffer;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IDownloadDocumentAttachmentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DownloadDocumentAttachmentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeBinary(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DownloadDocumentAttachmentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_777: Buffer = input.readBinary();
                        _args.success = value_777;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_778: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_778;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_779: core.ServerException = core.ServerException.read(input);
                        _args.error = value_779;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DownloadDocumentAttachmentResult(_args);
    }
}
export interface IRotatePdfPagesResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class RotatePdfPagesResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IRotatePdfPagesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RotatePdfPagesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RotatePdfPagesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_780: boolean = input.readBool();
                        _args.success = value_780;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_781: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_781;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_782: core.ServerException = core.ServerException.read(input);
                        _args.error = value_782;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RotatePdfPagesResult(_args);
    }
}
export interface IAddAttachmentsToDocumentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class AddAttachmentsToDocumentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IAddAttachmentsToDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddAttachmentsToDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddAttachmentsToDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_783: boolean = input.readBool();
                        _args.success = value_783;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_784: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_784;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_785: core.ServerException = core.ServerException.read(input);
                        _args.error = value_785;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AddAttachmentsToDocumentResult(_args);
    }
}
export interface IRemoveDocumentAttachmentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class RemoveDocumentAttachmentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IRemoveDocumentAttachmentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveDocumentAttachmentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveDocumentAttachmentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_786: boolean = input.readBool();
                        _args.success = value_786;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_787: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_787;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_788: core.ServerException = core.ServerException.read(input);
                        _args.error = value_788;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveDocumentAttachmentResult(_args);
    }
}
export interface IMarkAsWaitForPublishResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class MarkAsWaitForPublishResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IMarkAsWaitForPublishResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MarkAsWaitForPublishResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MarkAsWaitForPublishResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_789: boolean = input.readBool();
                        _args.success = value_789;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_790: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_790;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_791: core.ServerException = core.ServerException.read(input);
                        _args.error = value_791;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new MarkAsWaitForPublishResult(_args);
    }
}
export interface IChangeAttachmentEditModeResultArgs {
    success?: Attachment.Attachment;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeAttachmentEditModeResult {
    public success?: Attachment.Attachment;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeAttachmentEditModeResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeAttachmentEditModeResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeAttachmentEditModeResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_792: Attachment.Attachment = Attachment.Attachment.read(input);
                        _args.success = value_792;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_793: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_793;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_794: core.ServerException = core.ServerException.read(input);
                        _args.error = value_794;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeAttachmentEditModeResult(_args);
    }
}
export interface IGetDocumentAttachmentsResultArgs {
    success?: Array<Attachment.Attachment>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetDocumentAttachmentsResult {
    public success?: Array<Attachment.Attachment>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetDocumentAttachmentsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentAttachmentsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_795: Attachment.Attachment): void => {
                value_795.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentAttachmentsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_796: Array<Attachment.Attachment> = new Array<Attachment.Attachment>();
                        const metadata_85: thrift.TList = input.readListBegin();
                        const size_85: number = metadata_85.size;
                        for (let i_85: number = 0; i_85 < size_85; i_85++) {
                            const value_797: Attachment.Attachment = Attachment.Attachment.read(input);
                            value_796.push(value_797);
                        }
                        input.readListEnd();
                        _args.success = value_796;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_798: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_798;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_799: core.ServerException = core.ServerException.read(input);
                        _args.error = value_799;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetDocumentAttachmentsResult(_args);
    }
}
export interface IGetDocumentAttachmentByIdResultArgs {
    success?: Attachment.Attachment;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetDocumentAttachmentByIdResult {
    public success?: Attachment.Attachment;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetDocumentAttachmentByIdResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentAttachmentByIdResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentAttachmentByIdResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_800: Attachment.Attachment = Attachment.Attachment.read(input);
                        _args.success = value_800;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_801: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_801;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_802: core.ServerException = core.ServerException.read(input);
                        _args.error = value_802;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetDocumentAttachmentByIdResult(_args);
    }
}
export interface IGetAllDocumentAttachmentVersionsResultArgs {
    success?: Array<Attachment.Attachment>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllDocumentAttachmentVersionsResult {
    public success?: Array<Attachment.Attachment>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllDocumentAttachmentVersionsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentAttachmentVersionsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_803: Attachment.Attachment): void => {
                value_803.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentAttachmentVersionsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_804: Array<Attachment.Attachment> = new Array<Attachment.Attachment>();
                        const metadata_86: thrift.TList = input.readListBegin();
                        const size_86: number = metadata_86.size;
                        for (let i_86: number = 0; i_86 < size_86; i_86++) {
                            const value_805: Attachment.Attachment = Attachment.Attachment.read(input);
                            value_804.push(value_805);
                        }
                        input.readListEnd();
                        _args.success = value_804;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_806: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_806;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_807: core.ServerException = core.ServerException.read(input);
                        _args.error = value_807;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllDocumentAttachmentVersionsResult(_args);
    }
}
export interface IChangeAttachmentsVisibilityResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeAttachmentsVisibilityResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeAttachmentsVisibilityResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeAttachmentsVisibilityResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeAttachmentsVisibilityResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_808: boolean = input.readBool();
                        _args.success = value_808;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_809: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_809;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_810: core.ServerException = core.ServerException.read(input);
                        _args.error = value_810;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeAttachmentsVisibilityResult(_args);
    }
}
export interface ICreateOrUpdateDocumentCommentResultArgs {
    success?: DocumentComment.DocumentComment;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CreateOrUpdateDocumentCommentResult {
    public success?: DocumentComment.DocumentComment;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICreateOrUpdateDocumentCommentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateDocumentCommentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateDocumentCommentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_811: DocumentComment.DocumentComment = DocumentComment.DocumentComment.read(input);
                        _args.success = value_811;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_812: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_812;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_813: core.ServerException = core.ServerException.read(input);
                        _args.error = value_813;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateOrUpdateDocumentCommentResult(_args);
    }
}
export interface IGetAllDocumentCommentsResultArgs {
    success?: Array<DocumentComment.DocumentComment>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllDocumentCommentsResult {
    public success?: Array<DocumentComment.DocumentComment>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllDocumentCommentsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentCommentsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_814: DocumentComment.DocumentComment): void => {
                value_814.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentCommentsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_815: Array<DocumentComment.DocumentComment> = new Array<DocumentComment.DocumentComment>();
                        const metadata_87: thrift.TList = input.readListBegin();
                        const size_87: number = metadata_87.size;
                        for (let i_87: number = 0; i_87 < size_87; i_87++) {
                            const value_816: DocumentComment.DocumentComment = DocumentComment.DocumentComment.read(input);
                            value_815.push(value_816);
                        }
                        input.readListEnd();
                        _args.success = value_815;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_817: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_817;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_818: core.ServerException = core.ServerException.read(input);
                        _args.error = value_818;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllDocumentCommentsResult(_args);
    }
}
export interface IDeleteDocumentCommentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class DeleteDocumentCommentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IDeleteDocumentCommentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteDocumentCommentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteDocumentCommentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_819: boolean = input.readBool();
                        _args.success = value_819;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_820: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_820;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_821: core.ServerException = core.ServerException.read(input);
                        _args.error = value_821;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteDocumentCommentResult(_args);
    }
}
export interface ICreateOrUpdateDocumentContentHolderLinkResultArgs {
    success?: Array<ContentHolderShowPlace.ContentHolderShowPlace>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CreateOrUpdateDocumentContentHolderLinkResult {
    public success?: Array<ContentHolderShowPlace.ContentHolderShowPlace>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICreateOrUpdateDocumentContentHolderLinkResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateDocumentContentHolderLinkResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_822: ContentHolderShowPlace.ContentHolderShowPlace): void => {
                value_822.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateDocumentContentHolderLinkResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_823: Array<ContentHolderShowPlace.ContentHolderShowPlace> = new Array<ContentHolderShowPlace.ContentHolderShowPlace>();
                        const metadata_88: thrift.TList = input.readListBegin();
                        const size_88: number = metadata_88.size;
                        for (let i_88: number = 0; i_88 < size_88; i_88++) {
                            const value_824: ContentHolderShowPlace.ContentHolderShowPlace = ContentHolderShowPlace.ContentHolderShowPlace.read(input);
                            value_823.push(value_824);
                        }
                        input.readListEnd();
                        _args.success = value_823;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_825: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_825;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_826: core.ServerException = core.ServerException.read(input);
                        _args.error = value_826;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateOrUpdateDocumentContentHolderLinkResult(_args);
    }
}
export interface IDocumentToArchiveResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class DocumentToArchiveResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IDocumentToArchiveResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DocumentToArchiveResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DocumentToArchiveResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_827: boolean = input.readBool();
                        _args.success = value_827;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_828: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_828;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_829: core.ServerException = core.ServerException.read(input);
                        _args.error = value_829;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DocumentToArchiveResult(_args);
    }
}
export interface IGetAllResponsibleForDocumentResultArgs {
    success?: Set<core.UserOrGroup>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllResponsibleForDocumentResult {
    public success?: Set<core.UserOrGroup>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllResponsibleForDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllResponsibleForDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.SET, 0);
            output.writeSetBegin(thrift.Thrift.Type.STRUCT, this.success.size);
            this.success.forEach((value_830: core.UserOrGroup): void => {
                value_830.write(output);
            });
            output.writeSetEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllResponsibleForDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.SET) {
                        const value_831: Set<core.UserOrGroup> = new Set<core.UserOrGroup>();
                        const metadata_89: thrift.TSet = input.readSetBegin();
                        const size_89: number = metadata_89.size;
                        for (let i_89: number = 0; i_89 < size_89; i_89++) {
                            const value_832: core.UserOrGroup = core.UserOrGroup.read(input);
                            value_831.add(value_832);
                        }
                        input.readSetEnd();
                        _args.success = value_831;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_833: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_833;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_834: core.ServerException = core.ServerException.read(input);
                        _args.error = value_834;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllResponsibleForDocumentResult(_args);
    }
}
export interface IAddResponsibleForDocumentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class AddResponsibleForDocumentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IAddResponsibleForDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddResponsibleForDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddResponsibleForDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_835: boolean = input.readBool();
                        _args.success = value_835;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_836: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_836;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_837: core.ServerException = core.ServerException.read(input);
                        _args.error = value_837;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AddResponsibleForDocumentResult(_args);
    }
}
export interface IRemoveResponsibleForDocumentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class RemoveResponsibleForDocumentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IRemoveResponsibleForDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveResponsibleForDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveResponsibleForDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_838: boolean = input.readBool();
                        _args.success = value_838;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_839: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_839;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_840: core.ServerException = core.ServerException.read(input);
                        _args.error = value_840;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveResponsibleForDocumentResult(_args);
    }
}
export interface IGetDocHistoryPageResultArgs {
    success?: HistoryPage.HistoryPage;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetDocHistoryPageResult {
    public success?: HistoryPage.HistoryPage;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetDocHistoryPageResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocHistoryPageResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocHistoryPageResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_841: HistoryPage.HistoryPage = HistoryPage.HistoryPage.read(input);
                        _args.success = value_841;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_842: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_842;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_843: core.ServerException = core.ServerException.read(input);
                        _args.error = value_843;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetDocHistoryPageResult(_args);
    }
}
export interface IGetAllNewsResultArgs {
    success?: Array<core.News>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllNewsResult {
    public success?: Array<core.News>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllNewsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllNewsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_844: core.News): void => {
                value_844.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllNewsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_845: Array<core.News> = new Array<core.News>();
                        const metadata_90: thrift.TList = input.readListBegin();
                        const size_90: number = metadata_90.size;
                        for (let i_90: number = 0; i_90 < size_90; i_90++) {
                            const value_846: core.News = core.News.read(input);
                            value_845.push(value_846);
                        }
                        input.readListEnd();
                        _args.success = value_845;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_847: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_847;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_848: core.ServerException = core.ServerException.read(input);
                        _args.error = value_848;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllNewsResult(_args);
    }
}
export interface IGetTasksByDateResultArgs {
    success?: Map<TodayTaskType.TodayTaskType, number>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetTasksByDateResult {
    public success?: Map<TodayTaskType.TodayTaskType, number>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetTasksByDateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetTasksByDateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.MAP, 0);
            output.writeMapBegin(thrift.Thrift.Type.I32, thrift.Thrift.Type.I32, this.success.size);
            this.success.forEach((value_849: number, key_21: TodayTaskType.TodayTaskType): void => {
                output.writeI32(key_21);
                output.writeI32(value_849);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetTasksByDateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_850: Map<TodayTaskType.TodayTaskType, number> = new Map<TodayTaskType.TodayTaskType, number>();
                        const metadata_91: thrift.TMap = input.readMapBegin();
                        const size_91: number = metadata_91.size;
                        for (let i_91: number = 0; i_91 < size_91; i_91++) {
                            const key_22: TodayTaskType.TodayTaskType = input.readI32();
                            const value_851: number = input.readI32();
                            value_850.set(key_22, value_851);
                        }
                        input.readMapEnd();
                        _args.success = value_850;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_852: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_852;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_853: core.ServerException = core.ServerException.read(input);
                        _args.error = value_853;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetTasksByDateResult(_args);
    }
}
export interface IGenerateDocumentNumberResultArgs {
    success?: string;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GenerateDocumentNumberResult {
    public success?: string;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGenerateDocumentNumberResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GenerateDocumentNumberResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GenerateDocumentNumberResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_854: string = input.readString();
                        _args.success = value_854;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_855: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_855;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_856: core.ServerException = core.ServerException.read(input);
                        _args.error = value_856;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GenerateDocumentNumberResult(_args);
    }
}
export interface ISetDocumentViewedResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class SetDocumentViewedResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ISetDocumentViewedResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetDocumentViewedResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetDocumentViewedResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_857: boolean = input.readBool();
                        _args.success = value_857;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_858: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_858;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_859: core.ServerException = core.ServerException.read(input);
                        _args.error = value_859;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetDocumentViewedResult(_args);
    }
}
export interface IGetAllDocumentRelationsResultArgs {
    success?: Array<DocumentRelation.DocumentRelation>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllDocumentRelationsResult {
    public success?: Array<DocumentRelation.DocumentRelation>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllDocumentRelationsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentRelationsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_860: DocumentRelation.DocumentRelation): void => {
                value_860.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentRelationsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_861: Array<DocumentRelation.DocumentRelation> = new Array<DocumentRelation.DocumentRelation>();
                        const metadata_92: thrift.TList = input.readListBegin();
                        const size_92: number = metadata_92.size;
                        for (let i_92: number = 0; i_92 < size_92; i_92++) {
                            const value_862: DocumentRelation.DocumentRelation = DocumentRelation.DocumentRelation.read(input);
                            value_861.push(value_862);
                        }
                        input.readListEnd();
                        _args.success = value_861;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_863: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_863;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_864: core.ServerException = core.ServerException.read(input);
                        _args.error = value_864;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllDocumentRelationsResult(_args);
    }
}
export interface IChangeRelationsResultArgs {
    success?: Array<DocumentRelation.DocumentRelation>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeRelationsResult {
    public success?: Array<DocumentRelation.DocumentRelation>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeRelationsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeRelationsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_865: DocumentRelation.DocumentRelation): void => {
                value_865.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeRelationsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_866: Array<DocumentRelation.DocumentRelation> = new Array<DocumentRelation.DocumentRelation>();
                        const metadata_93: thrift.TList = input.readListBegin();
                        const size_93: number = metadata_93.size;
                        for (let i_93: number = 0; i_93 < size_93; i_93++) {
                            const value_867: DocumentRelation.DocumentRelation = DocumentRelation.DocumentRelation.read(input);
                            value_866.push(value_867);
                        }
                        input.readListEnd();
                        _args.success = value_866;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_868: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_868;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_869: core.ServerException = core.ServerException.read(input);
                        _args.error = value_869;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeRelationsResult(_args);
    }
}
export interface IChangeSubStatusResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeSubStatusResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeSubStatusResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeSubStatusResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeSubStatusResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_870: boolean = input.readBool();
                        _args.success = value_870;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_871: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_871;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_872: core.ServerException = core.ServerException.read(input);
                        _args.error = value_872;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeSubStatusResult(_args);
    }
}
export interface IRevertSubStatusResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class RevertSubStatusResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IRevertSubStatusResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RevertSubStatusResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RevertSubStatusResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_873: boolean = input.readBool();
                        _args.success = value_873;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_874: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_874;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_875: core.ServerException = core.ServerException.read(input);
                        _args.error = value_875;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RevertSubStatusResult(_args);
    }
}
export interface IIncreaseDeadlineForDocumentOrDocumentExecutionResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class IncreaseDeadlineForDocumentOrDocumentExecutionResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IIncreaseDeadlineForDocumentOrDocumentExecutionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("IncreaseDeadlineForDocumentOrDocumentExecutionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): IncreaseDeadlineForDocumentOrDocumentExecutionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_876: boolean = input.readBool();
                        _args.success = value_876;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_877: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_877;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_878: core.ServerException = core.ServerException.read(input);
                        _args.error = value_878;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new IncreaseDeadlineForDocumentOrDocumentExecutionResult(_args);
    }
}
export interface IAddAdditionalConfirmersResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class AddAdditionalConfirmersResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IAddAdditionalConfirmersResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddAdditionalConfirmersResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddAdditionalConfirmersResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_879: boolean = input.readBool();
                        _args.success = value_879;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_880: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_880;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_881: core.ServerException = core.ServerException.read(input);
                        _args.error = value_881;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AddAdditionalConfirmersResult(_args);
    }
}
export interface ISetAdditionalDecisionResultArgs {
    success?: Document.Document;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class SetAdditionalDecisionResult {
    public success?: Document.Document;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ISetAdditionalDecisionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetAdditionalDecisionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetAdditionalDecisionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_882: Document.Document = Document.Document.read(input);
                        _args.success = value_882;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_883: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_883;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_884: core.ServerException = core.ServerException.read(input);
                        _args.error = value_884;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetAdditionalDecisionResult(_args);
    }
}
export interface ISetAdditionalDecisionUsingServerKeyStorageResultArgs {
    success?: Document.Document;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class SetAdditionalDecisionUsingServerKeyStorageResult {
    public success?: Document.Document;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ISetAdditionalDecisionUsingServerKeyStorageResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetAdditionalDecisionUsingServerKeyStorageResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetAdditionalDecisionUsingServerKeyStorageResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_885: Document.Document = Document.Document.read(input);
                        _args.success = value_885;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_886: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_886;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_887: core.ServerException = core.ServerException.read(input);
                        _args.error = value_887;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetAdditionalDecisionUsingServerKeyStorageResult(_args);
    }
}
export interface ISetAdditionalDecisionExtResultArgs {
    success?: Document.Document;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class SetAdditionalDecisionExtResult {
    public success?: Document.Document;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ISetAdditionalDecisionExtResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetAdditionalDecisionExtResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetAdditionalDecisionExtResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_888: Document.Document = Document.Document.read(input);
                        _args.success = value_888;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_889: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_889;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_890: core.ServerException = core.ServerException.read(input);
                        _args.error = value_890;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetAdditionalDecisionExtResult(_args);
    }
}
export interface IRevokeDecisionResultArgs {
    success?: Document.Document;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class RevokeDecisionResult {
    public success?: Document.Document;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IRevokeDecisionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RevokeDecisionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RevokeDecisionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_891: Document.Document = Document.Document.read(input);
                        _args.success = value_891;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_892: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_892;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_893: core.ServerException = core.ServerException.read(input);
                        _args.error = value_893;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RevokeDecisionResult(_args);
    }
}
export interface IMarkDecisionAsRemovedResultArgs {
    success?: DocumentExecution.DocumentExecution;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class MarkDecisionAsRemovedResult {
    public success?: DocumentExecution.DocumentExecution;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IMarkDecisionAsRemovedResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MarkDecisionAsRemovedResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MarkDecisionAsRemovedResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_894: DocumentExecution.DocumentExecution = DocumentExecution.DocumentExecution.read(input);
                        _args.success = value_894;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_895: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_895;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_896: core.ServerException = core.ServerException.read(input);
                        _args.error = value_896;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new MarkDecisionAsRemovedResult(_args);
    }
}
export interface IGetAllOpenDocumentExecutionsStatisticResultArgs {
    success?: Map<DocumentExecutionStatisticType.DocumentExecutionStatisticType, number>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllOpenDocumentExecutionsStatisticResult {
    public success?: Map<DocumentExecutionStatisticType.DocumentExecutionStatisticType, number>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllOpenDocumentExecutionsStatisticResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllOpenDocumentExecutionsStatisticResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.MAP, 0);
            output.writeMapBegin(thrift.Thrift.Type.I32, thrift.Thrift.Type.I32, this.success.size);
            this.success.forEach((value_897: number, key_23: DocumentExecutionStatisticType.DocumentExecutionStatisticType): void => {
                output.writeI32(key_23);
                output.writeI32(value_897);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllOpenDocumentExecutionsStatisticResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_898: Map<DocumentExecutionStatisticType.DocumentExecutionStatisticType, number> = new Map<DocumentExecutionStatisticType.DocumentExecutionStatisticType, number>();
                        const metadata_94: thrift.TMap = input.readMapBegin();
                        const size_94: number = metadata_94.size;
                        for (let i_94: number = 0; i_94 < size_94; i_94++) {
                            const key_24: DocumentExecutionStatisticType.DocumentExecutionStatisticType = input.readI32();
                            const value_899: number = input.readI32();
                            value_898.set(key_24, value_899);
                        }
                        input.readMapEnd();
                        _args.success = value_898;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_900: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_900;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_901: core.ServerException = core.ServerException.read(input);
                        _args.error = value_901;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllOpenDocumentExecutionsStatisticResult(_args);
    }
}
export interface IChangeControlForDocumentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeControlForDocumentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeControlForDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeControlForDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeControlForDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_902: boolean = input.readBool();
                        _args.success = value_902;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_903: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_903;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_904: core.ServerException = core.ServerException.read(input);
                        _args.error = value_904;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeControlForDocumentResult(_args);
    }
}
export interface IAddTagsToDocumentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class AddTagsToDocumentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IAddTagsToDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddTagsToDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddTagsToDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_905: boolean = input.readBool();
                        _args.success = value_905;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_906: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_906;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_907: core.ServerException = core.ServerException.read(input);
                        _args.error = value_907;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AddTagsToDocumentResult(_args);
    }
}
export interface IRemoveTagsToDocumentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class RemoveTagsToDocumentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IRemoveTagsToDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveTagsToDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveTagsToDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_908: boolean = input.readBool();
                        _args.success = value_908;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_909: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_909;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_910: core.ServerException = core.ServerException.read(input);
                        _args.error = value_910;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveTagsToDocumentResult(_args);
    }
}
export interface IAddExecutorsToStageResultArgs {
    success?: Array<DocumentExecution.DocumentExecution>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class AddExecutorsToStageResult {
    public success?: Array<DocumentExecution.DocumentExecution>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IAddExecutorsToStageResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddExecutorsToStageResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_911: DocumentExecution.DocumentExecution): void => {
                value_911.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddExecutorsToStageResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_912: Array<DocumentExecution.DocumentExecution> = new Array<DocumentExecution.DocumentExecution>();
                        const metadata_95: thrift.TList = input.readListBegin();
                        const size_95: number = metadata_95.size;
                        for (let i_95: number = 0; i_95 < size_95; i_95++) {
                            const value_913: DocumentExecution.DocumentExecution = DocumentExecution.DocumentExecution.read(input);
                            value_912.push(value_913);
                        }
                        input.readListEnd();
                        _args.success = value_912;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_914: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_914;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_915: core.ServerException = core.ServerException.read(input);
                        _args.error = value_915;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AddExecutorsToStageResult(_args);
    }
}
export interface IGetCountDocsByFilterNoPermissionResultArgs {
    success?: number | Int64;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetCountDocsByFilterNoPermissionResult {
    public success?: Int64;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetCountDocsByFilterNoPermissionResultArgs) {
        if (args != null && args.success != null) {
            if (typeof args.success === "number") {
                this.success = new Int64(args.success);
            }
            else {
                this.success = args.success;
            }
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountDocsByFilterNoPermissionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I64, 0);
            output.writeI64(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountDocsByFilterNoPermissionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_916: Int64 = input.readI64();
                        _args.success = value_916;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_917: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_917;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_918: core.ServerException = core.ServerException.read(input);
                        _args.error = value_918;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetCountDocsByFilterNoPermissionResult(_args);
    }
}
export interface IGetTinyDocsByFilterNoPermissionResultArgs {
    success?: Array<Document.Document>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetTinyDocsByFilterNoPermissionResult {
    public success?: Array<Document.Document>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetTinyDocsByFilterNoPermissionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetTinyDocsByFilterNoPermissionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_919: Document.Document): void => {
                value_919.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetTinyDocsByFilterNoPermissionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_920: Array<Document.Document> = new Array<Document.Document>();
                        const metadata_96: thrift.TList = input.readListBegin();
                        const size_96: number = metadata_96.size;
                        for (let i_96: number = 0; i_96 < size_96; i_96++) {
                            const value_921: Document.Document = Document.Document.read(input);
                            value_920.push(value_921);
                        }
                        input.readListEnd();
                        _args.success = value_920;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_922: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_922;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_923: core.ServerException = core.ServerException.read(input);
                        _args.error = value_923;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetTinyDocsByFilterNoPermissionResult(_args);
    }
}
export interface IChangeRegistrationInfoForDocumentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeRegistrationInfoForDocumentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeRegistrationInfoForDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeRegistrationInfoForDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeRegistrationInfoForDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_924: boolean = input.readBool();
                        _args.success = value_924;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_925: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_925;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_926: core.ServerException = core.ServerException.read(input);
                        _args.error = value_926;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeRegistrationInfoForDocumentResult(_args);
    }
}
export interface ICreateChatForDocumentResultArgs {
    success?: string;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CreateChatForDocumentResult {
    public success?: string;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICreateChatForDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateChatForDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateChatForDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_927: string = input.readString();
                        _args.success = value_927;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_928: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_928;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_929: core.ServerException = core.ServerException.read(input);
                        _args.error = value_929;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateChatForDocumentResult(_args);
    }
}
export interface IGetDocumentExtShareListResultArgs {
    success?: Array<DocumentExtShare.DocumentExtShare>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetDocumentExtShareListResult {
    public success?: Array<DocumentExtShare.DocumentExtShare>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetDocumentExtShareListResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentExtShareListResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_930: DocumentExtShare.DocumentExtShare): void => {
                value_930.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentExtShareListResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_931: Array<DocumentExtShare.DocumentExtShare> = new Array<DocumentExtShare.DocumentExtShare>();
                        const metadata_97: thrift.TList = input.readListBegin();
                        const size_97: number = metadata_97.size;
                        for (let i_97: number = 0; i_97 < size_97; i_97++) {
                            const value_932: DocumentExtShare.DocumentExtShare = DocumentExtShare.DocumentExtShare.read(input);
                            value_931.push(value_932);
                        }
                        input.readListEnd();
                        _args.success = value_931;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_933: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_933;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_934: core.ServerException = core.ServerException.read(input);
                        _args.error = value_934;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetDocumentExtShareListResult(_args);
    }
}
export interface IChangeDocumentExtShareResultArgs {
    success?: Array<DocumentExtShare.DocumentExtShare>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeDocumentExtShareResult {
    public success?: Array<DocumentExtShare.DocumentExtShare>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeDocumentExtShareResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeDocumentExtShareResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_935: DocumentExtShare.DocumentExtShare): void => {
                value_935.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeDocumentExtShareResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_936: Array<DocumentExtShare.DocumentExtShare> = new Array<DocumentExtShare.DocumentExtShare>();
                        const metadata_98: thrift.TList = input.readListBegin();
                        const size_98: number = metadata_98.size;
                        for (let i_98: number = 0; i_98 < size_98; i_98++) {
                            const value_937: DocumentExtShare.DocumentExtShare = DocumentExtShare.DocumentExtShare.read(input);
                            value_936.push(value_937);
                        }
                        input.readListEnd();
                        _args.success = value_936;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_938: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_938;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_939: core.ServerException = core.ServerException.read(input);
                        _args.error = value_939;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeDocumentExtShareResult(_args);
    }
}
export interface IChangeAttachmentExtStatusResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeAttachmentExtStatusResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeAttachmentExtStatusResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeAttachmentExtStatusResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeAttachmentExtStatusResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_940: boolean = input.readBool();
                        _args.success = value_940;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_941: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_941;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_942: core.ServerException = core.ServerException.read(input);
                        _args.error = value_942;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeAttachmentExtStatusResult(_args);
    }
}
export interface IRemindDocumentExecutorResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class RemindDocumentExecutorResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IRemindDocumentExecutorResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemindDocumentExecutorResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemindDocumentExecutorResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_943: boolean = input.readBool();
                        _args.success = value_943;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_944: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_944;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_945: core.ServerException = core.ServerException.read(input);
                        _args.error = value_945;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemindDocumentExecutorResult(_args);
    }
}
export interface IUpdateReassignResolutionResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class UpdateReassignResolutionResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IUpdateReassignResolutionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateReassignResolutionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateReassignResolutionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_946: boolean = input.readBool();
                        _args.success = value_946;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_947: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_947;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_948: core.ServerException = core.ServerException.read(input);
                        _args.error = value_948;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new UpdateReassignResolutionResult(_args);
    }
}
export interface IUpdateSubStatusCommentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class UpdateSubStatusCommentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IUpdateSubStatusCommentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateSubStatusCommentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateSubStatusCommentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_949: boolean = input.readBool();
                        _args.success = value_949;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_950: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_950;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_951: core.ServerException = core.ServerException.read(input);
                        _args.error = value_951;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new UpdateSubStatusCommentResult(_args);
    }
}
export interface IRemoveSubStatusCommentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class RemoveSubStatusCommentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IRemoveSubStatusCommentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveSubStatusCommentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveSubStatusCommentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_952: boolean = input.readBool();
                        _args.success = value_952;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_953: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_953;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_954: core.ServerException = core.ServerException.read(input);
                        _args.error = value_954;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveSubStatusCommentResult(_args);
    }
}
export interface IChangeDocumentTypeResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeDocumentTypeResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeDocumentTypeResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeDocumentTypeResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeDocumentTypeResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_955: boolean = input.readBool();
                        _args.success = value_955;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_956: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_956;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_957: core.ServerException = core.ServerException.read(input);
                        _args.error = value_957;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeDocumentTypeResult(_args);
    }
}
export interface IGetDocumentRelationModelResultArgs {
    success?: DocumentRelationModel.DocumentRelationModel;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetDocumentRelationModelResult {
    public success?: DocumentRelationModel.DocumentRelationModel;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetDocumentRelationModelResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentRelationModelResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentRelationModelResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_958: DocumentRelationModel.DocumentRelationModel = DocumentRelationModel.DocumentRelationModel.read(input);
                        _args.success = value_958;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_959: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_959;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_960: core.ServerException = core.ServerException.read(input);
                        _args.error = value_960;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetDocumentRelationModelResult(_args);
    }
}
export interface IGetNewConvertedAttachmentVersionResultArgs {
    success?: Attachment.Attachment;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetNewConvertedAttachmentVersionResult {
    public success?: Attachment.Attachment;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetNewConvertedAttachmentVersionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetNewConvertedAttachmentVersionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetNewConvertedAttachmentVersionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_961: Attachment.Attachment = Attachment.Attachment.read(input);
                        _args.success = value_961;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_962: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_962;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_963: core.ServerException = core.ServerException.read(input);
                        _args.error = value_963;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetNewConvertedAttachmentVersionResult(_args);
    }
}
export interface IExportAsXMLResultArgs {
    success?: Buffer;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ExportAsXMLResult {
    public success?: Buffer;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IExportAsXMLResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExportAsXMLResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeBinary(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExportAsXMLResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_964: Buffer = input.readBinary();
                        _args.success = value_964;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_965: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_965;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_966: core.ServerException = core.ServerException.read(input);
                        _args.error = value_966;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExportAsXMLResult(_args);
    }
}
export interface IExportAsXMLv2ResultArgs {
    success?: Buffer;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ExportAsXMLv2Result {
    public success?: Buffer;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IExportAsXMLv2ResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExportAsXMLv2Result");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeBinary(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExportAsXMLv2Result {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_967: Buffer = input.readBinary();
                        _args.success = value_967;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_968: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_968;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_969: core.ServerException = core.ServerException.read(input);
                        _args.error = value_969;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExportAsXMLv2Result(_args);
    }
}
export interface IImportFromXMLResultArgs {
    success?: Document.Document;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ImportFromXMLResult {
    public success?: Document.Document;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IImportFromXMLResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ImportFromXMLResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ImportFromXMLResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_970: Document.Document = Document.Document.read(input);
                        _args.success = value_970;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_971: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_971;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_972: core.ServerException = core.ServerException.read(input);
                        _args.error = value_972;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ImportFromXMLResult(_args);
    }
}
export interface IGetDocContentItemsForChangeTypeResultArgs {
    success?: Array<ContentItem.ContentItem>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetDocContentItemsForChangeTypeResult {
    public success?: Array<ContentItem.ContentItem>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetDocContentItemsForChangeTypeResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocContentItemsForChangeTypeResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_973: ContentItem.ContentItem): void => {
                value_973.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocContentItemsForChangeTypeResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_974: Array<ContentItem.ContentItem> = new Array<ContentItem.ContentItem>();
                        const metadata_99: thrift.TList = input.readListBegin();
                        const size_99: number = metadata_99.size;
                        for (let i_99: number = 0; i_99 < size_99; i_99++) {
                            const value_975: ContentItem.ContentItem = ContentItem.ContentItem.read(input);
                            value_974.push(value_975);
                        }
                        input.readListEnd();
                        _args.success = value_974;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_976: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_976;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_977: core.ServerException = core.ServerException.read(input);
                        _args.error = value_977;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetDocContentItemsForChangeTypeResult(_args);
    }
}
export interface IDownloadDocumentTemplateResultArgs {
    success?: Buffer;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class DownloadDocumentTemplateResult {
    public success?: Buffer;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IDownloadDocumentTemplateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DownloadDocumentTemplateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeBinary(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DownloadDocumentTemplateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_978: Buffer = input.readBinary();
                        _args.success = value_978;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_979: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_979;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_980: core.ServerException = core.ServerException.read(input);
                        _args.error = value_980;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DownloadDocumentTemplateResult(_args);
    }
}
export interface IGetAllDocumentExecutionsByFilterResultArgs {
    success?: Array<DocumentExecution.DocumentExecution>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllDocumentExecutionsByFilterResult {
    public success?: Array<DocumentExecution.DocumentExecution>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllDocumentExecutionsByFilterResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentExecutionsByFilterResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_981: DocumentExecution.DocumentExecution): void => {
                value_981.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentExecutionsByFilterResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_982: Array<DocumentExecution.DocumentExecution> = new Array<DocumentExecution.DocumentExecution>();
                        const metadata_100: thrift.TList = input.readListBegin();
                        const size_100: number = metadata_100.size;
                        for (let i_100: number = 0; i_100 < size_100; i_100++) {
                            const value_983: DocumentExecution.DocumentExecution = DocumentExecution.DocumentExecution.read(input);
                            value_982.push(value_983);
                        }
                        input.readListEnd();
                        _args.success = value_982;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_984: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_984;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_985: core.ServerException = core.ServerException.read(input);
                        _args.error = value_985;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllDocumentExecutionsByFilterResult(_args);
    }
}
export interface IGetDocumentIdResultArgs {
    success?: string;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetDocumentIdResult {
    public success?: string;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetDocumentIdResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentIdResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentIdResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_986: string = input.readString();
                        _args.success = value_986;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_987: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_987;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_988: core.ServerException = core.ServerException.read(input);
                        _args.error = value_988;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetDocumentIdResult(_args);
    }
}
export interface IChangeDocumentNameResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeDocumentNameResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeDocumentNameResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeDocumentNameResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeDocumentNameResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_989: boolean = input.readBool();
                        _args.success = value_989;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_990: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_990;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_991: core.ServerException = core.ServerException.read(input);
                        _args.error = value_991;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeDocumentNameResult(_args);
    }
}
export interface IChangeAttachmentOrderResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeAttachmentOrderResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeAttachmentOrderResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeAttachmentOrderResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeAttachmentOrderResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_992: boolean = input.readBool();
                        _args.success = value_992;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_993: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_993;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_994: core.ServerException = core.ServerException.read(input);
                        _args.error = value_994;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeAttachmentOrderResult(_args);
    }
}
export interface ICompareAttachmentsURLResultArgs {
    success?: string;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CompareAttachmentsURLResult {
    public success?: string;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICompareAttachmentsURLResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CompareAttachmentsURLResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CompareAttachmentsURLResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_995: string = input.readString();
                        _args.success = value_995;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_996: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_996;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_997: core.ServerException = core.ServerException.read(input);
                        _args.error = value_997;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CompareAttachmentsURLResult(_args);
    }
}
export interface IGetDocumentDecisionXmlResultArgs {
    success?: string;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetDocumentDecisionXmlResult {
    public success?: string;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetDocumentDecisionXmlResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentDecisionXmlResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentDecisionXmlResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_998: string = input.readString();
                        _args.success = value_998;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_999: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_999;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1000: core.ServerException = core.ServerException.read(input);
                        _args.error = value_1000;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetDocumentDecisionXmlResult(_args);
    }
}
export interface IGetReassignDocXmlResultArgs {
    success?: string;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetReassignDocXmlResult {
    public success?: string;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetReassignDocXmlResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetReassignDocXmlResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetReassignDocXmlResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_1001: string = input.readString();
                        _args.success = value_1001;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1002: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_1002;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1003: core.ServerException = core.ServerException.read(input);
                        _args.error = value_1003;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetReassignDocXmlResult(_args);
    }
}
export interface IAddAnswerersResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class AddAnswerersResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IAddAnswerersResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddAnswerersResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddAnswerersResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_1004: boolean = input.readBool();
                        _args.success = value_1004;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1005: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_1005;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1006: core.ServerException = core.ServerException.read(input);
                        _args.error = value_1006;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AddAnswerersResult(_args);
    }
}
export interface IAddAnswerersToLinkedDocumentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class AddAnswerersToLinkedDocumentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IAddAnswerersToLinkedDocumentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddAnswerersToLinkedDocumentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddAnswerersToLinkedDocumentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_1007: boolean = input.readBool();
                        _args.success = value_1007;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1008: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_1008;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1009: core.ServerException = core.ServerException.read(input);
                        _args.error = value_1009;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AddAnswerersToLinkedDocumentResult(_args);
    }
}
export interface ICreateMeetingQuestionResultArgs {
    success?: Document.Document;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CreateMeetingQuestionResult {
    public success?: Document.Document;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICreateMeetingQuestionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateMeetingQuestionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateMeetingQuestionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1010: Document.Document = Document.Document.read(input);
                        _args.success = value_1010;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1011: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_1011;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1012: core.ServerException = core.ServerException.read(input);
                        _args.error = value_1012;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateMeetingQuestionResult(_args);
    }
}
export interface IChangeExternalNumberResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ChangeExternalNumberResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IChangeExternalNumberResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeExternalNumberResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeExternalNumberResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_1013: boolean = input.readBool();
                        _args.success = value_1013;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1014: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_1014;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1015: core.ServerException = core.ServerException.read(input);
                        _args.error = value_1015;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeExternalNumberResult(_args);
    }
}
export interface IGetAvailableSubStatusesResultArgs {
    success?: Set<DocPatternStageSubStatus.DocPatternStageSubStatus>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAvailableSubStatusesResult {
    public success?: Set<DocPatternStageSubStatus.DocPatternStageSubStatus>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAvailableSubStatusesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAvailableSubStatusesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.SET, 0);
            output.writeSetBegin(thrift.Thrift.Type.I32, this.success.size);
            this.success.forEach((value_1016: DocPatternStageSubStatus.DocPatternStageSubStatus): void => {
                output.writeI32(value_1016);
            });
            output.writeSetEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAvailableSubStatusesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.SET) {
                        const value_1017: Set<DocPatternStageSubStatus.DocPatternStageSubStatus> = new Set<DocPatternStageSubStatus.DocPatternStageSubStatus>();
                        const metadata_101: thrift.TSet = input.readSetBegin();
                        const size_101: number = metadata_101.size;
                        for (let i_101: number = 0; i_101 < size_101; i_101++) {
                            const value_1018: DocPatternStageSubStatus.DocPatternStageSubStatus = input.readI32();
                            value_1017.add(value_1018);
                        }
                        input.readSetEnd();
                        _args.success = value_1017;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1019: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_1019;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1020: core.ServerException = core.ServerException.read(input);
                        _args.error = value_1020;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAvailableSubStatusesResult(_args);
    }
}
export interface ICardWorkingStartResultArgs {
    success?: DocumentExecution.DocumentExecution;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CardWorkingStartResult {
    public success?: DocumentExecution.DocumentExecution;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICardWorkingStartResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CardWorkingStartResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CardWorkingStartResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1021: DocumentExecution.DocumentExecution = DocumentExecution.DocumentExecution.read(input);
                        _args.success = value_1021;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1022: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_1022;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1023: core.ServerException = core.ServerException.read(input);
                        _args.error = value_1023;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CardWorkingStartResult(_args);
    }
}
export interface ICardWorkingLogResultArgs {
    success?: DocumentExecution.DocumentExecution;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CardWorkingLogResult {
    public success?: DocumentExecution.DocumentExecution;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICardWorkingLogResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CardWorkingLogResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CardWorkingLogResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1024: DocumentExecution.DocumentExecution = DocumentExecution.DocumentExecution.read(input);
                        _args.success = value_1024;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1025: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_1025;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1026: core.ServerException = core.ServerException.read(input);
                        _args.error = value_1026;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CardWorkingLogResult(_args);
    }
}
export interface ICardWorkingStopResultArgs {
    success?: DocumentExecution.DocumentExecution;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CardWorkingStopResult {
    public success?: DocumentExecution.DocumentExecution;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICardWorkingStopResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CardWorkingStopResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CardWorkingStopResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1027: DocumentExecution.DocumentExecution = DocumentExecution.DocumentExecution.read(input);
                        _args.success = value_1027;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1028: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_1028;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1029: core.ServerException = core.ServerException.read(input);
                        _args.error = value_1029;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CardWorkingStopResult(_args);
    }
}
export interface IGetEnabledSubStatusesResultArgs {
    success?: Map<SubStatusKey.SubStatusKey, Array<DocPatternStageSubStatus.DocPatternStageSubStatus>>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetEnabledSubStatusesResult {
    public success?: Map<SubStatusKey.SubStatusKey, Array<DocPatternStageSubStatus.DocPatternStageSubStatus>>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetEnabledSubStatusesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetEnabledSubStatusesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.MAP, 0);
            output.writeMapBegin(thrift.Thrift.Type.I32, thrift.Thrift.Type.LIST, this.success.size);
            this.success.forEach((value_1030: Array<DocPatternStageSubStatus.DocPatternStageSubStatus>, key_25: SubStatusKey.SubStatusKey): void => {
                output.writeI32(key_25);
                output.writeListBegin(thrift.Thrift.Type.I32, value_1030.length);
                value_1030.forEach((value_1031: DocPatternStageSubStatus.DocPatternStageSubStatus): void => {
                    output.writeI32(value_1031);
                });
                output.writeListEnd();
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetEnabledSubStatusesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_1032: Map<SubStatusKey.SubStatusKey, Array<DocPatternStageSubStatus.DocPatternStageSubStatus>> = new Map<SubStatusKey.SubStatusKey, Array<DocPatternStageSubStatus.DocPatternStageSubStatus>>();
                        const metadata_102: thrift.TMap = input.readMapBegin();
                        const size_102: number = metadata_102.size;
                        for (let i_102: number = 0; i_102 < size_102; i_102++) {
                            const key_26: SubStatusKey.SubStatusKey = input.readI32();
                            const value_1033: Array<DocPatternStageSubStatus.DocPatternStageSubStatus> = new Array<DocPatternStageSubStatus.DocPatternStageSubStatus>();
                            const metadata_103: thrift.TList = input.readListBegin();
                            const size_103: number = metadata_103.size;
                            for (let i_103: number = 0; i_103 < size_103; i_103++) {
                                const value_1034: DocPatternStageSubStatus.DocPatternStageSubStatus = input.readI32();
                                value_1033.push(value_1034);
                            }
                            input.readListEnd();
                            value_1032.set(key_26, value_1033);
                        }
                        input.readMapEnd();
                        _args.success = value_1032;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1035: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_1035;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1036: core.ServerException = core.ServerException.read(input);
                        _args.error = value_1036;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetEnabledSubStatusesResult(_args);
    }
}
export interface IUpdateUserTagResultArgs {
    success?: DocumentTag.DocumentTag;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class UpdateUserTagResult {
    public success?: DocumentTag.DocumentTag;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IUpdateUserTagResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateUserTagResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateUserTagResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1037: DocumentTag.DocumentTag = DocumentTag.DocumentTag.read(input);
                        _args.success = value_1037;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1038: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_1038;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1039: core.ServerException = core.ServerException.read(input);
                        _args.error = value_1039;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new UpdateUserTagResult(_args);
    }
}
export interface IGetUserTagsResultArgs {
    success?: Array<DocumentTag.DocumentTag>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetUserTagsResult {
    public success?: Array<DocumentTag.DocumentTag>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetUserTagsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetUserTagsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_1040: DocumentTag.DocumentTag): void => {
                value_1040.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetUserTagsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_1041: Array<DocumentTag.DocumentTag> = new Array<DocumentTag.DocumentTag>();
                        const metadata_104: thrift.TList = input.readListBegin();
                        const size_104: number = metadata_104.size;
                        for (let i_104: number = 0; i_104 < size_104; i_104++) {
                            const value_1042: DocumentTag.DocumentTag = DocumentTag.DocumentTag.read(input);
                            value_1041.push(value_1042);
                        }
                        input.readListEnd();
                        _args.success = value_1041;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1043: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_1043;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1044: core.ServerException = core.ServerException.read(input);
                        _args.error = value_1044;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetUserTagsResult(_args);
    }
}
export interface IUpdateTagOrdersResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class UpdateTagOrdersResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IUpdateTagOrdersResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateTagOrdersResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateTagOrdersResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_1045: boolean = input.readBool();
                        _args.success = value_1045;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1046: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_1046;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1047: core.ServerException = core.ServerException.read(input);
                        _args.error = value_1047;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new UpdateTagOrdersResult(_args);
    }
}
export interface IDocumentFieldByKeyResultArgs {
    success?: string;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class DocumentFieldByKeyResult {
    public success?: string;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IDocumentFieldByKeyResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DocumentFieldByKeyResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DocumentFieldByKeyResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_1048: string = input.readString();
                        _args.success = value_1048;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1049: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_1049;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1050: core.ServerException = core.ServerException.read(input);
                        _args.error = value_1050;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DocumentFieldByKeyResult(_args);
    }
}
export interface IAddDecorationResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class AddDecorationResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IAddDecorationResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddDecorationResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddDecorationResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_1051: boolean = input.readBool();
                        _args.success = value_1051;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1052: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_1052;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_1053: core.ServerException = core.ServerException.read(input);
                        _args.error = value_1053;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AddDecorationResult(_args);
    }
}
export class Client {
    public _seqid: number;
    public _reqs: {
        [name: number]: (err: Error | object | undefined, val?: any) => void;
    };
    public output: thrift.TTransport;
    public protocol: new (trans: thrift.TTransport) => thrift.TProtocol;
    constructor(output: thrift.TTransport, protocol: new (trans: thrift.TTransport) => thrift.TProtocol) {
        this._seqid = 0;
        this._reqs = {};
        this.output = output;
        this.protocol = protocol;
    }
    public incrementSeqId(): number {
        return this._seqid += 1;
    }
    public calculatePermissions(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<DocPermissions.DocPermissions> {
        const requestId: number = this.incrementSeqId();
        return new Promise<DocPermissions.DocPermissions>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_calculatePermissions(token, documentId, accessPolicy, requestId);
        });
    }
    public createOrUpdateDocument(token: string, document: Document.Document, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<Document.Document> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Document.Document>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createOrUpdateDocument(token, document, accessPolicy, requestId);
        });
    }
    public updateDocument(token: string, document: Document.Document, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, addedResponsibles: Array<core.UserOrGroup>, removedResponsibles: Array<core.UserOrGroup>, addedSecurityClassificationIds: Array<string>, removedSecurityClassificationIds: Array<string>): Promise<Document.Document> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Document.Document>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_updateDocument(token, document, accessPolicy, addedResponsibles, removedResponsibles, addedSecurityClassificationIds, removedSecurityClassificationIds, requestId);
        });
    }
    public createDocument(token: string, document: Document.Document, users: Array<core.UserOrGroup>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, securityClassificationsId: Set<string>, attachments: Array<AttCreateInfo.AttCreateInfo>, docRelations: Array<DocumentRelation.DocumentRelation>): Promise<Document.Document> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Document.Document>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createDocument(token, document, users, holderLinks, securityClassificationsId, attachments, docRelations, requestId);
        });
    }
    public createDocumentFromXML(token: string, xmlDoc: Buffer): Promise<Document.Document> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Document.Document>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createDocumentFromXML(token, xmlDoc, requestId);
        });
    }
    public getDocument(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, decrypt: boolean, executorsPortion: number): Promise<Document.Document> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Document.Document>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getDocument(token, documentId, accessPolicy, decrypt, executorsPortion, requestId);
        });
    }
    public getAllDocuments(token: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter): Promise<Array<Document.Document>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<Document.Document>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllDocuments(token, accessPolicy, filter, requestId);
        });
    }
    public getCountAllDocuments(token: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter): Promise<number> {
        const requestId: number = this.incrementSeqId();
        return new Promise<number>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getCountAllDocuments(token, accessPolicy, filter, requestId);
        });
    }
    public deleteDocument(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteDocument(token, documentId, accessPolicy, requestId);
        });
    }
    public getAllPassedStages(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter): Promise<Array<PassedStage.PassedStage>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<PassedStage.PassedStage>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllPassedStages(token, documentId, accessPolicy, filter, requestId);
        });
    }
    public getExecutionTree(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, iteration: number, filter: core.KazFilter): Promise<Array<ExecutionTree.ExecutionTree>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<ExecutionTree.ExecutionTree>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getExecutionTree(token, documentId, accessPolicy, iteration, filter, requestId);
        });
    }
    public getActiveStages(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<Array<DocumentPatternStage.DocumentPatternStage>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocumentPatternStage.DocumentPatternStage>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getActiveStages(token, documentId, accessPolicy, requestId);
        });
    }
    public getCountPeoplesWhenRenderedDecision(token: string, documentId: string, stageId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<Map<string, number>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Map<string, number>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getCountPeoplesWhenRenderedDecision(token, documentId, stageId, accessPolicy, requestId);
        });
    }
    public setDocumentDecision(token: string, documentId: string, decision: string, documentComment: string, force: boolean, signature: string, cardId: string, attachments: Array<AttCreateInfo.AttCreateInfo>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, addSignToAttachment: Map<string, Array<string>>): Promise<Document.Document> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Document.Document>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setDocumentDecision(token, documentId, decision, documentComment, force, signature, cardId, attachments, holderLinks, accessPolicy, addSignToAttachment, requestId);
        });
    }
    public setDocumentDecisionByLinkId(token: string, documentId: string, linkID: string, cardId: string, documentComment: string, force: boolean, signature: string, pKeyId: string, password: string, attachments: Array<AttCreateInfo.AttCreateInfo>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, addSignToAttachment: Map<string, Array<string>>, attachmentsToSign: Array<string>): Promise<Document.Document> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Document.Document>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setDocumentDecisionByLinkId(token, documentId, linkID, cardId, documentComment, force, signature, pKeyId, password, attachments, holderLinks, accessPolicy, addSignToAttachment, attachmentsToSign, requestId);
        });
    }
    public setDocumentDecisionUsingServerKeyStorage(token: string, documentId: string, decision: string, documentComment: string, force: boolean, pKeyId: string, password: string, cardId: string, attachments: Array<AttCreateInfo.AttCreateInfo>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, attachmentsToSign: Array<string>): Promise<Document.Document> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Document.Document>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setDocumentDecisionUsingServerKeyStorage(token, documentId, decision, documentComment, force, pKeyId, password, cardId, attachments, holderLinks, accessPolicy, attachmentsToSign, requestId);
        });
    }
    public setDocumentDecisionExt(token: string, documentId: string, cardId: string, linkID: string, documentComment: string, force: boolean, attachments: Array<AttCreateInfo.AttCreateInfo>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, addSignToDecision: Array<string>, addSignToAttachment: Map<string, Array<string>>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<Document.Document> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Document.Document>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setDocumentDecisionExt(token, documentId, cardId, linkID, documentComment, force, attachments, holderLinks, addSignToDecision, addSignToAttachment, accessPolicy, requestId);
        });
    }
    public approveDocumentDecision(token: string, executionId: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_approveDocumentDecision(token, executionId, requestId);
        });
    }
    public shareDocument(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, usersOrGroups: Array<core.UserOrGroup>): Promise<Array<DocumentExecution.DocumentExecution>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocumentExecution.DocumentExecution>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_shareDocument(token, documentId, accessPolicy, usersOrGroups, requestId);
        });
    }
    public revokeDocument(token: string, documentId: string, usersOrGroups: Array<core.UserOrGroup>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_revokeDocument(token, documentId, usersOrGroups, accessPolicy, requestId);
        });
    }
    public getAllDocumentSharings(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter): Promise<Array<core.UserOrGroup>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<core.UserOrGroup>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllDocumentSharings(token, documentId, accessPolicy, filter, requestId);
        });
    }
    public getAllDocumentReassign(token: string, filter: core.KazFilter): Promise<Array<DocumentReassign.DocumentReassign>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocumentReassign.DocumentReassign>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllDocumentReassign(token, filter, requestId);
        });
    }
    public reassignDocument(token: string, documentId: string, documentReassign: Array<DocumentReassign.DocumentReassign>, cardId: string, signature: string): Promise<Array<DocumentExecution.DocumentExecution>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocumentExecution.DocumentExecution>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_reassignDocument(token, documentId, documentReassign, cardId, signature, requestId);
        });
    }
    public reassignDocumentUsingServerKeyStorage(token: string, documentId: string, documentReassign: Array<DocumentReassign.DocumentReassign>, cardId: string, pKeyId: string, password: string): Promise<Array<DocumentExecution.DocumentExecution>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocumentExecution.DocumentExecution>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_reassignDocumentUsingServerKeyStorage(token, documentId, documentReassign, cardId, pKeyId, password, requestId);
        });
    }
    public reassignDocumentExt(token: string, documentId: string, cardId: string, documentReassign: Array<DocumentReassign.DocumentReassign>, addSignToReasign: Array<string>): Promise<Array<DocumentExecution.DocumentExecution>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocumentExecution.DocumentExecution>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_reassignDocumentExt(token, documentId, cardId, documentReassign, addSignToReasign, requestId);
        });
    }
    public revokeChildCards(token: string, cardId: string, deleteCard: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_revokeChildCards(token, cardId, deleteCard, accessPolicy, requestId);
        });
    }
    public createOrUpdateAutomaticDocumentReassign(token: string, documentReassign: DocumentReassign.DocumentReassign): Promise<DocumentReassign.DocumentReassign> {
        const requestId: number = this.incrementSeqId();
        return new Promise<DocumentReassign.DocumentReassign>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createOrUpdateAutomaticDocumentReassign(token, documentReassign, requestId);
        });
    }
    public deleteAutomaticDocumentReassign(token: string, documentReassignId: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteAutomaticDocumentReassign(token, documentReassignId, requestId);
        });
    }
    public changeReassignControl(token: string, documentExecutionId: string, userId: string, reassignType: ExecutionReassignType.ExecutionReassignType): Promise<DocumentExecution.DocumentExecution> {
        const requestId: number = this.incrementSeqId();
        return new Promise<DocumentExecution.DocumentExecution>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeReassignControl(token, documentExecutionId, userId, reassignType, requestId);
        });
    }
    public getAllDocumentExecutions(token: string, documentId: string, stageId: string, typeLink: DocumentExecutionTypeLink.DocumentExecutionTypeLink, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<Array<DocumentExecution.DocumentExecution>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocumentExecution.DocumentExecution>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllDocumentExecutions(token, documentId, stageId, typeLink, filter, accessPolicy, requestId);
        });
    }
    public getDocumentExecution(token: string, docExecutionId: string): Promise<DocumentExecution.DocumentExecution> {
        const requestId: number = this.incrementSeqId();
        return new Promise<DocumentExecution.DocumentExecution>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getDocumentExecution(token, docExecutionId, requestId);
        });
    }
    public changeExecutorsForDocument(token: string, docId: string, toAdd: Array<DocumentReassign.DocumentReassign>, toClose: Array<string>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeExecutorsForDocument(token, docId, toAdd, toClose, accessPolicy, requestId);
        });
    }
    public createAttachmentFrom(token: string, documentId: string, cardId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, attCreateInfoList: Array<AttCreateInfo.AttCreateInfo>, processingType: AttachmentProcessingType.AttachmentProcessingType): Promise<Array<Attachment.Attachment>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<Attachment.Attachment>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createAttachmentFrom(token, documentId, cardId, accessPolicy, attCreateInfoList, processingType, requestId);
        });
    }
    public createLoadableAttachment(token: string, documentId: string, fileName: string, totalSize: Int64, countPortions: number, cardId: string, attachmmentId: string, forDraft: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, editMode: core.AttachmentEditMode, extStatus: core.AttachmentExtStatus): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createLoadableAttachment(token, documentId, fileName, totalSize, countPortions, cardId, attachmmentId, forDraft, accessPolicy, editMode, extStatus, requestId);
        });
    }
    public uploadDocumentAttachmentPortions(token: string, attachmentId: string, numberPortion: number, fileContentBytes: Buffer): Promise<Attachment.Attachment> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Attachment.Attachment>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_uploadDocumentAttachmentPortions(token, attachmentId, numberPortion, fileContentBytes, requestId);
        });
    }
    public addPreviewToAttachment(token: string, attachmentId: string, previewContent: Buffer, attachmentType: AttachmentType.AttachmentType, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<Attachment.Attachment> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Attachment.Attachment>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_addPreviewToAttachment(token, attachmentId, previewContent, attachmentType, accessPolicy, requestId);
        });
    }
    public writeHistoryOpenAttachment(token: string, attachmentId: string, attachmentType: AttachmentType.AttachmentType, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_writeHistoryOpenAttachment(token, attachmentId, attachmentType, accessPolicy, requestId);
        });
    }
    public downloadDocumentAttachment(token: string, attachmentId: string, attachmentType: AttachmentType.AttachmentType, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<Buffer> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Buffer>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_downloadDocumentAttachment(token, attachmentId, attachmentType, accessPolicy, requestId);
        });
    }
    public rotatePdfPages(token: string, attachmentId: string, pages: string, angle: number, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_rotatePdfPages(token, attachmentId, pages, angle, accessPolicy, requestId);
        });
    }
    public addAttachmentsToDocument(token: string, documentId: string, attachments: Array<AttCreateInfo.AttCreateInfo>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_addAttachmentsToDocument(token, documentId, attachments, accessPolicy, requestId);
        });
    }
    public removeDocumentAttachment(token: string, attachmentId: string, removeOldVersions: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeDocumentAttachment(token, attachmentId, removeOldVersions, accessPolicy, requestId);
        });
    }
    public markAsWaitForPublish(token: string, attachmentId: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_markAsWaitForPublish(token, attachmentId, requestId);
        });
    }
    public changeAttachmentEditMode(token: string, attachmentId: string, editMode: core.AttachmentEditMode): Promise<Attachment.Attachment> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Attachment.Attachment>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeAttachmentEditMode(token, attachmentId, editMode, requestId);
        });
    }
    public getDocumentAttachments(token: string, documentId: string, latestOnly: boolean, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<Array<Attachment.Attachment>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<Attachment.Attachment>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getDocumentAttachments(token, documentId, latestOnly, filter, accessPolicy, requestId);
        });
    }
    public getDocumentAttachmentById(token: string, attachmentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<Attachment.Attachment> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Attachment.Attachment>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getDocumentAttachmentById(token, attachmentId, accessPolicy, requestId);
        });
    }
    public getAllDocumentAttachmentVersions(token: string, attachmentId: string, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<Array<Attachment.Attachment>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<Attachment.Attachment>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllDocumentAttachmentVersions(token, attachmentId, filter, accessPolicy, requestId);
        });
    }
    public changeAttachmentsVisibility(token: string, toHideList: Array<string>, toShowList: Array<string>): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeAttachmentsVisibility(token, toHideList, toShowList, requestId);
        });
    }
    public createOrUpdateDocumentComment(token: string, documentComment: DocumentComment.DocumentComment, addToComment: string, changeType: ChangeType.ChangeType, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<DocumentComment.DocumentComment> {
        const requestId: number = this.incrementSeqId();
        return new Promise<DocumentComment.DocumentComment>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createOrUpdateDocumentComment(token, documentComment, addToComment, changeType, accessPolicy, requestId);
        });
    }
    public getAllDocumentComments(token: string, documentId: string, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<Array<DocumentComment.DocumentComment>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocumentComment.DocumentComment>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllDocumentComments(token, documentId, filter, accessPolicy, requestId);
        });
    }
    public deleteDocumentComment(token: string, documentCommentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteDocumentComment(token, documentCommentId, accessPolicy, requestId);
        });
    }
    public createOrUpdateDocumentContentHolderLink(token: string, documentId: string, holderLinks: Array<ContentHolderLink.ContentHolderLink>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<Array<ContentHolderShowPlace.ContentHolderShowPlace>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<ContentHolderShowPlace.ContentHolderShowPlace>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createOrUpdateDocumentContentHolderLink(token, documentId, holderLinks, accessPolicy, requestId);
        });
    }
    public documentToArchive(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_documentToArchive(token, documentId, accessPolicy, requestId);
        });
    }
    public getAllResponsibleForDocument(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter): Promise<Set<core.UserOrGroup>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Set<core.UserOrGroup>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllResponsibleForDocument(token, documentId, accessPolicy, filter, requestId);
        });
    }
    public addResponsibleForDocument(token: string, documentId: string, users: Array<core.UserOrGroup>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_addResponsibleForDocument(token, documentId, users, accessPolicy, requestId);
        });
    }
    public removeResponsibleForDocument(token: string, documentId: string, users: Array<core.UserOrGroup>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeResponsibleForDocument(token, documentId, users, accessPolicy, requestId);
        });
    }
    public getDocHistoryPage(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter): Promise<HistoryPage.HistoryPage> {
        const requestId: number = this.incrementSeqId();
        return new Promise<HistoryPage.HistoryPage>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getDocHistoryPage(token, documentId, accessPolicy, filter, requestId);
        });
    }
    public getAllNews(token: string, filter: core.KazFilter): Promise<Array<core.News>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<core.News>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllNews(token, filter, requestId);
        });
    }
    public getTasksByDate(token: string, date: Int64): Promise<Map<TodayTaskType.TodayTaskType, number>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Map<TodayTaskType.TodayTaskType, number>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getTasksByDate(token, date, requestId);
        });
    }
    public generateDocumentNumber(token: string, documentId: string, docNumber: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_generateDocumentNumber(token, documentId, docNumber, accessPolicy, requestId);
        });
    }
    public setDocumentViewed(token: string, documentId: string, viewed: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setDocumentViewed(token, documentId, viewed, accessPolicy, requestId);
        });
    }
    public getAllDocumentRelations(token: string, documentId: string, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<Array<DocumentRelation.DocumentRelation>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocumentRelation.DocumentRelation>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllDocumentRelations(token, documentId, filter, accessPolicy, requestId);
        });
    }
    public changeRelations(token: string, toCreate: Array<DocumentRelation.DocumentRelation>, toRemove: Array<string>): Promise<Array<DocumentRelation.DocumentRelation>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocumentRelation.DocumentRelation>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeRelations(token, toCreate, toRemove, requestId);
        });
    }
    public changeSubStatus(token: string, documentId: string, subStatus: DocPatternStageSubStatus.DocPatternStageSubStatus, comment: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeSubStatus(token, documentId, subStatus, comment, accessPolicy, requestId);
        });
    }
    public revertSubStatus(token: string, documentId: string, subStatus: DocPatternStageSubStatus.DocPatternStageSubStatus, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_revertSubStatus(token, documentId, subStatus, accessPolicy, requestId);
        });
    }
    public increaseDeadlineForDocumentOrDocumentExecution(token: string, documentId: string, documentExecution: string, deadlineTime: Int64, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_increaseDeadlineForDocumentOrDocumentExecution(token, documentId, documentExecution, deadlineTime, accessPolicy, requestId);
        });
    }
    public addAdditionalConfirmers(token: string, cardId: string, users: Array<string>, deadlineDate: Int64, comment: string, requireMyParticipation: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_addAdditionalConfirmers(token, cardId, users, deadlineDate, comment, requireMyParticipation, accessPolicy, requestId);
        });
    }
    public setAdditionalDecision(token: string, userDecision: Map<string, string>, cardId: string, comment: string, returnToParentStage: boolean, signature: string): Promise<Document.Document> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Document.Document>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setAdditionalDecision(token, userDecision, cardId, comment, returnToParentStage, signature, requestId);
        });
    }
    public setAdditionalDecisionUsingServerKeyStorage(token: string, userDecision: Map<string, string>, cardId: string, comment: string, returnToParentStage: boolean, pKeyId: string, password: string): Promise<Document.Document> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Document.Document>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setAdditionalDecisionUsingServerKeyStorage(token, userDecision, cardId, comment, returnToParentStage, pKeyId, password, requestId);
        });
    }
    public setAdditionalDecisionExt(token: string, userMap: Map<string, string>, cardId: string, comment: string, returnToParentStage: boolean, signatures: Array<string>): Promise<Document.Document> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Document.Document>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setAdditionalDecisionExt(token, userMap, cardId, comment, returnToParentStage, signatures, requestId);
        });
    }
    public revokeDecision(token: string, documentReassign: Array<DocumentReassign.DocumentReassign>, cardId: string, comment: string): Promise<Document.Document> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Document.Document>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_revokeDecision(token, documentReassign, cardId, comment, requestId);
        });
    }
    public markDecisionAsRemoved(token: string, documentId: string, cardId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<DocumentExecution.DocumentExecution> {
        const requestId: number = this.incrementSeqId();
        return new Promise<DocumentExecution.DocumentExecution>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_markDecisionAsRemoved(token, documentId, cardId, accessPolicy, requestId);
        });
    }
    public getAllOpenDocumentExecutionsStatistic(token: string, userId: string): Promise<Map<DocumentExecutionStatisticType.DocumentExecutionStatisticType, number>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Map<DocumentExecutionStatisticType.DocumentExecutionStatisticType, number>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllOpenDocumentExecutionsStatistic(token, userId, requestId);
        });
    }
    public changeControlForDocument(token: string, documentId: string, control: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeControlForDocument(token, documentId, control, accessPolicy, requestId);
        });
    }
    public addTagsToDocument(token: string, docId: string, tags: Array<string>): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_addTagsToDocument(token, docId, tags, requestId);
        });
    }
    public removeTagsToDocument(token: string, docId: string, tags: Array<string>): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeTagsToDocument(token, docId, tags, requestId);
        });
    }
    public addExecutorsToStage(token: string, docId: string, documentReassign: Array<DocumentReassign.DocumentReassign>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<Array<DocumentExecution.DocumentExecution>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocumentExecution.DocumentExecution>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_addExecutorsToStage(token, docId, documentReassign, accessPolicy, requestId);
        });
    }
    public getCountDocsByFilterNoPermission(token: string, patternGroupId: string, filter: core.KazFilter): Promise<Int64> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Int64>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getCountDocsByFilterNoPermission(token, patternGroupId, filter, requestId);
        });
    }
    public getTinyDocsByFilterNoPermission(token: string, filter: core.KazFilter): Promise<Array<Document.Document>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<Document.Document>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getTinyDocsByFilterNoPermission(token, filter, requestId);
        });
    }
    public changeRegistrationInfoForDocument(token: string, documentId: string, newRegistrationDate: Int64, newRegistrationNumber: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeRegistrationInfoForDocument(token, documentId, newRegistrationDate, newRegistrationNumber, accessPolicy, requestId);
        });
    }
    public createChatForDocument(token: string, documentId: string): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createChatForDocument(token, documentId, requestId);
        });
    }
    public getDocumentExtShareList(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter): Promise<Array<DocumentExtShare.DocumentExtShare>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocumentExtShare.DocumentExtShare>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getDocumentExtShareList(token, documentId, accessPolicy, filter, requestId);
        });
    }
    public changeDocumentExtShare(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, toAdd: Array<DocumentExtShare.DocumentExtShare>, toRemove: Array<string>): Promise<Array<DocumentExtShare.DocumentExtShare>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocumentExtShare.DocumentExtShare>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeDocumentExtShare(token, documentId, accessPolicy, toAdd, toRemove, requestId);
        });
    }
    public changeAttachmentExtStatus(token: string, statusMap: Map<string, core.AttachmentExtStatus>): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeAttachmentExtStatus(token, statusMap, requestId);
        });
    }
    public remindDocumentExecutor(token: string, cardId: string, comment: string, policy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_remindDocumentExecutor(token, cardId, comment, policy, requestId);
        });
    }
    public updateReassignResolution(token: string, cardId: string, resolution: string, policy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_updateReassignResolution(token, cardId, resolution, policy, requestId);
        });
    }
    public updateSubStatusComment(token: string, docCommentId: string, comment: string, policy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_updateSubStatusComment(token, docCommentId, comment, policy, requestId);
        });
    }
    public removeSubStatusComment(token: string, docCommentId: string, policy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeSubStatusComment(token, docCommentId, policy, requestId);
        });
    }
    public changeDocumentType(token: string, docId: string, startStageId: string, stages: Array<DocumentPatternStage.DocumentPatternStage>, contentItems: Array<ContentItem.ContentItem>, roles: Array<PatternProcessRole.PatternProcessRole>, patternVariables: Array<PatternVariable.PatternVariable>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, newRegNumber: string, patternId: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeDocumentType(token, docId, startStageId, stages, contentItems, roles, patternVariables, accessPolicy, newRegNumber, patternId, requestId);
        });
    }
    public getDocumentRelationModel(token: string, docId: string, filter: core.KazFilter): Promise<DocumentRelationModel.DocumentRelationModel> {
        const requestId: number = this.incrementSeqId();
        return new Promise<DocumentRelationModel.DocumentRelationModel>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getDocumentRelationModel(token, docId, filter, requestId);
        });
    }
    public getNewConvertedAttachmentVersion(token: string, prevAttId: string): Promise<Attachment.Attachment> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Attachment.Attachment>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getNewConvertedAttachmentVersion(token, prevAttId, requestId);
        });
    }
    public exportAsXML(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, allowedAttachmentFileExt: string, allowedAttachmentType: string): Promise<Buffer> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Buffer>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_exportAsXML(token, documentId, accessPolicy, allowedAttachmentFileExt, allowedAttachmentType, requestId);
        });
    }
    public exportAsXMLv2(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, allowedAttachmentFileExt: string, allowedAttachmentType: string): Promise<Buffer> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Buffer>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_exportAsXMLv2(token, documentId, accessPolicy, allowedAttachmentFileExt, allowedAttachmentType, requestId);
        });
    }
    public importFromXML(token: string, xml: Buffer): Promise<Document.Document> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Document.Document>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_importFromXML(token, xml, requestId);
        });
    }
    public getDocContentItemsForChangeType(token: string, documentId: string): Promise<Array<ContentItem.ContentItem>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<ContentItem.ContentItem>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getDocContentItemsForChangeType(token, documentId, requestId);
        });
    }
    public downloadDocumentTemplate(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, pdfPostDecorators: Array<core.PDFPostDecorator>): Promise<Buffer> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Buffer>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_downloadDocumentTemplate(token, documentId, accessPolicy, pdfPostDecorators, requestId);
        });
    }
    public getAllDocumentExecutionsByFilter(token: string, documentId: string, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<Array<DocumentExecution.DocumentExecution>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocumentExecution.DocumentExecution>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllDocumentExecutionsByFilter(token, documentId, filter, accessPolicy, requestId);
        });
    }
    public getDocumentId(token: string, sType: DocumentSearchType.DocumentSearchType, value: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getDocumentId(token, sType, value, accessPolicy, requestId);
        });
    }
    public changeDocumentName(token: string, docId: string, docName: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeDocumentName(token, docId, docName, accessPolicy, requestId);
        });
    }
    public changeAttachmentOrder(token: string, documentId: string, orderMap: Map<string, number>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeAttachmentOrder(token, documentId, orderMap, accessPolicy, requestId);
        });
    }
    public compareAttachmentsURL(token: string, attachmentId1: string, attachmentId2: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_compareAttachmentsURL(token, attachmentId1, attachmentId2, accessPolicy, requestId);
        });
    }
    public getDocumentDecisionXml(token: string, documentId: string, linkId: string, cardId: string, comment: string): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getDocumentDecisionXml(token, documentId, linkId, cardId, comment, requestId);
        });
    }
    public getReassignDocXml(token: string, documentId: string, cardId: string, documentReassign: Array<DocumentReassign.DocumentReassign>): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getReassignDocXml(token, documentId, cardId, documentReassign, requestId);
        });
    }
    public addAnswerers(token: string, cardId: string, users: Array<string>, deadlineDate: Int64, comment: string, requireMyParticipation: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_addAnswerers(token, cardId, users, deadlineDate, comment, requireMyParticipation, accessPolicy, requestId);
        });
    }
    public addAnswerersToLinkedDocument(token: string, docId: string, users: Array<core.UserOrGroup>, deadlineDate: Int64, comment: string, requireMyParticipation: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_addAnswerersToLinkedDocument(token, docId, users, deadlineDate, comment, requireMyParticipation, accessPolicy, requestId);
        });
    }
    public createMeetingQuestion(token: string, document: Document.Document, users: Array<core.UserOrGroup>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, securityClassificationsId: Set<string>, attachments: Array<AttCreateInfo.AttCreateInfo>, docRelations: Array<DocumentRelation.DocumentRelation>, meetingDocumentId: string): Promise<Document.Document> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Document.Document>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createMeetingQuestion(token, document, users, holderLinks, securityClassificationsId, attachments, docRelations, meetingDocumentId, requestId);
        });
    }
    public changeExternalNumber(token: string, documentId: string, externalId: string, externalNumber: string, externalRegDate: Int64, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeExternalNumber(token, documentId, externalId, externalNumber, externalRegDate, accessPolicy, requestId);
        });
    }
    public getAvailableSubStatuses(token: string, documentId: string): Promise<Set<DocPatternStageSubStatus.DocPatternStageSubStatus>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Set<DocPatternStageSubStatus.DocPatternStageSubStatus>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAvailableSubStatuses(token, documentId, requestId);
        });
    }
    public cardWorkingStart(token: string, cardId: string, workComment: string): Promise<DocumentExecution.DocumentExecution> {
        const requestId: number = this.incrementSeqId();
        return new Promise<DocumentExecution.DocumentExecution>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_cardWorkingStart(token, cardId, workComment, requestId);
        });
    }
    public cardWorkingLog(token: string, cardId: string, workComment: string): Promise<DocumentExecution.DocumentExecution> {
        const requestId: number = this.incrementSeqId();
        return new Promise<DocumentExecution.DocumentExecution>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_cardWorkingLog(token, cardId, workComment, requestId);
        });
    }
    public cardWorkingStop(token: string, cardId: string, workComment: string): Promise<DocumentExecution.DocumentExecution> {
        const requestId: number = this.incrementSeqId();
        return new Promise<DocumentExecution.DocumentExecution>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_cardWorkingStop(token, cardId, workComment, requestId);
        });
    }
    public getEnabledSubStatuses(token: string, documentId: string): Promise<Map<SubStatusKey.SubStatusKey, Array<DocPatternStageSubStatus.DocPatternStageSubStatus>>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Map<SubStatusKey.SubStatusKey, Array<DocPatternStageSubStatus.DocPatternStageSubStatus>>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getEnabledSubStatuses(token, documentId, requestId);
        });
    }
    public updateUserTag(token: string, docTag: DocumentTag.DocumentTag, fdelete: boolean): Promise<DocumentTag.DocumentTag> {
        const requestId: number = this.incrementSeqId();
        return new Promise<DocumentTag.DocumentTag>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_updateUserTag(token, docTag, fdelete, requestId);
        });
    }
    public getUserTags(token: string, filter: core.KazFilter): Promise<Array<DocumentTag.DocumentTag>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DocumentTag.DocumentTag>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getUserTags(token, filter, requestId);
        });
    }
    public updateTagOrders(token: string, oredrMap: Map<string, number>): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_updateTagOrders(token, oredrMap, requestId);
        });
    }
    public documentFieldByKey(token: string, documentId: string, key: string, keyType: DocKeyType.DocKeyType): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_documentFieldByKey(token, documentId, key, keyType, requestId);
        });
    }
    public addDecoration(token: string, attachmentId: string, decoratorKeys: Array<string>): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_addDecoration(token, attachmentId, decoratorKeys, requestId);
        });
    }
    public send_calculatePermissions(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("calculatePermissions", thrift.Thrift.MessageType.CALL, requestId);
        const args: CalculatePermissionsArgs = new CalculatePermissionsArgs({ token, documentId, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createOrUpdateDocument(token: string, document: Document.Document, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createOrUpdateDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateOrUpdateDocumentArgs = new CreateOrUpdateDocumentArgs({ token, document, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_updateDocument(token: string, document: Document.Document, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, addedResponsibles: Array<core.UserOrGroup>, removedResponsibles: Array<core.UserOrGroup>, addedSecurityClassificationIds: Array<string>, removedSecurityClassificationIds: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("updateDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: UpdateDocumentArgs = new UpdateDocumentArgs({ token, document, accessPolicy, addedResponsibles, removedResponsibles, addedSecurityClassificationIds, removedSecurityClassificationIds });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createDocument(token: string, document: Document.Document, users: Array<core.UserOrGroup>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, securityClassificationsId: Set<string>, attachments: Array<AttCreateInfo.AttCreateInfo>, docRelations: Array<DocumentRelation.DocumentRelation>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateDocumentArgs = new CreateDocumentArgs({ token, document, users, holderLinks, securityClassificationsId, attachments, docRelations });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createDocumentFromXML(token: string, xmlDoc: Buffer, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createDocumentFromXML", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateDocumentFromXMLArgs = new CreateDocumentFromXMLArgs({ token, xmlDoc });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getDocument(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, decrypt: boolean, executorsPortion: number, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetDocumentArgs = new GetDocumentArgs({ token, documentId, accessPolicy, decrypt, executorsPortion });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllDocuments(token: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllDocuments", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllDocumentsArgs = new GetAllDocumentsArgs({ token, accessPolicy, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getCountAllDocuments(token: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getCountAllDocuments", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetCountAllDocumentsArgs = new GetCountAllDocumentsArgs({ token, accessPolicy, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteDocument(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteDocumentArgs = new DeleteDocumentArgs({ token, documentId, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllPassedStages(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllPassedStages", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllPassedStagesArgs = new GetAllPassedStagesArgs({ token, documentId, accessPolicy, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getExecutionTree(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, iteration: number, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getExecutionTree", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetExecutionTreeArgs = new GetExecutionTreeArgs({ token, documentId, accessPolicy, iteration, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getActiveStages(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getActiveStages", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetActiveStagesArgs = new GetActiveStagesArgs({ token, documentId, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getCountPeoplesWhenRenderedDecision(token: string, documentId: string, stageId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getCountPeoplesWhenRenderedDecision", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetCountPeoplesWhenRenderedDecisionArgs = new GetCountPeoplesWhenRenderedDecisionArgs({ token, documentId, stageId, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setDocumentDecision(token: string, documentId: string, decision: string, documentComment: string, force: boolean, signature: string, cardId: string, attachments: Array<AttCreateInfo.AttCreateInfo>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, addSignToAttachment: Map<string, Array<string>>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setDocumentDecision", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetDocumentDecisionArgs = new SetDocumentDecisionArgs({ token, documentId, decision, documentComment, force, signature, cardId, attachments, holderLinks, accessPolicy, addSignToAttachment });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setDocumentDecisionByLinkId(token: string, documentId: string, linkID: string, cardId: string, documentComment: string, force: boolean, signature: string, pKeyId: string, password: string, attachments: Array<AttCreateInfo.AttCreateInfo>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, addSignToAttachment: Map<string, Array<string>>, attachmentsToSign: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setDocumentDecisionByLinkId", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetDocumentDecisionByLinkIdArgs = new SetDocumentDecisionByLinkIdArgs({ token, documentId, linkID, cardId, documentComment, force, signature, pKeyId, password, attachments, holderLinks, accessPolicy, addSignToAttachment, attachmentsToSign });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setDocumentDecisionUsingServerKeyStorage(token: string, documentId: string, decision: string, documentComment: string, force: boolean, pKeyId: string, password: string, cardId: string, attachments: Array<AttCreateInfo.AttCreateInfo>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, attachmentsToSign: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setDocumentDecisionUsingServerKeyStorage", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetDocumentDecisionUsingServerKeyStorageArgs = new SetDocumentDecisionUsingServerKeyStorageArgs({ token, documentId, decision, documentComment, force, pKeyId, password, cardId, attachments, holderLinks, accessPolicy, attachmentsToSign });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setDocumentDecisionExt(token: string, documentId: string, cardId: string, linkID: string, documentComment: string, force: boolean, attachments: Array<AttCreateInfo.AttCreateInfo>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, addSignToDecision: Array<string>, addSignToAttachment: Map<string, Array<string>>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setDocumentDecisionExt", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetDocumentDecisionExtArgs = new SetDocumentDecisionExtArgs({ token, documentId, cardId, linkID, documentComment, force, attachments, holderLinks, addSignToDecision, addSignToAttachment, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_approveDocumentDecision(token: string, executionId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("approveDocumentDecision", thrift.Thrift.MessageType.CALL, requestId);
        const args: ApproveDocumentDecisionArgs = new ApproveDocumentDecisionArgs({ token, executionId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_shareDocument(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, usersOrGroups: Array<core.UserOrGroup>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("shareDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: ShareDocumentArgs = new ShareDocumentArgs({ token, documentId, accessPolicy, usersOrGroups });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_revokeDocument(token: string, documentId: string, usersOrGroups: Array<core.UserOrGroup>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("revokeDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: RevokeDocumentArgs = new RevokeDocumentArgs({ token, documentId, usersOrGroups, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllDocumentSharings(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllDocumentSharings", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllDocumentSharingsArgs = new GetAllDocumentSharingsArgs({ token, documentId, accessPolicy, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllDocumentReassign(token: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllDocumentReassign", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllDocumentReassignArgs = new GetAllDocumentReassignArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_reassignDocument(token: string, documentId: string, documentReassign: Array<DocumentReassign.DocumentReassign>, cardId: string, signature: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("reassignDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: ReassignDocumentArgs = new ReassignDocumentArgs({ token, documentId, documentReassign, cardId, signature });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_reassignDocumentUsingServerKeyStorage(token: string, documentId: string, documentReassign: Array<DocumentReassign.DocumentReassign>, cardId: string, pKeyId: string, password: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("reassignDocumentUsingServerKeyStorage", thrift.Thrift.MessageType.CALL, requestId);
        const args: ReassignDocumentUsingServerKeyStorageArgs = new ReassignDocumentUsingServerKeyStorageArgs({ token, documentId, documentReassign, cardId, pKeyId, password });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_reassignDocumentExt(token: string, documentId: string, cardId: string, documentReassign: Array<DocumentReassign.DocumentReassign>, addSignToReasign: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("reassignDocumentExt", thrift.Thrift.MessageType.CALL, requestId);
        const args: ReassignDocumentExtArgs = new ReassignDocumentExtArgs({ token, documentId, cardId, documentReassign, addSignToReasign });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_revokeChildCards(token: string, cardId: string, deleteCard: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("revokeChildCards", thrift.Thrift.MessageType.CALL, requestId);
        const args: RevokeChildCardsArgs = new RevokeChildCardsArgs({ token, cardId, deleteCard, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createOrUpdateAutomaticDocumentReassign(token: string, documentReassign: DocumentReassign.DocumentReassign, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createOrUpdateAutomaticDocumentReassign", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateOrUpdateAutomaticDocumentReassignArgs = new CreateOrUpdateAutomaticDocumentReassignArgs({ token, documentReassign });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteAutomaticDocumentReassign(token: string, documentReassignId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteAutomaticDocumentReassign", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteAutomaticDocumentReassignArgs = new DeleteAutomaticDocumentReassignArgs({ token, documentReassignId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeReassignControl(token: string, documentExecutionId: string, userId: string, reassignType: ExecutionReassignType.ExecutionReassignType, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeReassignControl", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeReassignControlArgs = new ChangeReassignControlArgs({ token, documentExecutionId, userId, reassignType });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllDocumentExecutions(token: string, documentId: string, stageId: string, typeLink: DocumentExecutionTypeLink.DocumentExecutionTypeLink, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllDocumentExecutions", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllDocumentExecutionsArgs = new GetAllDocumentExecutionsArgs({ token, documentId, stageId, typeLink, filter, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getDocumentExecution(token: string, docExecutionId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getDocumentExecution", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetDocumentExecutionArgs = new GetDocumentExecutionArgs({ token, docExecutionId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeExecutorsForDocument(token: string, docId: string, toAdd: Array<DocumentReassign.DocumentReassign>, toClose: Array<string>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeExecutorsForDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeExecutorsForDocumentArgs = new ChangeExecutorsForDocumentArgs({ token, docId, toAdd, toClose, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createAttachmentFrom(token: string, documentId: string, cardId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, attCreateInfoList: Array<AttCreateInfo.AttCreateInfo>, processingType: AttachmentProcessingType.AttachmentProcessingType, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createAttachmentFrom", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateAttachmentFromArgs = new CreateAttachmentFromArgs({ token, documentId, cardId, accessPolicy, attCreateInfoList, processingType });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createLoadableAttachment(token: string, documentId: string, fileName: string, totalSize: Int64, countPortions: number, cardId: string, attachmmentId: string, forDraft: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, editMode: core.AttachmentEditMode, extStatus: core.AttachmentExtStatus, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createLoadableAttachment", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateLoadableAttachmentArgs = new CreateLoadableAttachmentArgs({ token, documentId, fileName, totalSize, countPortions, cardId, attachmmentId, forDraft, accessPolicy, editMode, extStatus });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_uploadDocumentAttachmentPortions(token: string, attachmentId: string, numberPortion: number, fileContentBytes: Buffer, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("uploadDocumentAttachmentPortions", thrift.Thrift.MessageType.CALL, requestId);
        const args: UploadDocumentAttachmentPortionsArgs = new UploadDocumentAttachmentPortionsArgs({ token, attachmentId, numberPortion, fileContentBytes });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_addPreviewToAttachment(token: string, attachmentId: string, previewContent: Buffer, attachmentType: AttachmentType.AttachmentType, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("addPreviewToAttachment", thrift.Thrift.MessageType.CALL, requestId);
        const args: AddPreviewToAttachmentArgs = new AddPreviewToAttachmentArgs({ token, attachmentId, previewContent, attachmentType, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_writeHistoryOpenAttachment(token: string, attachmentId: string, attachmentType: AttachmentType.AttachmentType, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("writeHistoryOpenAttachment", thrift.Thrift.MessageType.CALL, requestId);
        const args: WriteHistoryOpenAttachmentArgs = new WriteHistoryOpenAttachmentArgs({ token, attachmentId, attachmentType, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_downloadDocumentAttachment(token: string, attachmentId: string, attachmentType: AttachmentType.AttachmentType, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("downloadDocumentAttachment", thrift.Thrift.MessageType.CALL, requestId);
        const args: DownloadDocumentAttachmentArgs = new DownloadDocumentAttachmentArgs({ token, attachmentId, attachmentType, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_rotatePdfPages(token: string, attachmentId: string, pages: string, angle: number, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("rotatePdfPages", thrift.Thrift.MessageType.CALL, requestId);
        const args: RotatePdfPagesArgs = new RotatePdfPagesArgs({ token, attachmentId, pages, angle, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_addAttachmentsToDocument(token: string, documentId: string, attachments: Array<AttCreateInfo.AttCreateInfo>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("addAttachmentsToDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: AddAttachmentsToDocumentArgs = new AddAttachmentsToDocumentArgs({ token, documentId, attachments, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeDocumentAttachment(token: string, attachmentId: string, removeOldVersions: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeDocumentAttachment", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveDocumentAttachmentArgs = new RemoveDocumentAttachmentArgs({ token, attachmentId, removeOldVersions, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_markAsWaitForPublish(token: string, attachmentId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("markAsWaitForPublish", thrift.Thrift.MessageType.CALL, requestId);
        const args: MarkAsWaitForPublishArgs = new MarkAsWaitForPublishArgs({ token, attachmentId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeAttachmentEditMode(token: string, attachmentId: string, editMode: core.AttachmentEditMode, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeAttachmentEditMode", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeAttachmentEditModeArgs = new ChangeAttachmentEditModeArgs({ token, attachmentId, editMode });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getDocumentAttachments(token: string, documentId: string, latestOnly: boolean, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getDocumentAttachments", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetDocumentAttachmentsArgs = new GetDocumentAttachmentsArgs({ token, documentId, latestOnly, filter, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getDocumentAttachmentById(token: string, attachmentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getDocumentAttachmentById", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetDocumentAttachmentByIdArgs = new GetDocumentAttachmentByIdArgs({ token, attachmentId, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllDocumentAttachmentVersions(token: string, attachmentId: string, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllDocumentAttachmentVersions", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllDocumentAttachmentVersionsArgs = new GetAllDocumentAttachmentVersionsArgs({ token, attachmentId, filter, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeAttachmentsVisibility(token: string, toHideList: Array<string>, toShowList: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeAttachmentsVisibility", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeAttachmentsVisibilityArgs = new ChangeAttachmentsVisibilityArgs({ token, toHideList, toShowList });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createOrUpdateDocumentComment(token: string, documentComment: DocumentComment.DocumentComment, addToComment: string, changeType: ChangeType.ChangeType, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createOrUpdateDocumentComment", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateOrUpdateDocumentCommentArgs = new CreateOrUpdateDocumentCommentArgs({ token, documentComment, addToComment, changeType, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllDocumentComments(token: string, documentId: string, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllDocumentComments", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllDocumentCommentsArgs = new GetAllDocumentCommentsArgs({ token, documentId, filter, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteDocumentComment(token: string, documentCommentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteDocumentComment", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteDocumentCommentArgs = new DeleteDocumentCommentArgs({ token, documentCommentId, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createOrUpdateDocumentContentHolderLink(token: string, documentId: string, holderLinks: Array<ContentHolderLink.ContentHolderLink>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createOrUpdateDocumentContentHolderLink", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateOrUpdateDocumentContentHolderLinkArgs = new CreateOrUpdateDocumentContentHolderLinkArgs({ token, documentId, holderLinks, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_documentToArchive(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("documentToArchive", thrift.Thrift.MessageType.CALL, requestId);
        const args: DocumentToArchiveArgs = new DocumentToArchiveArgs({ token, documentId, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllResponsibleForDocument(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllResponsibleForDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllResponsibleForDocumentArgs = new GetAllResponsibleForDocumentArgs({ token, documentId, accessPolicy, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_addResponsibleForDocument(token: string, documentId: string, users: Array<core.UserOrGroup>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("addResponsibleForDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: AddResponsibleForDocumentArgs = new AddResponsibleForDocumentArgs({ token, documentId, users, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeResponsibleForDocument(token: string, documentId: string, users: Array<core.UserOrGroup>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeResponsibleForDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveResponsibleForDocumentArgs = new RemoveResponsibleForDocumentArgs({ token, documentId, users, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getDocHistoryPage(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getDocHistoryPage", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetDocHistoryPageArgs = new GetDocHistoryPageArgs({ token, documentId, accessPolicy, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllNews(token: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllNews", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllNewsArgs = new GetAllNewsArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getTasksByDate(token: string, date: Int64, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getTasksByDate", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetTasksByDateArgs = new GetTasksByDateArgs({ token, date });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_generateDocumentNumber(token: string, documentId: string, docNumber: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("generateDocumentNumber", thrift.Thrift.MessageType.CALL, requestId);
        const args: GenerateDocumentNumberArgs = new GenerateDocumentNumberArgs({ token, documentId, docNumber, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setDocumentViewed(token: string, documentId: string, viewed: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setDocumentViewed", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetDocumentViewedArgs = new SetDocumentViewedArgs({ token, documentId, viewed, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllDocumentRelations(token: string, documentId: string, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllDocumentRelations", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllDocumentRelationsArgs = new GetAllDocumentRelationsArgs({ token, documentId, filter, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeRelations(token: string, toCreate: Array<DocumentRelation.DocumentRelation>, toRemove: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeRelations", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeRelationsArgs = new ChangeRelationsArgs({ token, toCreate, toRemove });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeSubStatus(token: string, documentId: string, subStatus: DocPatternStageSubStatus.DocPatternStageSubStatus, comment: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeSubStatus", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeSubStatusArgs = new ChangeSubStatusArgs({ token, documentId, subStatus, comment, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_revertSubStatus(token: string, documentId: string, subStatus: DocPatternStageSubStatus.DocPatternStageSubStatus, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("revertSubStatus", thrift.Thrift.MessageType.CALL, requestId);
        const args: RevertSubStatusArgs = new RevertSubStatusArgs({ token, documentId, subStatus, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_increaseDeadlineForDocumentOrDocumentExecution(token: string, documentId: string, documentExecution: string, deadlineTime: Int64, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("increaseDeadlineForDocumentOrDocumentExecution", thrift.Thrift.MessageType.CALL, requestId);
        const args: IncreaseDeadlineForDocumentOrDocumentExecutionArgs = new IncreaseDeadlineForDocumentOrDocumentExecutionArgs({ token, documentId, documentExecution, deadlineTime, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_addAdditionalConfirmers(token: string, cardId: string, users: Array<string>, deadlineDate: Int64, comment: string, requireMyParticipation: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("addAdditionalConfirmers", thrift.Thrift.MessageType.CALL, requestId);
        const args: AddAdditionalConfirmersArgs = new AddAdditionalConfirmersArgs({ token, cardId, users, deadlineDate, comment, requireMyParticipation, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setAdditionalDecision(token: string, userDecision: Map<string, string>, cardId: string, comment: string, returnToParentStage: boolean, signature: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setAdditionalDecision", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetAdditionalDecisionArgs = new SetAdditionalDecisionArgs({ token, userDecision, cardId, comment, returnToParentStage, signature });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setAdditionalDecisionUsingServerKeyStorage(token: string, userDecision: Map<string, string>, cardId: string, comment: string, returnToParentStage: boolean, pKeyId: string, password: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setAdditionalDecisionUsingServerKeyStorage", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetAdditionalDecisionUsingServerKeyStorageArgs = new SetAdditionalDecisionUsingServerKeyStorageArgs({ token, userDecision, cardId, comment, returnToParentStage, pKeyId, password });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setAdditionalDecisionExt(token: string, userMap: Map<string, string>, cardId: string, comment: string, returnToParentStage: boolean, signatures: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setAdditionalDecisionExt", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetAdditionalDecisionExtArgs = new SetAdditionalDecisionExtArgs({ token, userMap, cardId, comment, returnToParentStage, signatures });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_revokeDecision(token: string, documentReassign: Array<DocumentReassign.DocumentReassign>, cardId: string, comment: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("revokeDecision", thrift.Thrift.MessageType.CALL, requestId);
        const args: RevokeDecisionArgs = new RevokeDecisionArgs({ token, documentReassign, cardId, comment });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_markDecisionAsRemoved(token: string, documentId: string, cardId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("markDecisionAsRemoved", thrift.Thrift.MessageType.CALL, requestId);
        const args: MarkDecisionAsRemovedArgs = new MarkDecisionAsRemovedArgs({ token, documentId, cardId, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllOpenDocumentExecutionsStatistic(token: string, userId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllOpenDocumentExecutionsStatistic", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllOpenDocumentExecutionsStatisticArgs = new GetAllOpenDocumentExecutionsStatisticArgs({ token, userId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeControlForDocument(token: string, documentId: string, control: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeControlForDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeControlForDocumentArgs = new ChangeControlForDocumentArgs({ token, documentId, control, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_addTagsToDocument(token: string, docId: string, tags: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("addTagsToDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: AddTagsToDocumentArgs = new AddTagsToDocumentArgs({ token, docId, tags });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeTagsToDocument(token: string, docId: string, tags: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeTagsToDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveTagsToDocumentArgs = new RemoveTagsToDocumentArgs({ token, docId, tags });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_addExecutorsToStage(token: string, docId: string, documentReassign: Array<DocumentReassign.DocumentReassign>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("addExecutorsToStage", thrift.Thrift.MessageType.CALL, requestId);
        const args: AddExecutorsToStageArgs = new AddExecutorsToStageArgs({ token, docId, documentReassign, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getCountDocsByFilterNoPermission(token: string, patternGroupId: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getCountDocsByFilterNoPermission", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetCountDocsByFilterNoPermissionArgs = new GetCountDocsByFilterNoPermissionArgs({ token, patternGroupId, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getTinyDocsByFilterNoPermission(token: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getTinyDocsByFilterNoPermission", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetTinyDocsByFilterNoPermissionArgs = new GetTinyDocsByFilterNoPermissionArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeRegistrationInfoForDocument(token: string, documentId: string, newRegistrationDate: Int64, newRegistrationNumber: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeRegistrationInfoForDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeRegistrationInfoForDocumentArgs = new ChangeRegistrationInfoForDocumentArgs({ token, documentId, newRegistrationDate, newRegistrationNumber, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createChatForDocument(token: string, documentId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createChatForDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateChatForDocumentArgs = new CreateChatForDocumentArgs({ token, documentId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getDocumentExtShareList(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getDocumentExtShareList", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetDocumentExtShareListArgs = new GetDocumentExtShareListArgs({ token, documentId, accessPolicy, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeDocumentExtShare(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, toAdd: Array<DocumentExtShare.DocumentExtShare>, toRemove: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeDocumentExtShare", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeDocumentExtShareArgs = new ChangeDocumentExtShareArgs({ token, documentId, accessPolicy, toAdd, toRemove });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeAttachmentExtStatus(token: string, statusMap: Map<string, core.AttachmentExtStatus>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeAttachmentExtStatus", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeAttachmentExtStatusArgs = new ChangeAttachmentExtStatusArgs({ token, statusMap });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_remindDocumentExecutor(token: string, cardId: string, comment: string, policy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("remindDocumentExecutor", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemindDocumentExecutorArgs = new RemindDocumentExecutorArgs({ token, cardId, comment, policy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_updateReassignResolution(token: string, cardId: string, resolution: string, policy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("updateReassignResolution", thrift.Thrift.MessageType.CALL, requestId);
        const args: UpdateReassignResolutionArgs = new UpdateReassignResolutionArgs({ token, cardId, resolution, policy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_updateSubStatusComment(token: string, docCommentId: string, comment: string, policy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("updateSubStatusComment", thrift.Thrift.MessageType.CALL, requestId);
        const args: UpdateSubStatusCommentArgs = new UpdateSubStatusCommentArgs({ token, docCommentId, comment, policy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeSubStatusComment(token: string, docCommentId: string, policy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeSubStatusComment", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveSubStatusCommentArgs = new RemoveSubStatusCommentArgs({ token, docCommentId, policy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeDocumentType(token: string, docId: string, startStageId: string, stages: Array<DocumentPatternStage.DocumentPatternStage>, contentItems: Array<ContentItem.ContentItem>, roles: Array<PatternProcessRole.PatternProcessRole>, patternVariables: Array<PatternVariable.PatternVariable>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, newRegNumber: string, patternId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeDocumentType", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeDocumentTypeArgs = new ChangeDocumentTypeArgs({ token, docId, startStageId, stages, contentItems, roles, patternVariables, accessPolicy, newRegNumber, patternId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getDocumentRelationModel(token: string, docId: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getDocumentRelationModel", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetDocumentRelationModelArgs = new GetDocumentRelationModelArgs({ token, docId, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getNewConvertedAttachmentVersion(token: string, prevAttId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getNewConvertedAttachmentVersion", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetNewConvertedAttachmentVersionArgs = new GetNewConvertedAttachmentVersionArgs({ token, prevAttId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_exportAsXML(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, allowedAttachmentFileExt: string, allowedAttachmentType: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("exportAsXML", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExportAsXMLArgs = new ExportAsXMLArgs({ token, documentId, accessPolicy, allowedAttachmentFileExt, allowedAttachmentType });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_exportAsXMLv2(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, allowedAttachmentFileExt: string, allowedAttachmentType: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("exportAsXMLv2", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExportAsXMLv2Args = new ExportAsXMLv2Args({ token, documentId, accessPolicy, allowedAttachmentFileExt, allowedAttachmentType });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_importFromXML(token: string, xml: Buffer, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("importFromXML", thrift.Thrift.MessageType.CALL, requestId);
        const args: ImportFromXMLArgs = new ImportFromXMLArgs({ token, xml });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getDocContentItemsForChangeType(token: string, documentId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getDocContentItemsForChangeType", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetDocContentItemsForChangeTypeArgs = new GetDocContentItemsForChangeTypeArgs({ token, documentId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_downloadDocumentTemplate(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, pdfPostDecorators: Array<core.PDFPostDecorator>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("downloadDocumentTemplate", thrift.Thrift.MessageType.CALL, requestId);
        const args: DownloadDocumentTemplateArgs = new DownloadDocumentTemplateArgs({ token, documentId, accessPolicy, pdfPostDecorators });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllDocumentExecutionsByFilter(token: string, documentId: string, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllDocumentExecutionsByFilter", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllDocumentExecutionsByFilterArgs = new GetAllDocumentExecutionsByFilterArgs({ token, documentId, filter, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getDocumentId(token: string, sType: DocumentSearchType.DocumentSearchType, value: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getDocumentId", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetDocumentIdArgs = new GetDocumentIdArgs({ token, sType, value, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeDocumentName(token: string, docId: string, docName: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeDocumentName", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeDocumentNameArgs = new ChangeDocumentNameArgs({ token, docId, docName, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeAttachmentOrder(token: string, documentId: string, orderMap: Map<string, number>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeAttachmentOrder", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeAttachmentOrderArgs = new ChangeAttachmentOrderArgs({ token, documentId, orderMap, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_compareAttachmentsURL(token: string, attachmentId1: string, attachmentId2: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("compareAttachmentsURL", thrift.Thrift.MessageType.CALL, requestId);
        const args: CompareAttachmentsURLArgs = new CompareAttachmentsURLArgs({ token, attachmentId1, attachmentId2, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getDocumentDecisionXml(token: string, documentId: string, linkId: string, cardId: string, comment: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getDocumentDecisionXml", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetDocumentDecisionXmlArgs = new GetDocumentDecisionXmlArgs({ token, documentId, linkId, cardId, comment });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getReassignDocXml(token: string, documentId: string, cardId: string, documentReassign: Array<DocumentReassign.DocumentReassign>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getReassignDocXml", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetReassignDocXmlArgs = new GetReassignDocXmlArgs({ token, documentId, cardId, documentReassign });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_addAnswerers(token: string, cardId: string, users: Array<string>, deadlineDate: Int64, comment: string, requireMyParticipation: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("addAnswerers", thrift.Thrift.MessageType.CALL, requestId);
        const args: AddAnswerersArgs = new AddAnswerersArgs({ token, cardId, users, deadlineDate, comment, requireMyParticipation, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_addAnswerersToLinkedDocument(token: string, docId: string, users: Array<core.UserOrGroup>, deadlineDate: Int64, comment: string, requireMyParticipation: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("addAnswerersToLinkedDocument", thrift.Thrift.MessageType.CALL, requestId);
        const args: AddAnswerersToLinkedDocumentArgs = new AddAnswerersToLinkedDocumentArgs({ token, docId, users, deadlineDate, comment, requireMyParticipation, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createMeetingQuestion(token: string, document: Document.Document, users: Array<core.UserOrGroup>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, securityClassificationsId: Set<string>, attachments: Array<AttCreateInfo.AttCreateInfo>, docRelations: Array<DocumentRelation.DocumentRelation>, meetingDocumentId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createMeetingQuestion", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateMeetingQuestionArgs = new CreateMeetingQuestionArgs({ token, document, users, holderLinks, securityClassificationsId, attachments, docRelations, meetingDocumentId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeExternalNumber(token: string, documentId: string, externalId: string, externalNumber: string, externalRegDate: Int64, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeExternalNumber", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeExternalNumberArgs = new ChangeExternalNumberArgs({ token, documentId, externalId, externalNumber, externalRegDate, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAvailableSubStatuses(token: string, documentId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAvailableSubStatuses", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAvailableSubStatusesArgs = new GetAvailableSubStatusesArgs({ token, documentId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_cardWorkingStart(token: string, cardId: string, workComment: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("cardWorkingStart", thrift.Thrift.MessageType.CALL, requestId);
        const args: CardWorkingStartArgs = new CardWorkingStartArgs({ token, cardId, workComment });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_cardWorkingLog(token: string, cardId: string, workComment: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("cardWorkingLog", thrift.Thrift.MessageType.CALL, requestId);
        const args: CardWorkingLogArgs = new CardWorkingLogArgs({ token, cardId, workComment });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_cardWorkingStop(token: string, cardId: string, workComment: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("cardWorkingStop", thrift.Thrift.MessageType.CALL, requestId);
        const args: CardWorkingStopArgs = new CardWorkingStopArgs({ token, cardId, workComment });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getEnabledSubStatuses(token: string, documentId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getEnabledSubStatuses", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetEnabledSubStatusesArgs = new GetEnabledSubStatusesArgs({ token, documentId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_updateUserTag(token: string, docTag: DocumentTag.DocumentTag, fdelete: boolean, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("updateUserTag", thrift.Thrift.MessageType.CALL, requestId);
        const args: UpdateUserTagArgs = new UpdateUserTagArgs({ token, docTag, fdelete });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getUserTags(token: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getUserTags", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetUserTagsArgs = new GetUserTagsArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_updateTagOrders(token: string, oredrMap: Map<string, number>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("updateTagOrders", thrift.Thrift.MessageType.CALL, requestId);
        const args: UpdateTagOrdersArgs = new UpdateTagOrdersArgs({ token, oredrMap });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_documentFieldByKey(token: string, documentId: string, key: string, keyType: DocKeyType.DocKeyType, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("documentFieldByKey", thrift.Thrift.MessageType.CALL, requestId);
        const args: DocumentFieldByKeyArgs = new DocumentFieldByKeyArgs({ token, documentId, key, keyType });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_addDecoration(token: string, attachmentId: string, decoratorKeys: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("addDecoration", thrift.Thrift.MessageType.CALL, requestId);
        const args: AddDecorationArgs = new AddDecorationArgs({ token, attachmentId, decoratorKeys });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public recv_calculatePermissions(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CalculatePermissionsResult = CalculatePermissionsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "calculatePermissions failed: unknown result"));
                }
            }
        }
    }
    public recv_createOrUpdateDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateOrUpdateDocumentResult = CreateOrUpdateDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createOrUpdateDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_updateDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: UpdateDocumentResult = UpdateDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "updateDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_createDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateDocumentResult = CreateDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_createDocumentFromXML(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateDocumentFromXMLResult = CreateDocumentFromXMLResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createDocumentFromXML failed: unknown result"));
                }
            }
        }
    }
    public recv_getDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetDocumentResult = GetDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllDocuments(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllDocumentsResult = GetAllDocumentsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllDocuments failed: unknown result"));
                }
            }
        }
    }
    public recv_getCountAllDocuments(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetCountAllDocumentsResult = GetCountAllDocumentsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getCountAllDocuments failed: unknown result"));
                }
            }
        }
    }
    public recv_deleteDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteDocumentResult = DeleteDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllPassedStages(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllPassedStagesResult = GetAllPassedStagesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllPassedStages failed: unknown result"));
                }
            }
        }
    }
    public recv_getExecutionTree(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetExecutionTreeResult = GetExecutionTreeResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getExecutionTree failed: unknown result"));
                }
            }
        }
    }
    public recv_getActiveStages(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetActiveStagesResult = GetActiveStagesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getActiveStages failed: unknown result"));
                }
            }
        }
    }
    public recv_getCountPeoplesWhenRenderedDecision(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetCountPeoplesWhenRenderedDecisionResult = GetCountPeoplesWhenRenderedDecisionResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getCountPeoplesWhenRenderedDecision failed: unknown result"));
                }
            }
        }
    }
    public recv_setDocumentDecision(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetDocumentDecisionResult = SetDocumentDecisionResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setDocumentDecision failed: unknown result"));
                }
            }
        }
    }
    public recv_setDocumentDecisionByLinkId(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetDocumentDecisionByLinkIdResult = SetDocumentDecisionByLinkIdResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setDocumentDecisionByLinkId failed: unknown result"));
                }
            }
        }
    }
    public recv_setDocumentDecisionUsingServerKeyStorage(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetDocumentDecisionUsingServerKeyStorageResult = SetDocumentDecisionUsingServerKeyStorageResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setDocumentDecisionUsingServerKeyStorage failed: unknown result"));
                }
            }
        }
    }
    public recv_setDocumentDecisionExt(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetDocumentDecisionExtResult = SetDocumentDecisionExtResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setDocumentDecisionExt failed: unknown result"));
                }
            }
        }
    }
    public recv_approveDocumentDecision(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ApproveDocumentDecisionResult = ApproveDocumentDecisionResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "approveDocumentDecision failed: unknown result"));
                }
            }
        }
    }
    public recv_shareDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ShareDocumentResult = ShareDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "shareDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_revokeDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RevokeDocumentResult = RevokeDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "revokeDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllDocumentSharings(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllDocumentSharingsResult = GetAllDocumentSharingsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllDocumentSharings failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllDocumentReassign(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllDocumentReassignResult = GetAllDocumentReassignResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllDocumentReassign failed: unknown result"));
                }
            }
        }
    }
    public recv_reassignDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ReassignDocumentResult = ReassignDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "reassignDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_reassignDocumentUsingServerKeyStorage(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ReassignDocumentUsingServerKeyStorageResult = ReassignDocumentUsingServerKeyStorageResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "reassignDocumentUsingServerKeyStorage failed: unknown result"));
                }
            }
        }
    }
    public recv_reassignDocumentExt(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ReassignDocumentExtResult = ReassignDocumentExtResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "reassignDocumentExt failed: unknown result"));
                }
            }
        }
    }
    public recv_revokeChildCards(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RevokeChildCardsResult = RevokeChildCardsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "revokeChildCards failed: unknown result"));
                }
            }
        }
    }
    public recv_createOrUpdateAutomaticDocumentReassign(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateOrUpdateAutomaticDocumentReassignResult = CreateOrUpdateAutomaticDocumentReassignResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createOrUpdateAutomaticDocumentReassign failed: unknown result"));
                }
            }
        }
    }
    public recv_deleteAutomaticDocumentReassign(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteAutomaticDocumentReassignResult = DeleteAutomaticDocumentReassignResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteAutomaticDocumentReassign failed: unknown result"));
                }
            }
        }
    }
    public recv_changeReassignControl(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeReassignControlResult = ChangeReassignControlResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeReassignControl failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllDocumentExecutions(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllDocumentExecutionsResult = GetAllDocumentExecutionsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllDocumentExecutions failed: unknown result"));
                }
            }
        }
    }
    public recv_getDocumentExecution(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetDocumentExecutionResult = GetDocumentExecutionResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getDocumentExecution failed: unknown result"));
                }
            }
        }
    }
    public recv_changeExecutorsForDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeExecutorsForDocumentResult = ChangeExecutorsForDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeExecutorsForDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_createAttachmentFrom(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateAttachmentFromResult = CreateAttachmentFromResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createAttachmentFrom failed: unknown result"));
                }
            }
        }
    }
    public recv_createLoadableAttachment(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateLoadableAttachmentResult = CreateLoadableAttachmentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createLoadableAttachment failed: unknown result"));
                }
            }
        }
    }
    public recv_uploadDocumentAttachmentPortions(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: UploadDocumentAttachmentPortionsResult = UploadDocumentAttachmentPortionsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "uploadDocumentAttachmentPortions failed: unknown result"));
                }
            }
        }
    }
    public recv_addPreviewToAttachment(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AddPreviewToAttachmentResult = AddPreviewToAttachmentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addPreviewToAttachment failed: unknown result"));
                }
            }
        }
    }
    public recv_writeHistoryOpenAttachment(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: WriteHistoryOpenAttachmentResult = WriteHistoryOpenAttachmentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "writeHistoryOpenAttachment failed: unknown result"));
                }
            }
        }
    }
    public recv_downloadDocumentAttachment(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DownloadDocumentAttachmentResult = DownloadDocumentAttachmentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "downloadDocumentAttachment failed: unknown result"));
                }
            }
        }
    }
    public recv_rotatePdfPages(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RotatePdfPagesResult = RotatePdfPagesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "rotatePdfPages failed: unknown result"));
                }
            }
        }
    }
    public recv_addAttachmentsToDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AddAttachmentsToDocumentResult = AddAttachmentsToDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addAttachmentsToDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_removeDocumentAttachment(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveDocumentAttachmentResult = RemoveDocumentAttachmentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeDocumentAttachment failed: unknown result"));
                }
            }
        }
    }
    public recv_markAsWaitForPublish(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: MarkAsWaitForPublishResult = MarkAsWaitForPublishResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "markAsWaitForPublish failed: unknown result"));
                }
            }
        }
    }
    public recv_changeAttachmentEditMode(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeAttachmentEditModeResult = ChangeAttachmentEditModeResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeAttachmentEditMode failed: unknown result"));
                }
            }
        }
    }
    public recv_getDocumentAttachments(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetDocumentAttachmentsResult = GetDocumentAttachmentsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getDocumentAttachments failed: unknown result"));
                }
            }
        }
    }
    public recv_getDocumentAttachmentById(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetDocumentAttachmentByIdResult = GetDocumentAttachmentByIdResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getDocumentAttachmentById failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllDocumentAttachmentVersions(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllDocumentAttachmentVersionsResult = GetAllDocumentAttachmentVersionsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllDocumentAttachmentVersions failed: unknown result"));
                }
            }
        }
    }
    public recv_changeAttachmentsVisibility(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeAttachmentsVisibilityResult = ChangeAttachmentsVisibilityResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeAttachmentsVisibility failed: unknown result"));
                }
            }
        }
    }
    public recv_createOrUpdateDocumentComment(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateOrUpdateDocumentCommentResult = CreateOrUpdateDocumentCommentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createOrUpdateDocumentComment failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllDocumentComments(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllDocumentCommentsResult = GetAllDocumentCommentsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllDocumentComments failed: unknown result"));
                }
            }
        }
    }
    public recv_deleteDocumentComment(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteDocumentCommentResult = DeleteDocumentCommentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteDocumentComment failed: unknown result"));
                }
            }
        }
    }
    public recv_createOrUpdateDocumentContentHolderLink(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateOrUpdateDocumentContentHolderLinkResult = CreateOrUpdateDocumentContentHolderLinkResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createOrUpdateDocumentContentHolderLink failed: unknown result"));
                }
            }
        }
    }
    public recv_documentToArchive(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DocumentToArchiveResult = DocumentToArchiveResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "documentToArchive failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllResponsibleForDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllResponsibleForDocumentResult = GetAllResponsibleForDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllResponsibleForDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_addResponsibleForDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AddResponsibleForDocumentResult = AddResponsibleForDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addResponsibleForDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_removeResponsibleForDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveResponsibleForDocumentResult = RemoveResponsibleForDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeResponsibleForDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_getDocHistoryPage(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetDocHistoryPageResult = GetDocHistoryPageResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getDocHistoryPage failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllNews(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllNewsResult = GetAllNewsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllNews failed: unknown result"));
                }
            }
        }
    }
    public recv_getTasksByDate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetTasksByDateResult = GetTasksByDateResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getTasksByDate failed: unknown result"));
                }
            }
        }
    }
    public recv_generateDocumentNumber(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GenerateDocumentNumberResult = GenerateDocumentNumberResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "generateDocumentNumber failed: unknown result"));
                }
            }
        }
    }
    public recv_setDocumentViewed(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetDocumentViewedResult = SetDocumentViewedResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setDocumentViewed failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllDocumentRelations(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllDocumentRelationsResult = GetAllDocumentRelationsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllDocumentRelations failed: unknown result"));
                }
            }
        }
    }
    public recv_changeRelations(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeRelationsResult = ChangeRelationsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeRelations failed: unknown result"));
                }
            }
        }
    }
    public recv_changeSubStatus(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeSubStatusResult = ChangeSubStatusResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeSubStatus failed: unknown result"));
                }
            }
        }
    }
    public recv_revertSubStatus(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RevertSubStatusResult = RevertSubStatusResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "revertSubStatus failed: unknown result"));
                }
            }
        }
    }
    public recv_increaseDeadlineForDocumentOrDocumentExecution(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: IncreaseDeadlineForDocumentOrDocumentExecutionResult = IncreaseDeadlineForDocumentOrDocumentExecutionResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "increaseDeadlineForDocumentOrDocumentExecution failed: unknown result"));
                }
            }
        }
    }
    public recv_addAdditionalConfirmers(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AddAdditionalConfirmersResult = AddAdditionalConfirmersResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addAdditionalConfirmers failed: unknown result"));
                }
            }
        }
    }
    public recv_setAdditionalDecision(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetAdditionalDecisionResult = SetAdditionalDecisionResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setAdditionalDecision failed: unknown result"));
                }
            }
        }
    }
    public recv_setAdditionalDecisionUsingServerKeyStorage(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetAdditionalDecisionUsingServerKeyStorageResult = SetAdditionalDecisionUsingServerKeyStorageResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setAdditionalDecisionUsingServerKeyStorage failed: unknown result"));
                }
            }
        }
    }
    public recv_setAdditionalDecisionExt(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetAdditionalDecisionExtResult = SetAdditionalDecisionExtResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setAdditionalDecisionExt failed: unknown result"));
                }
            }
        }
    }
    public recv_revokeDecision(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RevokeDecisionResult = RevokeDecisionResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "revokeDecision failed: unknown result"));
                }
            }
        }
    }
    public recv_markDecisionAsRemoved(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: MarkDecisionAsRemovedResult = MarkDecisionAsRemovedResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "markDecisionAsRemoved failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllOpenDocumentExecutionsStatistic(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllOpenDocumentExecutionsStatisticResult = GetAllOpenDocumentExecutionsStatisticResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllOpenDocumentExecutionsStatistic failed: unknown result"));
                }
            }
        }
    }
    public recv_changeControlForDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeControlForDocumentResult = ChangeControlForDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeControlForDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_addTagsToDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AddTagsToDocumentResult = AddTagsToDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addTagsToDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_removeTagsToDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveTagsToDocumentResult = RemoveTagsToDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeTagsToDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_addExecutorsToStage(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AddExecutorsToStageResult = AddExecutorsToStageResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addExecutorsToStage failed: unknown result"));
                }
            }
        }
    }
    public recv_getCountDocsByFilterNoPermission(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetCountDocsByFilterNoPermissionResult = GetCountDocsByFilterNoPermissionResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getCountDocsByFilterNoPermission failed: unknown result"));
                }
            }
        }
    }
    public recv_getTinyDocsByFilterNoPermission(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetTinyDocsByFilterNoPermissionResult = GetTinyDocsByFilterNoPermissionResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getTinyDocsByFilterNoPermission failed: unknown result"));
                }
            }
        }
    }
    public recv_changeRegistrationInfoForDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeRegistrationInfoForDocumentResult = ChangeRegistrationInfoForDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeRegistrationInfoForDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_createChatForDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateChatForDocumentResult = CreateChatForDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createChatForDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_getDocumentExtShareList(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetDocumentExtShareListResult = GetDocumentExtShareListResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getDocumentExtShareList failed: unknown result"));
                }
            }
        }
    }
    public recv_changeDocumentExtShare(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeDocumentExtShareResult = ChangeDocumentExtShareResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeDocumentExtShare failed: unknown result"));
                }
            }
        }
    }
    public recv_changeAttachmentExtStatus(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeAttachmentExtStatusResult = ChangeAttachmentExtStatusResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeAttachmentExtStatus failed: unknown result"));
                }
            }
        }
    }
    public recv_remindDocumentExecutor(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemindDocumentExecutorResult = RemindDocumentExecutorResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "remindDocumentExecutor failed: unknown result"));
                }
            }
        }
    }
    public recv_updateReassignResolution(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: UpdateReassignResolutionResult = UpdateReassignResolutionResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "updateReassignResolution failed: unknown result"));
                }
            }
        }
    }
    public recv_updateSubStatusComment(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: UpdateSubStatusCommentResult = UpdateSubStatusCommentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "updateSubStatusComment failed: unknown result"));
                }
            }
        }
    }
    public recv_removeSubStatusComment(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveSubStatusCommentResult = RemoveSubStatusCommentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeSubStatusComment failed: unknown result"));
                }
            }
        }
    }
    public recv_changeDocumentType(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeDocumentTypeResult = ChangeDocumentTypeResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeDocumentType failed: unknown result"));
                }
            }
        }
    }
    public recv_getDocumentRelationModel(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetDocumentRelationModelResult = GetDocumentRelationModelResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getDocumentRelationModel failed: unknown result"));
                }
            }
        }
    }
    public recv_getNewConvertedAttachmentVersion(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetNewConvertedAttachmentVersionResult = GetNewConvertedAttachmentVersionResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getNewConvertedAttachmentVersion failed: unknown result"));
                }
            }
        }
    }
    public recv_exportAsXML(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExportAsXMLResult = ExportAsXMLResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "exportAsXML failed: unknown result"));
                }
            }
        }
    }
    public recv_exportAsXMLv2(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExportAsXMLv2Result = ExportAsXMLv2Result.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "exportAsXMLv2 failed: unknown result"));
                }
            }
        }
    }
    public recv_importFromXML(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ImportFromXMLResult = ImportFromXMLResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "importFromXML failed: unknown result"));
                }
            }
        }
    }
    public recv_getDocContentItemsForChangeType(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetDocContentItemsForChangeTypeResult = GetDocContentItemsForChangeTypeResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getDocContentItemsForChangeType failed: unknown result"));
                }
            }
        }
    }
    public recv_downloadDocumentTemplate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DownloadDocumentTemplateResult = DownloadDocumentTemplateResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "downloadDocumentTemplate failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllDocumentExecutionsByFilter(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllDocumentExecutionsByFilterResult = GetAllDocumentExecutionsByFilterResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllDocumentExecutionsByFilter failed: unknown result"));
                }
            }
        }
    }
    public recv_getDocumentId(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetDocumentIdResult = GetDocumentIdResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getDocumentId failed: unknown result"));
                }
            }
        }
    }
    public recv_changeDocumentName(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeDocumentNameResult = ChangeDocumentNameResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeDocumentName failed: unknown result"));
                }
            }
        }
    }
    public recv_changeAttachmentOrder(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeAttachmentOrderResult = ChangeAttachmentOrderResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeAttachmentOrder failed: unknown result"));
                }
            }
        }
    }
    public recv_compareAttachmentsURL(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CompareAttachmentsURLResult = CompareAttachmentsURLResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "compareAttachmentsURL failed: unknown result"));
                }
            }
        }
    }
    public recv_getDocumentDecisionXml(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetDocumentDecisionXmlResult = GetDocumentDecisionXmlResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getDocumentDecisionXml failed: unknown result"));
                }
            }
        }
    }
    public recv_getReassignDocXml(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetReassignDocXmlResult = GetReassignDocXmlResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getReassignDocXml failed: unknown result"));
                }
            }
        }
    }
    public recv_addAnswerers(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AddAnswerersResult = AddAnswerersResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addAnswerers failed: unknown result"));
                }
            }
        }
    }
    public recv_addAnswerersToLinkedDocument(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AddAnswerersToLinkedDocumentResult = AddAnswerersToLinkedDocumentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addAnswerersToLinkedDocument failed: unknown result"));
                }
            }
        }
    }
    public recv_createMeetingQuestion(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateMeetingQuestionResult = CreateMeetingQuestionResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createMeetingQuestion failed: unknown result"));
                }
            }
        }
    }
    public recv_changeExternalNumber(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeExternalNumberResult = ChangeExternalNumberResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeExternalNumber failed: unknown result"));
                }
            }
        }
    }
    public recv_getAvailableSubStatuses(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAvailableSubStatusesResult = GetAvailableSubStatusesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAvailableSubStatuses failed: unknown result"));
                }
            }
        }
    }
    public recv_cardWorkingStart(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CardWorkingStartResult = CardWorkingStartResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "cardWorkingStart failed: unknown result"));
                }
            }
        }
    }
    public recv_cardWorkingLog(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CardWorkingLogResult = CardWorkingLogResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "cardWorkingLog failed: unknown result"));
                }
            }
        }
    }
    public recv_cardWorkingStop(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CardWorkingStopResult = CardWorkingStopResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "cardWorkingStop failed: unknown result"));
                }
            }
        }
    }
    public recv_getEnabledSubStatuses(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetEnabledSubStatusesResult = GetEnabledSubStatusesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getEnabledSubStatuses failed: unknown result"));
                }
            }
        }
    }
    public recv_updateUserTag(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: UpdateUserTagResult = UpdateUserTagResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "updateUserTag failed: unknown result"));
                }
            }
        }
    }
    public recv_getUserTags(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetUserTagsResult = GetUserTagsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getUserTags failed: unknown result"));
                }
            }
        }
    }
    public recv_updateTagOrders(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: UpdateTagOrdersResult = UpdateTagOrdersResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "updateTagOrders failed: unknown result"));
                }
            }
        }
    }
    public recv_documentFieldByKey(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DocumentFieldByKeyResult = DocumentFieldByKeyResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "documentFieldByKey failed: unknown result"));
                }
            }
        }
    }
    public recv_addDecoration(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AddDecorationResult = AddDecorationResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addDecoration failed: unknown result"));
                }
            }
        }
    }
}
export interface IHandler {
    calculatePermissions(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): DocPermissions.DocPermissions | Promise<DocPermissions.DocPermissions>;
    createOrUpdateDocument(token: string, document: Document.Document, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Document.Document | Promise<Document.Document>;
    updateDocument(token: string, document: Document.Document, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, addedResponsibles: Array<core.UserOrGroup>, removedResponsibles: Array<core.UserOrGroup>, addedSecurityClassificationIds: Array<string>, removedSecurityClassificationIds: Array<string>): Document.Document | Promise<Document.Document>;
    createDocument(token: string, document: Document.Document, users: Array<core.UserOrGroup>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, securityClassificationsId: Set<string>, attachments: Array<AttCreateInfo.AttCreateInfo>, docRelations: Array<DocumentRelation.DocumentRelation>): Document.Document | Promise<Document.Document>;
    createDocumentFromXML(token: string, xmlDoc: Buffer): Document.Document | Promise<Document.Document>;
    getDocument(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, decrypt: boolean, executorsPortion: number): Document.Document | Promise<Document.Document>;
    getAllDocuments(token: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter): Array<Document.Document> | Promise<Array<Document.Document>>;
    getCountAllDocuments(token: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter): number | Promise<number>;
    deleteDocument(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    getAllPassedStages(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter): Array<PassedStage.PassedStage> | Promise<Array<PassedStage.PassedStage>>;
    getExecutionTree(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, iteration: number, filter: core.KazFilter): Array<ExecutionTree.ExecutionTree> | Promise<Array<ExecutionTree.ExecutionTree>>;
    getActiveStages(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Array<DocumentPatternStage.DocumentPatternStage> | Promise<Array<DocumentPatternStage.DocumentPatternStage>>;
    getCountPeoplesWhenRenderedDecision(token: string, documentId: string, stageId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Map<string, number> | Promise<Map<string, number>>;
    setDocumentDecision(token: string, documentId: string, decision: string, documentComment: string, force: boolean, signature: string, cardId: string, attachments: Array<AttCreateInfo.AttCreateInfo>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, addSignToAttachment: Map<string, Array<string>>): Document.Document | Promise<Document.Document>;
    setDocumentDecisionByLinkId(token: string, documentId: string, linkID: string, cardId: string, documentComment: string, force: boolean, signature: string, pKeyId: string, password: string, attachments: Array<AttCreateInfo.AttCreateInfo>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, addSignToAttachment: Map<string, Array<string>>, attachmentsToSign: Array<string>): Document.Document | Promise<Document.Document>;
    setDocumentDecisionUsingServerKeyStorage(token: string, documentId: string, decision: string, documentComment: string, force: boolean, pKeyId: string, password: string, cardId: string, attachments: Array<AttCreateInfo.AttCreateInfo>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, attachmentsToSign: Array<string>): Document.Document | Promise<Document.Document>;
    setDocumentDecisionExt(token: string, documentId: string, cardId: string, linkID: string, documentComment: string, force: boolean, attachments: Array<AttCreateInfo.AttCreateInfo>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, addSignToDecision: Array<string>, addSignToAttachment: Map<string, Array<string>>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Document.Document | Promise<Document.Document>;
    approveDocumentDecision(token: string, executionId: string): boolean | Promise<boolean>;
    shareDocument(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, usersOrGroups: Array<core.UserOrGroup>): Array<DocumentExecution.DocumentExecution> | Promise<Array<DocumentExecution.DocumentExecution>>;
    revokeDocument(token: string, documentId: string, usersOrGroups: Array<core.UserOrGroup>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    getAllDocumentSharings(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter): Array<core.UserOrGroup> | Promise<Array<core.UserOrGroup>>;
    getAllDocumentReassign(token: string, filter: core.KazFilter): Array<DocumentReassign.DocumentReassign> | Promise<Array<DocumentReassign.DocumentReassign>>;
    reassignDocument(token: string, documentId: string, documentReassign: Array<DocumentReassign.DocumentReassign>, cardId: string, signature: string): Array<DocumentExecution.DocumentExecution> | Promise<Array<DocumentExecution.DocumentExecution>>;
    reassignDocumentUsingServerKeyStorage(token: string, documentId: string, documentReassign: Array<DocumentReassign.DocumentReassign>, cardId: string, pKeyId: string, password: string): Array<DocumentExecution.DocumentExecution> | Promise<Array<DocumentExecution.DocumentExecution>>;
    reassignDocumentExt(token: string, documentId: string, cardId: string, documentReassign: Array<DocumentReassign.DocumentReassign>, addSignToReasign: Array<string>): Array<DocumentExecution.DocumentExecution> | Promise<Array<DocumentExecution.DocumentExecution>>;
    revokeChildCards(token: string, cardId: string, deleteCard: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    createOrUpdateAutomaticDocumentReassign(token: string, documentReassign: DocumentReassign.DocumentReassign): DocumentReassign.DocumentReassign | Promise<DocumentReassign.DocumentReassign>;
    deleteAutomaticDocumentReassign(token: string, documentReassignId: string): boolean | Promise<boolean>;
    changeReassignControl(token: string, documentExecutionId: string, userId: string, reassignType: ExecutionReassignType.ExecutionReassignType): DocumentExecution.DocumentExecution | Promise<DocumentExecution.DocumentExecution>;
    getAllDocumentExecutions(token: string, documentId: string, stageId: string, typeLink: DocumentExecutionTypeLink.DocumentExecutionTypeLink, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Array<DocumentExecution.DocumentExecution> | Promise<Array<DocumentExecution.DocumentExecution>>;
    getDocumentExecution(token: string, docExecutionId: string): DocumentExecution.DocumentExecution | Promise<DocumentExecution.DocumentExecution>;
    changeExecutorsForDocument(token: string, docId: string, toAdd: Array<DocumentReassign.DocumentReassign>, toClose: Array<string>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    createAttachmentFrom(token: string, documentId: string, cardId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, attCreateInfoList: Array<AttCreateInfo.AttCreateInfo>, processingType: AttachmentProcessingType.AttachmentProcessingType): Array<Attachment.Attachment> | Promise<Array<Attachment.Attachment>>;
    createLoadableAttachment(token: string, documentId: string, fileName: string, totalSize: Int64, countPortions: number, cardId: string, attachmmentId: string, forDraft: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, editMode: core.AttachmentEditMode, extStatus: core.AttachmentExtStatus): string | Promise<string>;
    uploadDocumentAttachmentPortions(token: string, attachmentId: string, numberPortion: number, fileContentBytes: Buffer): Attachment.Attachment | Promise<Attachment.Attachment>;
    addPreviewToAttachment(token: string, attachmentId: string, previewContent: Buffer, attachmentType: AttachmentType.AttachmentType, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Attachment.Attachment | Promise<Attachment.Attachment>;
    writeHistoryOpenAttachment(token: string, attachmentId: string, attachmentType: AttachmentType.AttachmentType, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    downloadDocumentAttachment(token: string, attachmentId: string, attachmentType: AttachmentType.AttachmentType, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Buffer | Promise<Buffer>;
    rotatePdfPages(token: string, attachmentId: string, pages: string, angle: number, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    addAttachmentsToDocument(token: string, documentId: string, attachments: Array<AttCreateInfo.AttCreateInfo>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    removeDocumentAttachment(token: string, attachmentId: string, removeOldVersions: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    markAsWaitForPublish(token: string, attachmentId: string): boolean | Promise<boolean>;
    changeAttachmentEditMode(token: string, attachmentId: string, editMode: core.AttachmentEditMode): Attachment.Attachment | Promise<Attachment.Attachment>;
    getDocumentAttachments(token: string, documentId: string, latestOnly: boolean, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Array<Attachment.Attachment> | Promise<Array<Attachment.Attachment>>;
    getDocumentAttachmentById(token: string, attachmentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Attachment.Attachment | Promise<Attachment.Attachment>;
    getAllDocumentAttachmentVersions(token: string, attachmentId: string, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Array<Attachment.Attachment> | Promise<Array<Attachment.Attachment>>;
    changeAttachmentsVisibility(token: string, toHideList: Array<string>, toShowList: Array<string>): boolean | Promise<boolean>;
    createOrUpdateDocumentComment(token: string, documentComment: DocumentComment.DocumentComment, addToComment: string, changeType: ChangeType.ChangeType, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): DocumentComment.DocumentComment | Promise<DocumentComment.DocumentComment>;
    getAllDocumentComments(token: string, documentId: string, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Array<DocumentComment.DocumentComment> | Promise<Array<DocumentComment.DocumentComment>>;
    deleteDocumentComment(token: string, documentCommentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    createOrUpdateDocumentContentHolderLink(token: string, documentId: string, holderLinks: Array<ContentHolderLink.ContentHolderLink>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Array<ContentHolderShowPlace.ContentHolderShowPlace> | Promise<Array<ContentHolderShowPlace.ContentHolderShowPlace>>;
    documentToArchive(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    getAllResponsibleForDocument(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter): Set<core.UserOrGroup> | Promise<Set<core.UserOrGroup>>;
    addResponsibleForDocument(token: string, documentId: string, users: Array<core.UserOrGroup>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    removeResponsibleForDocument(token: string, documentId: string, users: Array<core.UserOrGroup>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    getDocHistoryPage(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter): HistoryPage.HistoryPage | Promise<HistoryPage.HistoryPage>;
    getAllNews(token: string, filter: core.KazFilter): Array<core.News> | Promise<Array<core.News>>;
    getTasksByDate(token: string, date: Int64): Map<TodayTaskType.TodayTaskType, number> | Promise<Map<TodayTaskType.TodayTaskType, number>>;
    generateDocumentNumber(token: string, documentId: string, docNumber: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): string | Promise<string>;
    setDocumentViewed(token: string, documentId: string, viewed: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    getAllDocumentRelations(token: string, documentId: string, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Array<DocumentRelation.DocumentRelation> | Promise<Array<DocumentRelation.DocumentRelation>>;
    changeRelations(token: string, toCreate: Array<DocumentRelation.DocumentRelation>, toRemove: Array<string>): Array<DocumentRelation.DocumentRelation> | Promise<Array<DocumentRelation.DocumentRelation>>;
    changeSubStatus(token: string, documentId: string, subStatus: DocPatternStageSubStatus.DocPatternStageSubStatus, comment: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    revertSubStatus(token: string, documentId: string, subStatus: DocPatternStageSubStatus.DocPatternStageSubStatus, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    increaseDeadlineForDocumentOrDocumentExecution(token: string, documentId: string, documentExecution: string, deadlineTime: Int64, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    addAdditionalConfirmers(token: string, cardId: string, users: Array<string>, deadlineDate: Int64, comment: string, requireMyParticipation: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    setAdditionalDecision(token: string, userDecision: Map<string, string>, cardId: string, comment: string, returnToParentStage: boolean, signature: string): Document.Document | Promise<Document.Document>;
    setAdditionalDecisionUsingServerKeyStorage(token: string, userDecision: Map<string, string>, cardId: string, comment: string, returnToParentStage: boolean, pKeyId: string, password: string): Document.Document | Promise<Document.Document>;
    setAdditionalDecisionExt(token: string, userMap: Map<string, string>, cardId: string, comment: string, returnToParentStage: boolean, signatures: Array<string>): Document.Document | Promise<Document.Document>;
    revokeDecision(token: string, documentReassign: Array<DocumentReassign.DocumentReassign>, cardId: string, comment: string): Document.Document | Promise<Document.Document>;
    markDecisionAsRemoved(token: string, documentId: string, cardId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): DocumentExecution.DocumentExecution | Promise<DocumentExecution.DocumentExecution>;
    getAllOpenDocumentExecutionsStatistic(token: string, userId: string): Map<DocumentExecutionStatisticType.DocumentExecutionStatisticType, number> | Promise<Map<DocumentExecutionStatisticType.DocumentExecutionStatisticType, number>>;
    changeControlForDocument(token: string, documentId: string, control: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    addTagsToDocument(token: string, docId: string, tags: Array<string>): boolean | Promise<boolean>;
    removeTagsToDocument(token: string, docId: string, tags: Array<string>): boolean | Promise<boolean>;
    addExecutorsToStage(token: string, docId: string, documentReassign: Array<DocumentReassign.DocumentReassign>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Array<DocumentExecution.DocumentExecution> | Promise<Array<DocumentExecution.DocumentExecution>>;
    getCountDocsByFilterNoPermission(token: string, patternGroupId: string, filter: core.KazFilter): Int64 | Promise<Int64>;
    getTinyDocsByFilterNoPermission(token: string, filter: core.KazFilter): Array<Document.Document> | Promise<Array<Document.Document>>;
    changeRegistrationInfoForDocument(token: string, documentId: string, newRegistrationDate: Int64, newRegistrationNumber: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    createChatForDocument(token: string, documentId: string): string | Promise<string>;
    getDocumentExtShareList(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, filter: core.KazFilter): Array<DocumentExtShare.DocumentExtShare> | Promise<Array<DocumentExtShare.DocumentExtShare>>;
    changeDocumentExtShare(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, toAdd: Array<DocumentExtShare.DocumentExtShare>, toRemove: Array<string>): Array<DocumentExtShare.DocumentExtShare> | Promise<Array<DocumentExtShare.DocumentExtShare>>;
    changeAttachmentExtStatus(token: string, statusMap: Map<string, core.AttachmentExtStatus>): boolean | Promise<boolean>;
    remindDocumentExecutor(token: string, cardId: string, comment: string, policy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    updateReassignResolution(token: string, cardId: string, resolution: string, policy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    updateSubStatusComment(token: string, docCommentId: string, comment: string, policy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    removeSubStatusComment(token: string, docCommentId: string, policy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    changeDocumentType(token: string, docId: string, startStageId: string, stages: Array<DocumentPatternStage.DocumentPatternStage>, contentItems: Array<ContentItem.ContentItem>, roles: Array<PatternProcessRole.PatternProcessRole>, patternVariables: Array<PatternVariable.PatternVariable>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, newRegNumber: string, patternId: string): boolean | Promise<boolean>;
    getDocumentRelationModel(token: string, docId: string, filter: core.KazFilter): DocumentRelationModel.DocumentRelationModel | Promise<DocumentRelationModel.DocumentRelationModel>;
    getNewConvertedAttachmentVersion(token: string, prevAttId: string): Attachment.Attachment | Promise<Attachment.Attachment>;
    exportAsXML(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, allowedAttachmentFileExt: string, allowedAttachmentType: string): Buffer | Promise<Buffer>;
    exportAsXMLv2(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, allowedAttachmentFileExt: string, allowedAttachmentType: string): Buffer | Promise<Buffer>;
    importFromXML(token: string, xml: Buffer): Document.Document | Promise<Document.Document>;
    getDocContentItemsForChangeType(token: string, documentId: string): Array<ContentItem.ContentItem> | Promise<Array<ContentItem.ContentItem>>;
    downloadDocumentTemplate(token: string, documentId: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy, pdfPostDecorators: Array<core.PDFPostDecorator>): Buffer | Promise<Buffer>;
    getAllDocumentExecutionsByFilter(token: string, documentId: string, filter: core.KazFilter, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): Array<DocumentExecution.DocumentExecution> | Promise<Array<DocumentExecution.DocumentExecution>>;
    getDocumentId(token: string, sType: DocumentSearchType.DocumentSearchType, value: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): string | Promise<string>;
    changeDocumentName(token: string, docId: string, docName: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    changeAttachmentOrder(token: string, documentId: string, orderMap: Map<string, number>, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    compareAttachmentsURL(token: string, attachmentId1: string, attachmentId2: string, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): string | Promise<string>;
    getDocumentDecisionXml(token: string, documentId: string, linkId: string, cardId: string, comment: string): string | Promise<string>;
    getReassignDocXml(token: string, documentId: string, cardId: string, documentReassign: Array<DocumentReassign.DocumentReassign>): string | Promise<string>;
    addAnswerers(token: string, cardId: string, users: Array<string>, deadlineDate: Int64, comment: string, requireMyParticipation: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    addAnswerersToLinkedDocument(token: string, docId: string, users: Array<core.UserOrGroup>, deadlineDate: Int64, comment: string, requireMyParticipation: boolean, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    createMeetingQuestion(token: string, document: Document.Document, users: Array<core.UserOrGroup>, holderLinks: Array<ContentHolderLink.ContentHolderLink>, securityClassificationsId: Set<string>, attachments: Array<AttCreateInfo.AttCreateInfo>, docRelations: Array<DocumentRelation.DocumentRelation>, meetingDocumentId: string): Document.Document | Promise<Document.Document>;
    changeExternalNumber(token: string, documentId: string, externalId: string, externalNumber: string, externalRegDate: Int64, accessPolicy: DocumentAccessPolicy.DocumentAccessPolicy): boolean | Promise<boolean>;
    getAvailableSubStatuses(token: string, documentId: string): Set<DocPatternStageSubStatus.DocPatternStageSubStatus> | Promise<Set<DocPatternStageSubStatus.DocPatternStageSubStatus>>;
    cardWorkingStart(token: string, cardId: string, workComment: string): DocumentExecution.DocumentExecution | Promise<DocumentExecution.DocumentExecution>;
    cardWorkingLog(token: string, cardId: string, workComment: string): DocumentExecution.DocumentExecution | Promise<DocumentExecution.DocumentExecution>;
    cardWorkingStop(token: string, cardId: string, workComment: string): DocumentExecution.DocumentExecution | Promise<DocumentExecution.DocumentExecution>;
    getEnabledSubStatuses(token: string, documentId: string): Map<SubStatusKey.SubStatusKey, Array<DocPatternStageSubStatus.DocPatternStageSubStatus>> | Promise<Map<SubStatusKey.SubStatusKey, Array<DocPatternStageSubStatus.DocPatternStageSubStatus>>>;
    updateUserTag(token: string, docTag: DocumentTag.DocumentTag, fdelete: boolean): DocumentTag.DocumentTag | Promise<DocumentTag.DocumentTag>;
    getUserTags(token: string, filter: core.KazFilter): Array<DocumentTag.DocumentTag> | Promise<Array<DocumentTag.DocumentTag>>;
    updateTagOrders(token: string, oredrMap: Map<string, number>): boolean | Promise<boolean>;
    documentFieldByKey(token: string, documentId: string, key: string, keyType: DocKeyType.DocKeyType): string | Promise<string>;
    addDecoration(token: string, attachmentId: string, decoratorKeys: Array<string>): boolean | Promise<boolean>;
}
export class Processor {
    public _handler: IHandler;
    constructor(handler: IHandler) {
        this._handler = handler;
    }
    public process(input: thrift.TProtocol, output: thrift.TProtocol): void {
        const metadata: thrift.TMessage = input.readMessageBegin();
        const fname: string = metadata.fname;
        const requestId: number = metadata.rseqid;
        const methodName: string = "process_" + fname;
        switch (methodName) {
            case "process_calculatePermissions": {
                this.process_calculatePermissions(requestId, input, output);
                return;
            }
            case "process_createOrUpdateDocument": {
                this.process_createOrUpdateDocument(requestId, input, output);
                return;
            }
            case "process_updateDocument": {
                this.process_updateDocument(requestId, input, output);
                return;
            }
            case "process_createDocument": {
                this.process_createDocument(requestId, input, output);
                return;
            }
            case "process_createDocumentFromXML": {
                this.process_createDocumentFromXML(requestId, input, output);
                return;
            }
            case "process_getDocument": {
                this.process_getDocument(requestId, input, output);
                return;
            }
            case "process_getAllDocuments": {
                this.process_getAllDocuments(requestId, input, output);
                return;
            }
            case "process_getCountAllDocuments": {
                this.process_getCountAllDocuments(requestId, input, output);
                return;
            }
            case "process_deleteDocument": {
                this.process_deleteDocument(requestId, input, output);
                return;
            }
            case "process_getAllPassedStages": {
                this.process_getAllPassedStages(requestId, input, output);
                return;
            }
            case "process_getExecutionTree": {
                this.process_getExecutionTree(requestId, input, output);
                return;
            }
            case "process_getActiveStages": {
                this.process_getActiveStages(requestId, input, output);
                return;
            }
            case "process_getCountPeoplesWhenRenderedDecision": {
                this.process_getCountPeoplesWhenRenderedDecision(requestId, input, output);
                return;
            }
            case "process_setDocumentDecision": {
                this.process_setDocumentDecision(requestId, input, output);
                return;
            }
            case "process_setDocumentDecisionByLinkId": {
                this.process_setDocumentDecisionByLinkId(requestId, input, output);
                return;
            }
            case "process_setDocumentDecisionUsingServerKeyStorage": {
                this.process_setDocumentDecisionUsingServerKeyStorage(requestId, input, output);
                return;
            }
            case "process_setDocumentDecisionExt": {
                this.process_setDocumentDecisionExt(requestId, input, output);
                return;
            }
            case "process_approveDocumentDecision": {
                this.process_approveDocumentDecision(requestId, input, output);
                return;
            }
            case "process_shareDocument": {
                this.process_shareDocument(requestId, input, output);
                return;
            }
            case "process_revokeDocument": {
                this.process_revokeDocument(requestId, input, output);
                return;
            }
            case "process_getAllDocumentSharings": {
                this.process_getAllDocumentSharings(requestId, input, output);
                return;
            }
            case "process_getAllDocumentReassign": {
                this.process_getAllDocumentReassign(requestId, input, output);
                return;
            }
            case "process_reassignDocument": {
                this.process_reassignDocument(requestId, input, output);
                return;
            }
            case "process_reassignDocumentUsingServerKeyStorage": {
                this.process_reassignDocumentUsingServerKeyStorage(requestId, input, output);
                return;
            }
            case "process_reassignDocumentExt": {
                this.process_reassignDocumentExt(requestId, input, output);
                return;
            }
            case "process_revokeChildCards": {
                this.process_revokeChildCards(requestId, input, output);
                return;
            }
            case "process_createOrUpdateAutomaticDocumentReassign": {
                this.process_createOrUpdateAutomaticDocumentReassign(requestId, input, output);
                return;
            }
            case "process_deleteAutomaticDocumentReassign": {
                this.process_deleteAutomaticDocumentReassign(requestId, input, output);
                return;
            }
            case "process_changeReassignControl": {
                this.process_changeReassignControl(requestId, input, output);
                return;
            }
            case "process_getAllDocumentExecutions": {
                this.process_getAllDocumentExecutions(requestId, input, output);
                return;
            }
            case "process_getDocumentExecution": {
                this.process_getDocumentExecution(requestId, input, output);
                return;
            }
            case "process_changeExecutorsForDocument": {
                this.process_changeExecutorsForDocument(requestId, input, output);
                return;
            }
            case "process_createAttachmentFrom": {
                this.process_createAttachmentFrom(requestId, input, output);
                return;
            }
            case "process_createLoadableAttachment": {
                this.process_createLoadableAttachment(requestId, input, output);
                return;
            }
            case "process_uploadDocumentAttachmentPortions": {
                this.process_uploadDocumentAttachmentPortions(requestId, input, output);
                return;
            }
            case "process_addPreviewToAttachment": {
                this.process_addPreviewToAttachment(requestId, input, output);
                return;
            }
            case "process_writeHistoryOpenAttachment": {
                this.process_writeHistoryOpenAttachment(requestId, input, output);
                return;
            }
            case "process_downloadDocumentAttachment": {
                this.process_downloadDocumentAttachment(requestId, input, output);
                return;
            }
            case "process_rotatePdfPages": {
                this.process_rotatePdfPages(requestId, input, output);
                return;
            }
            case "process_addAttachmentsToDocument": {
                this.process_addAttachmentsToDocument(requestId, input, output);
                return;
            }
            case "process_removeDocumentAttachment": {
                this.process_removeDocumentAttachment(requestId, input, output);
                return;
            }
            case "process_markAsWaitForPublish": {
                this.process_markAsWaitForPublish(requestId, input, output);
                return;
            }
            case "process_changeAttachmentEditMode": {
                this.process_changeAttachmentEditMode(requestId, input, output);
                return;
            }
            case "process_getDocumentAttachments": {
                this.process_getDocumentAttachments(requestId, input, output);
                return;
            }
            case "process_getDocumentAttachmentById": {
                this.process_getDocumentAttachmentById(requestId, input, output);
                return;
            }
            case "process_getAllDocumentAttachmentVersions": {
                this.process_getAllDocumentAttachmentVersions(requestId, input, output);
                return;
            }
            case "process_changeAttachmentsVisibility": {
                this.process_changeAttachmentsVisibility(requestId, input, output);
                return;
            }
            case "process_createOrUpdateDocumentComment": {
                this.process_createOrUpdateDocumentComment(requestId, input, output);
                return;
            }
            case "process_getAllDocumentComments": {
                this.process_getAllDocumentComments(requestId, input, output);
                return;
            }
            case "process_deleteDocumentComment": {
                this.process_deleteDocumentComment(requestId, input, output);
                return;
            }
            case "process_createOrUpdateDocumentContentHolderLink": {
                this.process_createOrUpdateDocumentContentHolderLink(requestId, input, output);
                return;
            }
            case "process_documentToArchive": {
                this.process_documentToArchive(requestId, input, output);
                return;
            }
            case "process_getAllResponsibleForDocument": {
                this.process_getAllResponsibleForDocument(requestId, input, output);
                return;
            }
            case "process_addResponsibleForDocument": {
                this.process_addResponsibleForDocument(requestId, input, output);
                return;
            }
            case "process_removeResponsibleForDocument": {
                this.process_removeResponsibleForDocument(requestId, input, output);
                return;
            }
            case "process_getDocHistoryPage": {
                this.process_getDocHistoryPage(requestId, input, output);
                return;
            }
            case "process_getAllNews": {
                this.process_getAllNews(requestId, input, output);
                return;
            }
            case "process_getTasksByDate": {
                this.process_getTasksByDate(requestId, input, output);
                return;
            }
            case "process_generateDocumentNumber": {
                this.process_generateDocumentNumber(requestId, input, output);
                return;
            }
            case "process_setDocumentViewed": {
                this.process_setDocumentViewed(requestId, input, output);
                return;
            }
            case "process_getAllDocumentRelations": {
                this.process_getAllDocumentRelations(requestId, input, output);
                return;
            }
            case "process_changeRelations": {
                this.process_changeRelations(requestId, input, output);
                return;
            }
            case "process_changeSubStatus": {
                this.process_changeSubStatus(requestId, input, output);
                return;
            }
            case "process_revertSubStatus": {
                this.process_revertSubStatus(requestId, input, output);
                return;
            }
            case "process_increaseDeadlineForDocumentOrDocumentExecution": {
                this.process_increaseDeadlineForDocumentOrDocumentExecution(requestId, input, output);
                return;
            }
            case "process_addAdditionalConfirmers": {
                this.process_addAdditionalConfirmers(requestId, input, output);
                return;
            }
            case "process_setAdditionalDecision": {
                this.process_setAdditionalDecision(requestId, input, output);
                return;
            }
            case "process_setAdditionalDecisionUsingServerKeyStorage": {
                this.process_setAdditionalDecisionUsingServerKeyStorage(requestId, input, output);
                return;
            }
            case "process_setAdditionalDecisionExt": {
                this.process_setAdditionalDecisionExt(requestId, input, output);
                return;
            }
            case "process_revokeDecision": {
                this.process_revokeDecision(requestId, input, output);
                return;
            }
            case "process_markDecisionAsRemoved": {
                this.process_markDecisionAsRemoved(requestId, input, output);
                return;
            }
            case "process_getAllOpenDocumentExecutionsStatistic": {
                this.process_getAllOpenDocumentExecutionsStatistic(requestId, input, output);
                return;
            }
            case "process_changeControlForDocument": {
                this.process_changeControlForDocument(requestId, input, output);
                return;
            }
            case "process_addTagsToDocument": {
                this.process_addTagsToDocument(requestId, input, output);
                return;
            }
            case "process_removeTagsToDocument": {
                this.process_removeTagsToDocument(requestId, input, output);
                return;
            }
            case "process_addExecutorsToStage": {
                this.process_addExecutorsToStage(requestId, input, output);
                return;
            }
            case "process_getCountDocsByFilterNoPermission": {
                this.process_getCountDocsByFilterNoPermission(requestId, input, output);
                return;
            }
            case "process_getTinyDocsByFilterNoPermission": {
                this.process_getTinyDocsByFilterNoPermission(requestId, input, output);
                return;
            }
            case "process_changeRegistrationInfoForDocument": {
                this.process_changeRegistrationInfoForDocument(requestId, input, output);
                return;
            }
            case "process_createChatForDocument": {
                this.process_createChatForDocument(requestId, input, output);
                return;
            }
            case "process_getDocumentExtShareList": {
                this.process_getDocumentExtShareList(requestId, input, output);
                return;
            }
            case "process_changeDocumentExtShare": {
                this.process_changeDocumentExtShare(requestId, input, output);
                return;
            }
            case "process_changeAttachmentExtStatus": {
                this.process_changeAttachmentExtStatus(requestId, input, output);
                return;
            }
            case "process_remindDocumentExecutor": {
                this.process_remindDocumentExecutor(requestId, input, output);
                return;
            }
            case "process_updateReassignResolution": {
                this.process_updateReassignResolution(requestId, input, output);
                return;
            }
            case "process_updateSubStatusComment": {
                this.process_updateSubStatusComment(requestId, input, output);
                return;
            }
            case "process_removeSubStatusComment": {
                this.process_removeSubStatusComment(requestId, input, output);
                return;
            }
            case "process_changeDocumentType": {
                this.process_changeDocumentType(requestId, input, output);
                return;
            }
            case "process_getDocumentRelationModel": {
                this.process_getDocumentRelationModel(requestId, input, output);
                return;
            }
            case "process_getNewConvertedAttachmentVersion": {
                this.process_getNewConvertedAttachmentVersion(requestId, input, output);
                return;
            }
            case "process_exportAsXML": {
                this.process_exportAsXML(requestId, input, output);
                return;
            }
            case "process_exportAsXMLv2": {
                this.process_exportAsXMLv2(requestId, input, output);
                return;
            }
            case "process_importFromXML": {
                this.process_importFromXML(requestId, input, output);
                return;
            }
            case "process_getDocContentItemsForChangeType": {
                this.process_getDocContentItemsForChangeType(requestId, input, output);
                return;
            }
            case "process_downloadDocumentTemplate": {
                this.process_downloadDocumentTemplate(requestId, input, output);
                return;
            }
            case "process_getAllDocumentExecutionsByFilter": {
                this.process_getAllDocumentExecutionsByFilter(requestId, input, output);
                return;
            }
            case "process_getDocumentId": {
                this.process_getDocumentId(requestId, input, output);
                return;
            }
            case "process_changeDocumentName": {
                this.process_changeDocumentName(requestId, input, output);
                return;
            }
            case "process_changeAttachmentOrder": {
                this.process_changeAttachmentOrder(requestId, input, output);
                return;
            }
            case "process_compareAttachmentsURL": {
                this.process_compareAttachmentsURL(requestId, input, output);
                return;
            }
            case "process_getDocumentDecisionXml": {
                this.process_getDocumentDecisionXml(requestId, input, output);
                return;
            }
            case "process_getReassignDocXml": {
                this.process_getReassignDocXml(requestId, input, output);
                return;
            }
            case "process_addAnswerers": {
                this.process_addAnswerers(requestId, input, output);
                return;
            }
            case "process_addAnswerersToLinkedDocument": {
                this.process_addAnswerersToLinkedDocument(requestId, input, output);
                return;
            }
            case "process_createMeetingQuestion": {
                this.process_createMeetingQuestion(requestId, input, output);
                return;
            }
            case "process_changeExternalNumber": {
                this.process_changeExternalNumber(requestId, input, output);
                return;
            }
            case "process_getAvailableSubStatuses": {
                this.process_getAvailableSubStatuses(requestId, input, output);
                return;
            }
            case "process_cardWorkingStart": {
                this.process_cardWorkingStart(requestId, input, output);
                return;
            }
            case "process_cardWorkingLog": {
                this.process_cardWorkingLog(requestId, input, output);
                return;
            }
            case "process_cardWorkingStop": {
                this.process_cardWorkingStop(requestId, input, output);
                return;
            }
            case "process_getEnabledSubStatuses": {
                this.process_getEnabledSubStatuses(requestId, input, output);
                return;
            }
            case "process_updateUserTag": {
                this.process_updateUserTag(requestId, input, output);
                return;
            }
            case "process_getUserTags": {
                this.process_getUserTags(requestId, input, output);
                return;
            }
            case "process_updateTagOrders": {
                this.process_updateTagOrders(requestId, input, output);
                return;
            }
            case "process_documentFieldByKey": {
                this.process_documentFieldByKey(requestId, input, output);
                return;
            }
            case "process_addDecoration": {
                this.process_addDecoration(requestId, input, output);
                return;
            }
            default: {
                input.skip(thrift.Thrift.Type.STRUCT);
                input.readMessageEnd();
                const errMessage = "Unknown function " + fname;
                const err = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                output.writeMessageBegin(fname, thrift.Thrift.MessageType.EXCEPTION, requestId);
                err.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        }
    }
    public process_calculatePermissions(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<DocPermissions.DocPermissions>((resolve, reject): void => {
            try {
                const args: CalculatePermissionsArgs = CalculatePermissionsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.calculatePermissions(args.token, args.documentId, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DocPermissions.DocPermissions): void => {
            const result: CalculatePermissionsResult = new CalculatePermissionsResult({ success: data });
            output.writeMessageBegin("calculatePermissions", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CalculatePermissionsResult = new CalculatePermissionsResult({ validError: err });
                output.writeMessageBegin("calculatePermissions", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CalculatePermissionsResult = new CalculatePermissionsResult({ error: err });
                output.writeMessageBegin("calculatePermissions", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("calculatePermissions", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createOrUpdateDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Document.Document>((resolve, reject): void => {
            try {
                const args: CreateOrUpdateDocumentArgs = CreateOrUpdateDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createOrUpdateDocument(args.token, args.document, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Document.Document): void => {
            const result: CreateOrUpdateDocumentResult = new CreateOrUpdateDocumentResult({ success: data });
            output.writeMessageBegin("createOrUpdateDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CreateOrUpdateDocumentResult = new CreateOrUpdateDocumentResult({ validError: err });
                output.writeMessageBegin("createOrUpdateDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CreateOrUpdateDocumentResult = new CreateOrUpdateDocumentResult({ error: err });
                output.writeMessageBegin("createOrUpdateDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createOrUpdateDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_updateDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Document.Document>((resolve, reject): void => {
            try {
                const args: UpdateDocumentArgs = UpdateDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.updateDocument(args.token, args.document, args.accessPolicy, args.addedResponsibles, args.removedResponsibles, args.addedSecurityClassificationIds, args.removedSecurityClassificationIds));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Document.Document): void => {
            const result: UpdateDocumentResult = new UpdateDocumentResult({ success: data });
            output.writeMessageBegin("updateDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: UpdateDocumentResult = new UpdateDocumentResult({ validError: err });
                output.writeMessageBegin("updateDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: UpdateDocumentResult = new UpdateDocumentResult({ error: err });
                output.writeMessageBegin("updateDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("updateDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Document.Document>((resolve, reject): void => {
            try {
                const args: CreateDocumentArgs = CreateDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createDocument(args.token, args.document, args.users, args.holderLinks, args.securityClassificationsId, args.attachments, args.docRelations));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Document.Document): void => {
            const result: CreateDocumentResult = new CreateDocumentResult({ success: data });
            output.writeMessageBegin("createDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CreateDocumentResult = new CreateDocumentResult({ validError: err });
                output.writeMessageBegin("createDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CreateDocumentResult = new CreateDocumentResult({ error: err });
                output.writeMessageBegin("createDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createDocumentFromXML(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Document.Document>((resolve, reject): void => {
            try {
                const args: CreateDocumentFromXMLArgs = CreateDocumentFromXMLArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createDocumentFromXML(args.token, args.xmlDoc));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Document.Document): void => {
            const result: CreateDocumentFromXMLResult = new CreateDocumentFromXMLResult({ success: data });
            output.writeMessageBegin("createDocumentFromXML", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CreateDocumentFromXMLResult = new CreateDocumentFromXMLResult({ validError: err });
                output.writeMessageBegin("createDocumentFromXML", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CreateDocumentFromXMLResult = new CreateDocumentFromXMLResult({ error: err });
                output.writeMessageBegin("createDocumentFromXML", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createDocumentFromXML", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Document.Document>((resolve, reject): void => {
            try {
                const args: GetDocumentArgs = GetDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getDocument(args.token, args.documentId, args.accessPolicy, args.decrypt, args.executorsPortion));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Document.Document): void => {
            const result: GetDocumentResult = new GetDocumentResult({ success: data });
            output.writeMessageBegin("getDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetDocumentResult = new GetDocumentResult({ validError: err });
                output.writeMessageBegin("getDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetDocumentResult = new GetDocumentResult({ error: err });
                output.writeMessageBegin("getDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllDocuments(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<Document.Document>>((resolve, reject): void => {
            try {
                const args: GetAllDocumentsArgs = GetAllDocumentsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllDocuments(args.token, args.accessPolicy, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<Document.Document>): void => {
            const result: GetAllDocumentsResult = new GetAllDocumentsResult({ success: data });
            output.writeMessageBegin("getAllDocuments", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllDocumentsResult = new GetAllDocumentsResult({ validError: err });
                output.writeMessageBegin("getAllDocuments", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllDocumentsResult = new GetAllDocumentsResult({ error: err });
                output.writeMessageBegin("getAllDocuments", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllDocuments", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getCountAllDocuments(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<number>((resolve, reject): void => {
            try {
                const args: GetCountAllDocumentsArgs = GetCountAllDocumentsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getCountAllDocuments(args.token, args.accessPolicy, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): void => {
            const result: GetCountAllDocumentsResult = new GetCountAllDocumentsResult({ success: data });
            output.writeMessageBegin("getCountAllDocuments", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetCountAllDocumentsResult = new GetCountAllDocumentsResult({ validError: err });
                output.writeMessageBegin("getCountAllDocuments", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetCountAllDocumentsResult = new GetCountAllDocumentsResult({ error: err });
                output.writeMessageBegin("getCountAllDocuments", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getCountAllDocuments", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_deleteDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: DeleteDocumentArgs = DeleteDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteDocument(args.token, args.documentId, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: DeleteDocumentResult = new DeleteDocumentResult({ success: data });
            output.writeMessageBegin("deleteDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: DeleteDocumentResult = new DeleteDocumentResult({ validError: err });
                output.writeMessageBegin("deleteDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: DeleteDocumentResult = new DeleteDocumentResult({ error: err });
                output.writeMessageBegin("deleteDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("deleteDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllPassedStages(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<PassedStage.PassedStage>>((resolve, reject): void => {
            try {
                const args: GetAllPassedStagesArgs = GetAllPassedStagesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllPassedStages(args.token, args.documentId, args.accessPolicy, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<PassedStage.PassedStage>): void => {
            const result: GetAllPassedStagesResult = new GetAllPassedStagesResult({ success: data });
            output.writeMessageBegin("getAllPassedStages", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllPassedStagesResult = new GetAllPassedStagesResult({ validError: err });
                output.writeMessageBegin("getAllPassedStages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllPassedStagesResult = new GetAllPassedStagesResult({ error: err });
                output.writeMessageBegin("getAllPassedStages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllPassedStages", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getExecutionTree(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<ExecutionTree.ExecutionTree>>((resolve, reject): void => {
            try {
                const args: GetExecutionTreeArgs = GetExecutionTreeArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getExecutionTree(args.token, args.documentId, args.accessPolicy, args.iteration, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<ExecutionTree.ExecutionTree>): void => {
            const result: GetExecutionTreeResult = new GetExecutionTreeResult({ success: data });
            output.writeMessageBegin("getExecutionTree", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetExecutionTreeResult = new GetExecutionTreeResult({ validError: err });
                output.writeMessageBegin("getExecutionTree", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetExecutionTreeResult = new GetExecutionTreeResult({ error: err });
                output.writeMessageBegin("getExecutionTree", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getExecutionTree", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getActiveStages(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocumentPatternStage.DocumentPatternStage>>((resolve, reject): void => {
            try {
                const args: GetActiveStagesArgs = GetActiveStagesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getActiveStages(args.token, args.documentId, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocumentPatternStage.DocumentPatternStage>): void => {
            const result: GetActiveStagesResult = new GetActiveStagesResult({ success: data });
            output.writeMessageBegin("getActiveStages", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetActiveStagesResult = new GetActiveStagesResult({ validError: err });
                output.writeMessageBegin("getActiveStages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetActiveStagesResult = new GetActiveStagesResult({ error: err });
                output.writeMessageBegin("getActiveStages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getActiveStages", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getCountPeoplesWhenRenderedDecision(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Map<string, number>>((resolve, reject): void => {
            try {
                const args: GetCountPeoplesWhenRenderedDecisionArgs = GetCountPeoplesWhenRenderedDecisionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getCountPeoplesWhenRenderedDecision(args.token, args.documentId, args.stageId, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Map<string, number>): void => {
            const result: GetCountPeoplesWhenRenderedDecisionResult = new GetCountPeoplesWhenRenderedDecisionResult({ success: data });
            output.writeMessageBegin("getCountPeoplesWhenRenderedDecision", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetCountPeoplesWhenRenderedDecisionResult = new GetCountPeoplesWhenRenderedDecisionResult({ validError: err });
                output.writeMessageBegin("getCountPeoplesWhenRenderedDecision", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetCountPeoplesWhenRenderedDecisionResult = new GetCountPeoplesWhenRenderedDecisionResult({ error: err });
                output.writeMessageBegin("getCountPeoplesWhenRenderedDecision", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getCountPeoplesWhenRenderedDecision", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_setDocumentDecision(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Document.Document>((resolve, reject): void => {
            try {
                const args: SetDocumentDecisionArgs = SetDocumentDecisionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setDocumentDecision(args.token, args.documentId, args.decision, args.documentComment, args.force, args.signature, args.cardId, args.attachments, args.holderLinks, args.accessPolicy, args.addSignToAttachment));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Document.Document): void => {
            const result: SetDocumentDecisionResult = new SetDocumentDecisionResult({ success: data });
            output.writeMessageBegin("setDocumentDecision", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: SetDocumentDecisionResult = new SetDocumentDecisionResult({ validError: err });
                output.writeMessageBegin("setDocumentDecision", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: SetDocumentDecisionResult = new SetDocumentDecisionResult({ error: err });
                output.writeMessageBegin("setDocumentDecision", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("setDocumentDecision", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_setDocumentDecisionByLinkId(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Document.Document>((resolve, reject): void => {
            try {
                const args: SetDocumentDecisionByLinkIdArgs = SetDocumentDecisionByLinkIdArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setDocumentDecisionByLinkId(args.token, args.documentId, args.linkID, args.cardId, args.documentComment, args.force, args.signature, args.pKeyId, args.password, args.attachments, args.holderLinks, args.accessPolicy, args.addSignToAttachment, args.attachmentsToSign));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Document.Document): void => {
            const result: SetDocumentDecisionByLinkIdResult = new SetDocumentDecisionByLinkIdResult({ success: data });
            output.writeMessageBegin("setDocumentDecisionByLinkId", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: SetDocumentDecisionByLinkIdResult = new SetDocumentDecisionByLinkIdResult({ validError: err });
                output.writeMessageBegin("setDocumentDecisionByLinkId", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: SetDocumentDecisionByLinkIdResult = new SetDocumentDecisionByLinkIdResult({ error: err });
                output.writeMessageBegin("setDocumentDecisionByLinkId", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("setDocumentDecisionByLinkId", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_setDocumentDecisionUsingServerKeyStorage(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Document.Document>((resolve, reject): void => {
            try {
                const args: SetDocumentDecisionUsingServerKeyStorageArgs = SetDocumentDecisionUsingServerKeyStorageArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setDocumentDecisionUsingServerKeyStorage(args.token, args.documentId, args.decision, args.documentComment, args.force, args.pKeyId, args.password, args.cardId, args.attachments, args.holderLinks, args.accessPolicy, args.attachmentsToSign));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Document.Document): void => {
            const result: SetDocumentDecisionUsingServerKeyStorageResult = new SetDocumentDecisionUsingServerKeyStorageResult({ success: data });
            output.writeMessageBegin("setDocumentDecisionUsingServerKeyStorage", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: SetDocumentDecisionUsingServerKeyStorageResult = new SetDocumentDecisionUsingServerKeyStorageResult({ validError: err });
                output.writeMessageBegin("setDocumentDecisionUsingServerKeyStorage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: SetDocumentDecisionUsingServerKeyStorageResult = new SetDocumentDecisionUsingServerKeyStorageResult({ error: err });
                output.writeMessageBegin("setDocumentDecisionUsingServerKeyStorage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("setDocumentDecisionUsingServerKeyStorage", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_setDocumentDecisionExt(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Document.Document>((resolve, reject): void => {
            try {
                const args: SetDocumentDecisionExtArgs = SetDocumentDecisionExtArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setDocumentDecisionExt(args.token, args.documentId, args.cardId, args.linkID, args.documentComment, args.force, args.attachments, args.holderLinks, args.addSignToDecision, args.addSignToAttachment, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Document.Document): void => {
            const result: SetDocumentDecisionExtResult = new SetDocumentDecisionExtResult({ success: data });
            output.writeMessageBegin("setDocumentDecisionExt", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: SetDocumentDecisionExtResult = new SetDocumentDecisionExtResult({ validError: err });
                output.writeMessageBegin("setDocumentDecisionExt", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: SetDocumentDecisionExtResult = new SetDocumentDecisionExtResult({ error: err });
                output.writeMessageBegin("setDocumentDecisionExt", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("setDocumentDecisionExt", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_approveDocumentDecision(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ApproveDocumentDecisionArgs = ApproveDocumentDecisionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.approveDocumentDecision(args.token, args.executionId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ApproveDocumentDecisionResult = new ApproveDocumentDecisionResult({ success: data });
            output.writeMessageBegin("approveDocumentDecision", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ApproveDocumentDecisionResult = new ApproveDocumentDecisionResult({ validError: err });
                output.writeMessageBegin("approveDocumentDecision", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ApproveDocumentDecisionResult = new ApproveDocumentDecisionResult({ error: err });
                output.writeMessageBegin("approveDocumentDecision", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("approveDocumentDecision", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_shareDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocumentExecution.DocumentExecution>>((resolve, reject): void => {
            try {
                const args: ShareDocumentArgs = ShareDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.shareDocument(args.token, args.documentId, args.accessPolicy, args.usersOrGroups));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocumentExecution.DocumentExecution>): void => {
            const result: ShareDocumentResult = new ShareDocumentResult({ success: data });
            output.writeMessageBegin("shareDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ShareDocumentResult = new ShareDocumentResult({ validError: err });
                output.writeMessageBegin("shareDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ShareDocumentResult = new ShareDocumentResult({ error: err });
                output.writeMessageBegin("shareDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("shareDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_revokeDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RevokeDocumentArgs = RevokeDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.revokeDocument(args.token, args.documentId, args.usersOrGroups, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RevokeDocumentResult = new RevokeDocumentResult({ success: data });
            output.writeMessageBegin("revokeDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: RevokeDocumentResult = new RevokeDocumentResult({ validError: err });
                output.writeMessageBegin("revokeDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: RevokeDocumentResult = new RevokeDocumentResult({ error: err });
                output.writeMessageBegin("revokeDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("revokeDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllDocumentSharings(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<core.UserOrGroup>>((resolve, reject): void => {
            try {
                const args: GetAllDocumentSharingsArgs = GetAllDocumentSharingsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllDocumentSharings(args.token, args.documentId, args.accessPolicy, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<core.UserOrGroup>): void => {
            const result: GetAllDocumentSharingsResult = new GetAllDocumentSharingsResult({ success: data });
            output.writeMessageBegin("getAllDocumentSharings", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllDocumentSharingsResult = new GetAllDocumentSharingsResult({ validError: err });
                output.writeMessageBegin("getAllDocumentSharings", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllDocumentSharingsResult = new GetAllDocumentSharingsResult({ error: err });
                output.writeMessageBegin("getAllDocumentSharings", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllDocumentSharings", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllDocumentReassign(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocumentReassign.DocumentReassign>>((resolve, reject): void => {
            try {
                const args: GetAllDocumentReassignArgs = GetAllDocumentReassignArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllDocumentReassign(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocumentReassign.DocumentReassign>): void => {
            const result: GetAllDocumentReassignResult = new GetAllDocumentReassignResult({ success: data });
            output.writeMessageBegin("getAllDocumentReassign", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllDocumentReassignResult = new GetAllDocumentReassignResult({ validError: err });
                output.writeMessageBegin("getAllDocumentReassign", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllDocumentReassignResult = new GetAllDocumentReassignResult({ error: err });
                output.writeMessageBegin("getAllDocumentReassign", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllDocumentReassign", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_reassignDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocumentExecution.DocumentExecution>>((resolve, reject): void => {
            try {
                const args: ReassignDocumentArgs = ReassignDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.reassignDocument(args.token, args.documentId, args.documentReassign, args.cardId, args.signature));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocumentExecution.DocumentExecution>): void => {
            const result: ReassignDocumentResult = new ReassignDocumentResult({ success: data });
            output.writeMessageBegin("reassignDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ReassignDocumentResult = new ReassignDocumentResult({ validError: err });
                output.writeMessageBegin("reassignDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ReassignDocumentResult = new ReassignDocumentResult({ error: err });
                output.writeMessageBegin("reassignDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("reassignDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_reassignDocumentUsingServerKeyStorage(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocumentExecution.DocumentExecution>>((resolve, reject): void => {
            try {
                const args: ReassignDocumentUsingServerKeyStorageArgs = ReassignDocumentUsingServerKeyStorageArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.reassignDocumentUsingServerKeyStorage(args.token, args.documentId, args.documentReassign, args.cardId, args.pKeyId, args.password));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocumentExecution.DocumentExecution>): void => {
            const result: ReassignDocumentUsingServerKeyStorageResult = new ReassignDocumentUsingServerKeyStorageResult({ success: data });
            output.writeMessageBegin("reassignDocumentUsingServerKeyStorage", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ReassignDocumentUsingServerKeyStorageResult = new ReassignDocumentUsingServerKeyStorageResult({ validError: err });
                output.writeMessageBegin("reassignDocumentUsingServerKeyStorage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ReassignDocumentUsingServerKeyStorageResult = new ReassignDocumentUsingServerKeyStorageResult({ error: err });
                output.writeMessageBegin("reassignDocumentUsingServerKeyStorage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("reassignDocumentUsingServerKeyStorage", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_reassignDocumentExt(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocumentExecution.DocumentExecution>>((resolve, reject): void => {
            try {
                const args: ReassignDocumentExtArgs = ReassignDocumentExtArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.reassignDocumentExt(args.token, args.documentId, args.cardId, args.documentReassign, args.addSignToReasign));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocumentExecution.DocumentExecution>): void => {
            const result: ReassignDocumentExtResult = new ReassignDocumentExtResult({ success: data });
            output.writeMessageBegin("reassignDocumentExt", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ReassignDocumentExtResult = new ReassignDocumentExtResult({ validError: err });
                output.writeMessageBegin("reassignDocumentExt", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ReassignDocumentExtResult = new ReassignDocumentExtResult({ error: err });
                output.writeMessageBegin("reassignDocumentExt", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("reassignDocumentExt", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_revokeChildCards(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RevokeChildCardsArgs = RevokeChildCardsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.revokeChildCards(args.token, args.cardId, args.deleteCard, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RevokeChildCardsResult = new RevokeChildCardsResult({ success: data });
            output.writeMessageBegin("revokeChildCards", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: RevokeChildCardsResult = new RevokeChildCardsResult({ validError: err });
                output.writeMessageBegin("revokeChildCards", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: RevokeChildCardsResult = new RevokeChildCardsResult({ error: err });
                output.writeMessageBegin("revokeChildCards", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("revokeChildCards", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createOrUpdateAutomaticDocumentReassign(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<DocumentReassign.DocumentReassign>((resolve, reject): void => {
            try {
                const args: CreateOrUpdateAutomaticDocumentReassignArgs = CreateOrUpdateAutomaticDocumentReassignArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createOrUpdateAutomaticDocumentReassign(args.token, args.documentReassign));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DocumentReassign.DocumentReassign): void => {
            const result: CreateOrUpdateAutomaticDocumentReassignResult = new CreateOrUpdateAutomaticDocumentReassignResult({ success: data });
            output.writeMessageBegin("createOrUpdateAutomaticDocumentReassign", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CreateOrUpdateAutomaticDocumentReassignResult = new CreateOrUpdateAutomaticDocumentReassignResult({ validError: err });
                output.writeMessageBegin("createOrUpdateAutomaticDocumentReassign", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CreateOrUpdateAutomaticDocumentReassignResult = new CreateOrUpdateAutomaticDocumentReassignResult({ error: err });
                output.writeMessageBegin("createOrUpdateAutomaticDocumentReassign", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createOrUpdateAutomaticDocumentReassign", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_deleteAutomaticDocumentReassign(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: DeleteAutomaticDocumentReassignArgs = DeleteAutomaticDocumentReassignArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteAutomaticDocumentReassign(args.token, args.documentReassignId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: DeleteAutomaticDocumentReassignResult = new DeleteAutomaticDocumentReassignResult({ success: data });
            output.writeMessageBegin("deleteAutomaticDocumentReassign", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: DeleteAutomaticDocumentReassignResult = new DeleteAutomaticDocumentReassignResult({ validError: err });
                output.writeMessageBegin("deleteAutomaticDocumentReassign", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: DeleteAutomaticDocumentReassignResult = new DeleteAutomaticDocumentReassignResult({ error: err });
                output.writeMessageBegin("deleteAutomaticDocumentReassign", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("deleteAutomaticDocumentReassign", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeReassignControl(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<DocumentExecution.DocumentExecution>((resolve, reject): void => {
            try {
                const args: ChangeReassignControlArgs = ChangeReassignControlArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeReassignControl(args.token, args.documentExecutionId, args.userId, args.reassignType));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DocumentExecution.DocumentExecution): void => {
            const result: ChangeReassignControlResult = new ChangeReassignControlResult({ success: data });
            output.writeMessageBegin("changeReassignControl", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeReassignControlResult = new ChangeReassignControlResult({ validError: err });
                output.writeMessageBegin("changeReassignControl", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeReassignControlResult = new ChangeReassignControlResult({ error: err });
                output.writeMessageBegin("changeReassignControl", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeReassignControl", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllDocumentExecutions(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocumentExecution.DocumentExecution>>((resolve, reject): void => {
            try {
                const args: GetAllDocumentExecutionsArgs = GetAllDocumentExecutionsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllDocumentExecutions(args.token, args.documentId, args.stageId, args.typeLink, args.filter, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocumentExecution.DocumentExecution>): void => {
            const result: GetAllDocumentExecutionsResult = new GetAllDocumentExecutionsResult({ success: data });
            output.writeMessageBegin("getAllDocumentExecutions", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllDocumentExecutionsResult = new GetAllDocumentExecutionsResult({ validError: err });
                output.writeMessageBegin("getAllDocumentExecutions", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllDocumentExecutionsResult = new GetAllDocumentExecutionsResult({ error: err });
                output.writeMessageBegin("getAllDocumentExecutions", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllDocumentExecutions", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getDocumentExecution(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<DocumentExecution.DocumentExecution>((resolve, reject): void => {
            try {
                const args: GetDocumentExecutionArgs = GetDocumentExecutionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getDocumentExecution(args.token, args.docExecutionId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DocumentExecution.DocumentExecution): void => {
            const result: GetDocumentExecutionResult = new GetDocumentExecutionResult({ success: data });
            output.writeMessageBegin("getDocumentExecution", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetDocumentExecutionResult = new GetDocumentExecutionResult({ validError: err });
                output.writeMessageBegin("getDocumentExecution", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetDocumentExecutionResult = new GetDocumentExecutionResult({ error: err });
                output.writeMessageBegin("getDocumentExecution", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getDocumentExecution", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeExecutorsForDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeExecutorsForDocumentArgs = ChangeExecutorsForDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeExecutorsForDocument(args.token, args.docId, args.toAdd, args.toClose, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeExecutorsForDocumentResult = new ChangeExecutorsForDocumentResult({ success: data });
            output.writeMessageBegin("changeExecutorsForDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeExecutorsForDocumentResult = new ChangeExecutorsForDocumentResult({ validError: err });
                output.writeMessageBegin("changeExecutorsForDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeExecutorsForDocumentResult = new ChangeExecutorsForDocumentResult({ error: err });
                output.writeMessageBegin("changeExecutorsForDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeExecutorsForDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createAttachmentFrom(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<Attachment.Attachment>>((resolve, reject): void => {
            try {
                const args: CreateAttachmentFromArgs = CreateAttachmentFromArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createAttachmentFrom(args.token, args.documentId, args.cardId, args.accessPolicy, args.attCreateInfoList, args.processingType));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<Attachment.Attachment>): void => {
            const result: CreateAttachmentFromResult = new CreateAttachmentFromResult({ success: data });
            output.writeMessageBegin("createAttachmentFrom", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CreateAttachmentFromResult = new CreateAttachmentFromResult({ validError: err });
                output.writeMessageBegin("createAttachmentFrom", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CreateAttachmentFromResult = new CreateAttachmentFromResult({ error: err });
                output.writeMessageBegin("createAttachmentFrom", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createAttachmentFrom", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createLoadableAttachment(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: CreateLoadableAttachmentArgs = CreateLoadableAttachmentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createLoadableAttachment(args.token, args.documentId, args.fileName, args.totalSize, args.countPortions, args.cardId, args.attachmmentId, args.forDraft, args.accessPolicy, args.editMode, args.extStatus));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: CreateLoadableAttachmentResult = new CreateLoadableAttachmentResult({ success: data });
            output.writeMessageBegin("createLoadableAttachment", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CreateLoadableAttachmentResult = new CreateLoadableAttachmentResult({ validError: err });
                output.writeMessageBegin("createLoadableAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CreateLoadableAttachmentResult = new CreateLoadableAttachmentResult({ error: err });
                output.writeMessageBegin("createLoadableAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createLoadableAttachment", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_uploadDocumentAttachmentPortions(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Attachment.Attachment>((resolve, reject): void => {
            try {
                const args: UploadDocumentAttachmentPortionsArgs = UploadDocumentAttachmentPortionsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.uploadDocumentAttachmentPortions(args.token, args.attachmentId, args.numberPortion, args.fileContentBytes));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Attachment.Attachment): void => {
            const result: UploadDocumentAttachmentPortionsResult = new UploadDocumentAttachmentPortionsResult({ success: data });
            output.writeMessageBegin("uploadDocumentAttachmentPortions", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: UploadDocumentAttachmentPortionsResult = new UploadDocumentAttachmentPortionsResult({ validError: err });
                output.writeMessageBegin("uploadDocumentAttachmentPortions", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: UploadDocumentAttachmentPortionsResult = new UploadDocumentAttachmentPortionsResult({ error: err });
                output.writeMessageBegin("uploadDocumentAttachmentPortions", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("uploadDocumentAttachmentPortions", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_addPreviewToAttachment(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Attachment.Attachment>((resolve, reject): void => {
            try {
                const args: AddPreviewToAttachmentArgs = AddPreviewToAttachmentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.addPreviewToAttachment(args.token, args.attachmentId, args.previewContent, args.attachmentType, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Attachment.Attachment): void => {
            const result: AddPreviewToAttachmentResult = new AddPreviewToAttachmentResult({ success: data });
            output.writeMessageBegin("addPreviewToAttachment", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: AddPreviewToAttachmentResult = new AddPreviewToAttachmentResult({ validError: err });
                output.writeMessageBegin("addPreviewToAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: AddPreviewToAttachmentResult = new AddPreviewToAttachmentResult({ error: err });
                output.writeMessageBegin("addPreviewToAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addPreviewToAttachment", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_writeHistoryOpenAttachment(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: WriteHistoryOpenAttachmentArgs = WriteHistoryOpenAttachmentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.writeHistoryOpenAttachment(args.token, args.attachmentId, args.attachmentType, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: WriteHistoryOpenAttachmentResult = new WriteHistoryOpenAttachmentResult({ success: data });
            output.writeMessageBegin("writeHistoryOpenAttachment", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: WriteHistoryOpenAttachmentResult = new WriteHistoryOpenAttachmentResult({ validError: err });
                output.writeMessageBegin("writeHistoryOpenAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: WriteHistoryOpenAttachmentResult = new WriteHistoryOpenAttachmentResult({ error: err });
                output.writeMessageBegin("writeHistoryOpenAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("writeHistoryOpenAttachment", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_downloadDocumentAttachment(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Buffer>((resolve, reject): void => {
            try {
                const args: DownloadDocumentAttachmentArgs = DownloadDocumentAttachmentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.downloadDocumentAttachment(args.token, args.attachmentId, args.attachmentType, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Buffer): void => {
            const result: DownloadDocumentAttachmentResult = new DownloadDocumentAttachmentResult({ success: data });
            output.writeMessageBegin("downloadDocumentAttachment", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: DownloadDocumentAttachmentResult = new DownloadDocumentAttachmentResult({ validError: err });
                output.writeMessageBegin("downloadDocumentAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: DownloadDocumentAttachmentResult = new DownloadDocumentAttachmentResult({ error: err });
                output.writeMessageBegin("downloadDocumentAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("downloadDocumentAttachment", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_rotatePdfPages(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RotatePdfPagesArgs = RotatePdfPagesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.rotatePdfPages(args.token, args.attachmentId, args.pages, args.angle, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RotatePdfPagesResult = new RotatePdfPagesResult({ success: data });
            output.writeMessageBegin("rotatePdfPages", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: RotatePdfPagesResult = new RotatePdfPagesResult({ validError: err });
                output.writeMessageBegin("rotatePdfPages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: RotatePdfPagesResult = new RotatePdfPagesResult({ error: err });
                output.writeMessageBegin("rotatePdfPages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("rotatePdfPages", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_addAttachmentsToDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: AddAttachmentsToDocumentArgs = AddAttachmentsToDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.addAttachmentsToDocument(args.token, args.documentId, args.attachments, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: AddAttachmentsToDocumentResult = new AddAttachmentsToDocumentResult({ success: data });
            output.writeMessageBegin("addAttachmentsToDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: AddAttachmentsToDocumentResult = new AddAttachmentsToDocumentResult({ validError: err });
                output.writeMessageBegin("addAttachmentsToDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: AddAttachmentsToDocumentResult = new AddAttachmentsToDocumentResult({ error: err });
                output.writeMessageBegin("addAttachmentsToDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addAttachmentsToDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeDocumentAttachment(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemoveDocumentAttachmentArgs = RemoveDocumentAttachmentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeDocumentAttachment(args.token, args.attachmentId, args.removeOldVersions, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemoveDocumentAttachmentResult = new RemoveDocumentAttachmentResult({ success: data });
            output.writeMessageBegin("removeDocumentAttachment", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: RemoveDocumentAttachmentResult = new RemoveDocumentAttachmentResult({ validError: err });
                output.writeMessageBegin("removeDocumentAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: RemoveDocumentAttachmentResult = new RemoveDocumentAttachmentResult({ error: err });
                output.writeMessageBegin("removeDocumentAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeDocumentAttachment", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_markAsWaitForPublish(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: MarkAsWaitForPublishArgs = MarkAsWaitForPublishArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.markAsWaitForPublish(args.token, args.attachmentId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: MarkAsWaitForPublishResult = new MarkAsWaitForPublishResult({ success: data });
            output.writeMessageBegin("markAsWaitForPublish", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: MarkAsWaitForPublishResult = new MarkAsWaitForPublishResult({ validError: err });
                output.writeMessageBegin("markAsWaitForPublish", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: MarkAsWaitForPublishResult = new MarkAsWaitForPublishResult({ error: err });
                output.writeMessageBegin("markAsWaitForPublish", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("markAsWaitForPublish", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeAttachmentEditMode(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Attachment.Attachment>((resolve, reject): void => {
            try {
                const args: ChangeAttachmentEditModeArgs = ChangeAttachmentEditModeArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeAttachmentEditMode(args.token, args.attachmentId, args.editMode));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Attachment.Attachment): void => {
            const result: ChangeAttachmentEditModeResult = new ChangeAttachmentEditModeResult({ success: data });
            output.writeMessageBegin("changeAttachmentEditMode", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeAttachmentEditModeResult = new ChangeAttachmentEditModeResult({ validError: err });
                output.writeMessageBegin("changeAttachmentEditMode", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeAttachmentEditModeResult = new ChangeAttachmentEditModeResult({ error: err });
                output.writeMessageBegin("changeAttachmentEditMode", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeAttachmentEditMode", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getDocumentAttachments(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<Attachment.Attachment>>((resolve, reject): void => {
            try {
                const args: GetDocumentAttachmentsArgs = GetDocumentAttachmentsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getDocumentAttachments(args.token, args.documentId, args.latestOnly, args.filter, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<Attachment.Attachment>): void => {
            const result: GetDocumentAttachmentsResult = new GetDocumentAttachmentsResult({ success: data });
            output.writeMessageBegin("getDocumentAttachments", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetDocumentAttachmentsResult = new GetDocumentAttachmentsResult({ validError: err });
                output.writeMessageBegin("getDocumentAttachments", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetDocumentAttachmentsResult = new GetDocumentAttachmentsResult({ error: err });
                output.writeMessageBegin("getDocumentAttachments", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getDocumentAttachments", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getDocumentAttachmentById(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Attachment.Attachment>((resolve, reject): void => {
            try {
                const args: GetDocumentAttachmentByIdArgs = GetDocumentAttachmentByIdArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getDocumentAttachmentById(args.token, args.attachmentId, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Attachment.Attachment): void => {
            const result: GetDocumentAttachmentByIdResult = new GetDocumentAttachmentByIdResult({ success: data });
            output.writeMessageBegin("getDocumentAttachmentById", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetDocumentAttachmentByIdResult = new GetDocumentAttachmentByIdResult({ validError: err });
                output.writeMessageBegin("getDocumentAttachmentById", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetDocumentAttachmentByIdResult = new GetDocumentAttachmentByIdResult({ error: err });
                output.writeMessageBegin("getDocumentAttachmentById", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getDocumentAttachmentById", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllDocumentAttachmentVersions(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<Attachment.Attachment>>((resolve, reject): void => {
            try {
                const args: GetAllDocumentAttachmentVersionsArgs = GetAllDocumentAttachmentVersionsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllDocumentAttachmentVersions(args.token, args.attachmentId, args.filter, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<Attachment.Attachment>): void => {
            const result: GetAllDocumentAttachmentVersionsResult = new GetAllDocumentAttachmentVersionsResult({ success: data });
            output.writeMessageBegin("getAllDocumentAttachmentVersions", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllDocumentAttachmentVersionsResult = new GetAllDocumentAttachmentVersionsResult({ validError: err });
                output.writeMessageBegin("getAllDocumentAttachmentVersions", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllDocumentAttachmentVersionsResult = new GetAllDocumentAttachmentVersionsResult({ error: err });
                output.writeMessageBegin("getAllDocumentAttachmentVersions", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllDocumentAttachmentVersions", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeAttachmentsVisibility(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeAttachmentsVisibilityArgs = ChangeAttachmentsVisibilityArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeAttachmentsVisibility(args.token, args.toHideList, args.toShowList));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeAttachmentsVisibilityResult = new ChangeAttachmentsVisibilityResult({ success: data });
            output.writeMessageBegin("changeAttachmentsVisibility", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeAttachmentsVisibilityResult = new ChangeAttachmentsVisibilityResult({ validError: err });
                output.writeMessageBegin("changeAttachmentsVisibility", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeAttachmentsVisibilityResult = new ChangeAttachmentsVisibilityResult({ error: err });
                output.writeMessageBegin("changeAttachmentsVisibility", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeAttachmentsVisibility", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createOrUpdateDocumentComment(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<DocumentComment.DocumentComment>((resolve, reject): void => {
            try {
                const args: CreateOrUpdateDocumentCommentArgs = CreateOrUpdateDocumentCommentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createOrUpdateDocumentComment(args.token, args.documentComment, args.addToComment, args.changeType, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DocumentComment.DocumentComment): void => {
            const result: CreateOrUpdateDocumentCommentResult = new CreateOrUpdateDocumentCommentResult({ success: data });
            output.writeMessageBegin("createOrUpdateDocumentComment", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CreateOrUpdateDocumentCommentResult = new CreateOrUpdateDocumentCommentResult({ validError: err });
                output.writeMessageBegin("createOrUpdateDocumentComment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CreateOrUpdateDocumentCommentResult = new CreateOrUpdateDocumentCommentResult({ error: err });
                output.writeMessageBegin("createOrUpdateDocumentComment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createOrUpdateDocumentComment", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllDocumentComments(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocumentComment.DocumentComment>>((resolve, reject): void => {
            try {
                const args: GetAllDocumentCommentsArgs = GetAllDocumentCommentsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllDocumentComments(args.token, args.documentId, args.filter, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocumentComment.DocumentComment>): void => {
            const result: GetAllDocumentCommentsResult = new GetAllDocumentCommentsResult({ success: data });
            output.writeMessageBegin("getAllDocumentComments", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllDocumentCommentsResult = new GetAllDocumentCommentsResult({ validError: err });
                output.writeMessageBegin("getAllDocumentComments", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllDocumentCommentsResult = new GetAllDocumentCommentsResult({ error: err });
                output.writeMessageBegin("getAllDocumentComments", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllDocumentComments", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_deleteDocumentComment(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: DeleteDocumentCommentArgs = DeleteDocumentCommentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteDocumentComment(args.token, args.documentCommentId, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: DeleteDocumentCommentResult = new DeleteDocumentCommentResult({ success: data });
            output.writeMessageBegin("deleteDocumentComment", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: DeleteDocumentCommentResult = new DeleteDocumentCommentResult({ validError: err });
                output.writeMessageBegin("deleteDocumentComment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: DeleteDocumentCommentResult = new DeleteDocumentCommentResult({ error: err });
                output.writeMessageBegin("deleteDocumentComment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("deleteDocumentComment", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createOrUpdateDocumentContentHolderLink(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<ContentHolderShowPlace.ContentHolderShowPlace>>((resolve, reject): void => {
            try {
                const args: CreateOrUpdateDocumentContentHolderLinkArgs = CreateOrUpdateDocumentContentHolderLinkArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createOrUpdateDocumentContentHolderLink(args.token, args.documentId, args.holderLinks, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<ContentHolderShowPlace.ContentHolderShowPlace>): void => {
            const result: CreateOrUpdateDocumentContentHolderLinkResult = new CreateOrUpdateDocumentContentHolderLinkResult({ success: data });
            output.writeMessageBegin("createOrUpdateDocumentContentHolderLink", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CreateOrUpdateDocumentContentHolderLinkResult = new CreateOrUpdateDocumentContentHolderLinkResult({ validError: err });
                output.writeMessageBegin("createOrUpdateDocumentContentHolderLink", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CreateOrUpdateDocumentContentHolderLinkResult = new CreateOrUpdateDocumentContentHolderLinkResult({ error: err });
                output.writeMessageBegin("createOrUpdateDocumentContentHolderLink", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createOrUpdateDocumentContentHolderLink", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_documentToArchive(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: DocumentToArchiveArgs = DocumentToArchiveArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.documentToArchive(args.token, args.documentId, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: DocumentToArchiveResult = new DocumentToArchiveResult({ success: data });
            output.writeMessageBegin("documentToArchive", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: DocumentToArchiveResult = new DocumentToArchiveResult({ validError: err });
                output.writeMessageBegin("documentToArchive", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: DocumentToArchiveResult = new DocumentToArchiveResult({ error: err });
                output.writeMessageBegin("documentToArchive", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("documentToArchive", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllResponsibleForDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Set<core.UserOrGroup>>((resolve, reject): void => {
            try {
                const args: GetAllResponsibleForDocumentArgs = GetAllResponsibleForDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllResponsibleForDocument(args.token, args.documentId, args.accessPolicy, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Set<core.UserOrGroup>): void => {
            const result: GetAllResponsibleForDocumentResult = new GetAllResponsibleForDocumentResult({ success: data });
            output.writeMessageBegin("getAllResponsibleForDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllResponsibleForDocumentResult = new GetAllResponsibleForDocumentResult({ validError: err });
                output.writeMessageBegin("getAllResponsibleForDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllResponsibleForDocumentResult = new GetAllResponsibleForDocumentResult({ error: err });
                output.writeMessageBegin("getAllResponsibleForDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllResponsibleForDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_addResponsibleForDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: AddResponsibleForDocumentArgs = AddResponsibleForDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.addResponsibleForDocument(args.token, args.documentId, args.users, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: AddResponsibleForDocumentResult = new AddResponsibleForDocumentResult({ success: data });
            output.writeMessageBegin("addResponsibleForDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: AddResponsibleForDocumentResult = new AddResponsibleForDocumentResult({ validError: err });
                output.writeMessageBegin("addResponsibleForDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: AddResponsibleForDocumentResult = new AddResponsibleForDocumentResult({ error: err });
                output.writeMessageBegin("addResponsibleForDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addResponsibleForDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeResponsibleForDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemoveResponsibleForDocumentArgs = RemoveResponsibleForDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeResponsibleForDocument(args.token, args.documentId, args.users, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemoveResponsibleForDocumentResult = new RemoveResponsibleForDocumentResult({ success: data });
            output.writeMessageBegin("removeResponsibleForDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: RemoveResponsibleForDocumentResult = new RemoveResponsibleForDocumentResult({ validError: err });
                output.writeMessageBegin("removeResponsibleForDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: RemoveResponsibleForDocumentResult = new RemoveResponsibleForDocumentResult({ error: err });
                output.writeMessageBegin("removeResponsibleForDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeResponsibleForDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getDocHistoryPage(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<HistoryPage.HistoryPage>((resolve, reject): void => {
            try {
                const args: GetDocHistoryPageArgs = GetDocHistoryPageArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getDocHistoryPage(args.token, args.documentId, args.accessPolicy, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: HistoryPage.HistoryPage): void => {
            const result: GetDocHistoryPageResult = new GetDocHistoryPageResult({ success: data });
            output.writeMessageBegin("getDocHistoryPage", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetDocHistoryPageResult = new GetDocHistoryPageResult({ validError: err });
                output.writeMessageBegin("getDocHistoryPage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetDocHistoryPageResult = new GetDocHistoryPageResult({ error: err });
                output.writeMessageBegin("getDocHistoryPage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getDocHistoryPage", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllNews(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<core.News>>((resolve, reject): void => {
            try {
                const args: GetAllNewsArgs = GetAllNewsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllNews(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<core.News>): void => {
            const result: GetAllNewsResult = new GetAllNewsResult({ success: data });
            output.writeMessageBegin("getAllNews", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllNewsResult = new GetAllNewsResult({ validError: err });
                output.writeMessageBegin("getAllNews", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllNewsResult = new GetAllNewsResult({ error: err });
                output.writeMessageBegin("getAllNews", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllNews", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getTasksByDate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Map<TodayTaskType.TodayTaskType, number>>((resolve, reject): void => {
            try {
                const args: GetTasksByDateArgs = GetTasksByDateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getTasksByDate(args.token, args.date));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Map<TodayTaskType.TodayTaskType, number>): void => {
            const result: GetTasksByDateResult = new GetTasksByDateResult({ success: data });
            output.writeMessageBegin("getTasksByDate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetTasksByDateResult = new GetTasksByDateResult({ validError: err });
                output.writeMessageBegin("getTasksByDate", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetTasksByDateResult = new GetTasksByDateResult({ error: err });
                output.writeMessageBegin("getTasksByDate", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getTasksByDate", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_generateDocumentNumber(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: GenerateDocumentNumberArgs = GenerateDocumentNumberArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.generateDocumentNumber(args.token, args.documentId, args.docNumber, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: GenerateDocumentNumberResult = new GenerateDocumentNumberResult({ success: data });
            output.writeMessageBegin("generateDocumentNumber", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GenerateDocumentNumberResult = new GenerateDocumentNumberResult({ validError: err });
                output.writeMessageBegin("generateDocumentNumber", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GenerateDocumentNumberResult = new GenerateDocumentNumberResult({ error: err });
                output.writeMessageBegin("generateDocumentNumber", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("generateDocumentNumber", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_setDocumentViewed(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: SetDocumentViewedArgs = SetDocumentViewedArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setDocumentViewed(args.token, args.documentId, args.viewed, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: SetDocumentViewedResult = new SetDocumentViewedResult({ success: data });
            output.writeMessageBegin("setDocumentViewed", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: SetDocumentViewedResult = new SetDocumentViewedResult({ validError: err });
                output.writeMessageBegin("setDocumentViewed", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: SetDocumentViewedResult = new SetDocumentViewedResult({ error: err });
                output.writeMessageBegin("setDocumentViewed", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("setDocumentViewed", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllDocumentRelations(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocumentRelation.DocumentRelation>>((resolve, reject): void => {
            try {
                const args: GetAllDocumentRelationsArgs = GetAllDocumentRelationsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllDocumentRelations(args.token, args.documentId, args.filter, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocumentRelation.DocumentRelation>): void => {
            const result: GetAllDocumentRelationsResult = new GetAllDocumentRelationsResult({ success: data });
            output.writeMessageBegin("getAllDocumentRelations", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllDocumentRelationsResult = new GetAllDocumentRelationsResult({ validError: err });
                output.writeMessageBegin("getAllDocumentRelations", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllDocumentRelationsResult = new GetAllDocumentRelationsResult({ error: err });
                output.writeMessageBegin("getAllDocumentRelations", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllDocumentRelations", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeRelations(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocumentRelation.DocumentRelation>>((resolve, reject): void => {
            try {
                const args: ChangeRelationsArgs = ChangeRelationsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeRelations(args.token, args.toCreate, args.toRemove));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocumentRelation.DocumentRelation>): void => {
            const result: ChangeRelationsResult = new ChangeRelationsResult({ success: data });
            output.writeMessageBegin("changeRelations", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeRelationsResult = new ChangeRelationsResult({ validError: err });
                output.writeMessageBegin("changeRelations", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeRelationsResult = new ChangeRelationsResult({ error: err });
                output.writeMessageBegin("changeRelations", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeRelations", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeSubStatus(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeSubStatusArgs = ChangeSubStatusArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeSubStatus(args.token, args.documentId, args.subStatus, args.comment, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeSubStatusResult = new ChangeSubStatusResult({ success: data });
            output.writeMessageBegin("changeSubStatus", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeSubStatusResult = new ChangeSubStatusResult({ validError: err });
                output.writeMessageBegin("changeSubStatus", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeSubStatusResult = new ChangeSubStatusResult({ error: err });
                output.writeMessageBegin("changeSubStatus", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeSubStatus", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_revertSubStatus(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RevertSubStatusArgs = RevertSubStatusArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.revertSubStatus(args.token, args.documentId, args.subStatus, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RevertSubStatusResult = new RevertSubStatusResult({ success: data });
            output.writeMessageBegin("revertSubStatus", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: RevertSubStatusResult = new RevertSubStatusResult({ validError: err });
                output.writeMessageBegin("revertSubStatus", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: RevertSubStatusResult = new RevertSubStatusResult({ error: err });
                output.writeMessageBegin("revertSubStatus", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("revertSubStatus", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_increaseDeadlineForDocumentOrDocumentExecution(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: IncreaseDeadlineForDocumentOrDocumentExecutionArgs = IncreaseDeadlineForDocumentOrDocumentExecutionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.increaseDeadlineForDocumentOrDocumentExecution(args.token, args.documentId, args.documentExecution, args.deadlineTime, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: IncreaseDeadlineForDocumentOrDocumentExecutionResult = new IncreaseDeadlineForDocumentOrDocumentExecutionResult({ success: data });
            output.writeMessageBegin("increaseDeadlineForDocumentOrDocumentExecution", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: IncreaseDeadlineForDocumentOrDocumentExecutionResult = new IncreaseDeadlineForDocumentOrDocumentExecutionResult({ validError: err });
                output.writeMessageBegin("increaseDeadlineForDocumentOrDocumentExecution", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: IncreaseDeadlineForDocumentOrDocumentExecutionResult = new IncreaseDeadlineForDocumentOrDocumentExecutionResult({ error: err });
                output.writeMessageBegin("increaseDeadlineForDocumentOrDocumentExecution", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("increaseDeadlineForDocumentOrDocumentExecution", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_addAdditionalConfirmers(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: AddAdditionalConfirmersArgs = AddAdditionalConfirmersArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.addAdditionalConfirmers(args.token, args.cardId, args.users, args.deadlineDate, args.comment, args.requireMyParticipation, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: AddAdditionalConfirmersResult = new AddAdditionalConfirmersResult({ success: data });
            output.writeMessageBegin("addAdditionalConfirmers", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: AddAdditionalConfirmersResult = new AddAdditionalConfirmersResult({ validError: err });
                output.writeMessageBegin("addAdditionalConfirmers", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: AddAdditionalConfirmersResult = new AddAdditionalConfirmersResult({ error: err });
                output.writeMessageBegin("addAdditionalConfirmers", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addAdditionalConfirmers", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_setAdditionalDecision(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Document.Document>((resolve, reject): void => {
            try {
                const args: SetAdditionalDecisionArgs = SetAdditionalDecisionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setAdditionalDecision(args.token, args.userDecision, args.cardId, args.comment, args.returnToParentStage, args.signature));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Document.Document): void => {
            const result: SetAdditionalDecisionResult = new SetAdditionalDecisionResult({ success: data });
            output.writeMessageBegin("setAdditionalDecision", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: SetAdditionalDecisionResult = new SetAdditionalDecisionResult({ validError: err });
                output.writeMessageBegin("setAdditionalDecision", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: SetAdditionalDecisionResult = new SetAdditionalDecisionResult({ error: err });
                output.writeMessageBegin("setAdditionalDecision", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("setAdditionalDecision", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_setAdditionalDecisionUsingServerKeyStorage(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Document.Document>((resolve, reject): void => {
            try {
                const args: SetAdditionalDecisionUsingServerKeyStorageArgs = SetAdditionalDecisionUsingServerKeyStorageArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setAdditionalDecisionUsingServerKeyStorage(args.token, args.userDecision, args.cardId, args.comment, args.returnToParentStage, args.pKeyId, args.password));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Document.Document): void => {
            const result: SetAdditionalDecisionUsingServerKeyStorageResult = new SetAdditionalDecisionUsingServerKeyStorageResult({ success: data });
            output.writeMessageBegin("setAdditionalDecisionUsingServerKeyStorage", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: SetAdditionalDecisionUsingServerKeyStorageResult = new SetAdditionalDecisionUsingServerKeyStorageResult({ validError: err });
                output.writeMessageBegin("setAdditionalDecisionUsingServerKeyStorage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: SetAdditionalDecisionUsingServerKeyStorageResult = new SetAdditionalDecisionUsingServerKeyStorageResult({ error: err });
                output.writeMessageBegin("setAdditionalDecisionUsingServerKeyStorage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("setAdditionalDecisionUsingServerKeyStorage", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_setAdditionalDecisionExt(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Document.Document>((resolve, reject): void => {
            try {
                const args: SetAdditionalDecisionExtArgs = SetAdditionalDecisionExtArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setAdditionalDecisionExt(args.token, args.userMap, args.cardId, args.comment, args.returnToParentStage, args.signatures));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Document.Document): void => {
            const result: SetAdditionalDecisionExtResult = new SetAdditionalDecisionExtResult({ success: data });
            output.writeMessageBegin("setAdditionalDecisionExt", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: SetAdditionalDecisionExtResult = new SetAdditionalDecisionExtResult({ validError: err });
                output.writeMessageBegin("setAdditionalDecisionExt", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: SetAdditionalDecisionExtResult = new SetAdditionalDecisionExtResult({ error: err });
                output.writeMessageBegin("setAdditionalDecisionExt", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("setAdditionalDecisionExt", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_revokeDecision(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Document.Document>((resolve, reject): void => {
            try {
                const args: RevokeDecisionArgs = RevokeDecisionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.revokeDecision(args.token, args.documentReassign, args.cardId, args.comment));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Document.Document): void => {
            const result: RevokeDecisionResult = new RevokeDecisionResult({ success: data });
            output.writeMessageBegin("revokeDecision", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: RevokeDecisionResult = new RevokeDecisionResult({ validError: err });
                output.writeMessageBegin("revokeDecision", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: RevokeDecisionResult = new RevokeDecisionResult({ error: err });
                output.writeMessageBegin("revokeDecision", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("revokeDecision", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_markDecisionAsRemoved(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<DocumentExecution.DocumentExecution>((resolve, reject): void => {
            try {
                const args: MarkDecisionAsRemovedArgs = MarkDecisionAsRemovedArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.markDecisionAsRemoved(args.token, args.documentId, args.cardId, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DocumentExecution.DocumentExecution): void => {
            const result: MarkDecisionAsRemovedResult = new MarkDecisionAsRemovedResult({ success: data });
            output.writeMessageBegin("markDecisionAsRemoved", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: MarkDecisionAsRemovedResult = new MarkDecisionAsRemovedResult({ validError: err });
                output.writeMessageBegin("markDecisionAsRemoved", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: MarkDecisionAsRemovedResult = new MarkDecisionAsRemovedResult({ error: err });
                output.writeMessageBegin("markDecisionAsRemoved", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("markDecisionAsRemoved", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllOpenDocumentExecutionsStatistic(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Map<DocumentExecutionStatisticType.DocumentExecutionStatisticType, number>>((resolve, reject): void => {
            try {
                const args: GetAllOpenDocumentExecutionsStatisticArgs = GetAllOpenDocumentExecutionsStatisticArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllOpenDocumentExecutionsStatistic(args.token, args.userId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Map<DocumentExecutionStatisticType.DocumentExecutionStatisticType, number>): void => {
            const result: GetAllOpenDocumentExecutionsStatisticResult = new GetAllOpenDocumentExecutionsStatisticResult({ success: data });
            output.writeMessageBegin("getAllOpenDocumentExecutionsStatistic", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllOpenDocumentExecutionsStatisticResult = new GetAllOpenDocumentExecutionsStatisticResult({ validError: err });
                output.writeMessageBegin("getAllOpenDocumentExecutionsStatistic", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllOpenDocumentExecutionsStatisticResult = new GetAllOpenDocumentExecutionsStatisticResult({ error: err });
                output.writeMessageBegin("getAllOpenDocumentExecutionsStatistic", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllOpenDocumentExecutionsStatistic", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeControlForDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeControlForDocumentArgs = ChangeControlForDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeControlForDocument(args.token, args.documentId, args.control, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeControlForDocumentResult = new ChangeControlForDocumentResult({ success: data });
            output.writeMessageBegin("changeControlForDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeControlForDocumentResult = new ChangeControlForDocumentResult({ validError: err });
                output.writeMessageBegin("changeControlForDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeControlForDocumentResult = new ChangeControlForDocumentResult({ error: err });
                output.writeMessageBegin("changeControlForDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeControlForDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_addTagsToDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: AddTagsToDocumentArgs = AddTagsToDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.addTagsToDocument(args.token, args.docId, args.tags));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: AddTagsToDocumentResult = new AddTagsToDocumentResult({ success: data });
            output.writeMessageBegin("addTagsToDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: AddTagsToDocumentResult = new AddTagsToDocumentResult({ validError: err });
                output.writeMessageBegin("addTagsToDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: AddTagsToDocumentResult = new AddTagsToDocumentResult({ error: err });
                output.writeMessageBegin("addTagsToDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addTagsToDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeTagsToDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemoveTagsToDocumentArgs = RemoveTagsToDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeTagsToDocument(args.token, args.docId, args.tags));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemoveTagsToDocumentResult = new RemoveTagsToDocumentResult({ success: data });
            output.writeMessageBegin("removeTagsToDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: RemoveTagsToDocumentResult = new RemoveTagsToDocumentResult({ validError: err });
                output.writeMessageBegin("removeTagsToDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: RemoveTagsToDocumentResult = new RemoveTagsToDocumentResult({ error: err });
                output.writeMessageBegin("removeTagsToDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeTagsToDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_addExecutorsToStage(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocumentExecution.DocumentExecution>>((resolve, reject): void => {
            try {
                const args: AddExecutorsToStageArgs = AddExecutorsToStageArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.addExecutorsToStage(args.token, args.docId, args.documentReassign, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocumentExecution.DocumentExecution>): void => {
            const result: AddExecutorsToStageResult = new AddExecutorsToStageResult({ success: data });
            output.writeMessageBegin("addExecutorsToStage", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: AddExecutorsToStageResult = new AddExecutorsToStageResult({ validError: err });
                output.writeMessageBegin("addExecutorsToStage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: AddExecutorsToStageResult = new AddExecutorsToStageResult({ error: err });
                output.writeMessageBegin("addExecutorsToStage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addExecutorsToStage", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getCountDocsByFilterNoPermission(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Int64>((resolve, reject): void => {
            try {
                const args: GetCountDocsByFilterNoPermissionArgs = GetCountDocsByFilterNoPermissionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getCountDocsByFilterNoPermission(args.token, args.patternGroupId, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Int64): void => {
            const result: GetCountDocsByFilterNoPermissionResult = new GetCountDocsByFilterNoPermissionResult({ success: data });
            output.writeMessageBegin("getCountDocsByFilterNoPermission", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetCountDocsByFilterNoPermissionResult = new GetCountDocsByFilterNoPermissionResult({ validError: err });
                output.writeMessageBegin("getCountDocsByFilterNoPermission", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetCountDocsByFilterNoPermissionResult = new GetCountDocsByFilterNoPermissionResult({ error: err });
                output.writeMessageBegin("getCountDocsByFilterNoPermission", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getCountDocsByFilterNoPermission", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getTinyDocsByFilterNoPermission(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<Document.Document>>((resolve, reject): void => {
            try {
                const args: GetTinyDocsByFilterNoPermissionArgs = GetTinyDocsByFilterNoPermissionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getTinyDocsByFilterNoPermission(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<Document.Document>): void => {
            const result: GetTinyDocsByFilterNoPermissionResult = new GetTinyDocsByFilterNoPermissionResult({ success: data });
            output.writeMessageBegin("getTinyDocsByFilterNoPermission", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetTinyDocsByFilterNoPermissionResult = new GetTinyDocsByFilterNoPermissionResult({ validError: err });
                output.writeMessageBegin("getTinyDocsByFilterNoPermission", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetTinyDocsByFilterNoPermissionResult = new GetTinyDocsByFilterNoPermissionResult({ error: err });
                output.writeMessageBegin("getTinyDocsByFilterNoPermission", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getTinyDocsByFilterNoPermission", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeRegistrationInfoForDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeRegistrationInfoForDocumentArgs = ChangeRegistrationInfoForDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeRegistrationInfoForDocument(args.token, args.documentId, args.newRegistrationDate, args.newRegistrationNumber, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeRegistrationInfoForDocumentResult = new ChangeRegistrationInfoForDocumentResult({ success: data });
            output.writeMessageBegin("changeRegistrationInfoForDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeRegistrationInfoForDocumentResult = new ChangeRegistrationInfoForDocumentResult({ validError: err });
                output.writeMessageBegin("changeRegistrationInfoForDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeRegistrationInfoForDocumentResult = new ChangeRegistrationInfoForDocumentResult({ error: err });
                output.writeMessageBegin("changeRegistrationInfoForDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeRegistrationInfoForDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createChatForDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: CreateChatForDocumentArgs = CreateChatForDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createChatForDocument(args.token, args.documentId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: CreateChatForDocumentResult = new CreateChatForDocumentResult({ success: data });
            output.writeMessageBegin("createChatForDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CreateChatForDocumentResult = new CreateChatForDocumentResult({ validError: err });
                output.writeMessageBegin("createChatForDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CreateChatForDocumentResult = new CreateChatForDocumentResult({ error: err });
                output.writeMessageBegin("createChatForDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createChatForDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getDocumentExtShareList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocumentExtShare.DocumentExtShare>>((resolve, reject): void => {
            try {
                const args: GetDocumentExtShareListArgs = GetDocumentExtShareListArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getDocumentExtShareList(args.token, args.documentId, args.accessPolicy, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocumentExtShare.DocumentExtShare>): void => {
            const result: GetDocumentExtShareListResult = new GetDocumentExtShareListResult({ success: data });
            output.writeMessageBegin("getDocumentExtShareList", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetDocumentExtShareListResult = new GetDocumentExtShareListResult({ validError: err });
                output.writeMessageBegin("getDocumentExtShareList", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetDocumentExtShareListResult = new GetDocumentExtShareListResult({ error: err });
                output.writeMessageBegin("getDocumentExtShareList", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getDocumentExtShareList", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeDocumentExtShare(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocumentExtShare.DocumentExtShare>>((resolve, reject): void => {
            try {
                const args: ChangeDocumentExtShareArgs = ChangeDocumentExtShareArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeDocumentExtShare(args.token, args.documentId, args.accessPolicy, args.toAdd, args.toRemove));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocumentExtShare.DocumentExtShare>): void => {
            const result: ChangeDocumentExtShareResult = new ChangeDocumentExtShareResult({ success: data });
            output.writeMessageBegin("changeDocumentExtShare", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeDocumentExtShareResult = new ChangeDocumentExtShareResult({ validError: err });
                output.writeMessageBegin("changeDocumentExtShare", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeDocumentExtShareResult = new ChangeDocumentExtShareResult({ error: err });
                output.writeMessageBegin("changeDocumentExtShare", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeDocumentExtShare", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeAttachmentExtStatus(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeAttachmentExtStatusArgs = ChangeAttachmentExtStatusArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeAttachmentExtStatus(args.token, args.statusMap));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeAttachmentExtStatusResult = new ChangeAttachmentExtStatusResult({ success: data });
            output.writeMessageBegin("changeAttachmentExtStatus", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeAttachmentExtStatusResult = new ChangeAttachmentExtStatusResult({ validError: err });
                output.writeMessageBegin("changeAttachmentExtStatus", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeAttachmentExtStatusResult = new ChangeAttachmentExtStatusResult({ error: err });
                output.writeMessageBegin("changeAttachmentExtStatus", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeAttachmentExtStatus", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_remindDocumentExecutor(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemindDocumentExecutorArgs = RemindDocumentExecutorArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.remindDocumentExecutor(args.token, args.cardId, args.comment, args.policy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemindDocumentExecutorResult = new RemindDocumentExecutorResult({ success: data });
            output.writeMessageBegin("remindDocumentExecutor", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: RemindDocumentExecutorResult = new RemindDocumentExecutorResult({ validError: err });
                output.writeMessageBegin("remindDocumentExecutor", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: RemindDocumentExecutorResult = new RemindDocumentExecutorResult({ error: err });
                output.writeMessageBegin("remindDocumentExecutor", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("remindDocumentExecutor", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_updateReassignResolution(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: UpdateReassignResolutionArgs = UpdateReassignResolutionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.updateReassignResolution(args.token, args.cardId, args.resolution, args.policy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: UpdateReassignResolutionResult = new UpdateReassignResolutionResult({ success: data });
            output.writeMessageBegin("updateReassignResolution", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: UpdateReassignResolutionResult = new UpdateReassignResolutionResult({ validError: err });
                output.writeMessageBegin("updateReassignResolution", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: UpdateReassignResolutionResult = new UpdateReassignResolutionResult({ error: err });
                output.writeMessageBegin("updateReassignResolution", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("updateReassignResolution", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_updateSubStatusComment(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: UpdateSubStatusCommentArgs = UpdateSubStatusCommentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.updateSubStatusComment(args.token, args.docCommentId, args.comment, args.policy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: UpdateSubStatusCommentResult = new UpdateSubStatusCommentResult({ success: data });
            output.writeMessageBegin("updateSubStatusComment", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: UpdateSubStatusCommentResult = new UpdateSubStatusCommentResult({ validError: err });
                output.writeMessageBegin("updateSubStatusComment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: UpdateSubStatusCommentResult = new UpdateSubStatusCommentResult({ error: err });
                output.writeMessageBegin("updateSubStatusComment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("updateSubStatusComment", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeSubStatusComment(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemoveSubStatusCommentArgs = RemoveSubStatusCommentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeSubStatusComment(args.token, args.docCommentId, args.policy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemoveSubStatusCommentResult = new RemoveSubStatusCommentResult({ success: data });
            output.writeMessageBegin("removeSubStatusComment", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: RemoveSubStatusCommentResult = new RemoveSubStatusCommentResult({ validError: err });
                output.writeMessageBegin("removeSubStatusComment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: RemoveSubStatusCommentResult = new RemoveSubStatusCommentResult({ error: err });
                output.writeMessageBegin("removeSubStatusComment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeSubStatusComment", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeDocumentType(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeDocumentTypeArgs = ChangeDocumentTypeArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeDocumentType(args.token, args.docId, args.startStageId, args.stages, args.contentItems, args.roles, args.patternVariables, args.accessPolicy, args.newRegNumber, args.patternId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeDocumentTypeResult = new ChangeDocumentTypeResult({ success: data });
            output.writeMessageBegin("changeDocumentType", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeDocumentTypeResult = new ChangeDocumentTypeResult({ validError: err });
                output.writeMessageBegin("changeDocumentType", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeDocumentTypeResult = new ChangeDocumentTypeResult({ error: err });
                output.writeMessageBegin("changeDocumentType", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeDocumentType", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getDocumentRelationModel(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<DocumentRelationModel.DocumentRelationModel>((resolve, reject): void => {
            try {
                const args: GetDocumentRelationModelArgs = GetDocumentRelationModelArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getDocumentRelationModel(args.token, args.docId, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DocumentRelationModel.DocumentRelationModel): void => {
            const result: GetDocumentRelationModelResult = new GetDocumentRelationModelResult({ success: data });
            output.writeMessageBegin("getDocumentRelationModel", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetDocumentRelationModelResult = new GetDocumentRelationModelResult({ validError: err });
                output.writeMessageBegin("getDocumentRelationModel", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetDocumentRelationModelResult = new GetDocumentRelationModelResult({ error: err });
                output.writeMessageBegin("getDocumentRelationModel", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getDocumentRelationModel", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getNewConvertedAttachmentVersion(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Attachment.Attachment>((resolve, reject): void => {
            try {
                const args: GetNewConvertedAttachmentVersionArgs = GetNewConvertedAttachmentVersionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getNewConvertedAttachmentVersion(args.token, args.prevAttId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Attachment.Attachment): void => {
            const result: GetNewConvertedAttachmentVersionResult = new GetNewConvertedAttachmentVersionResult({ success: data });
            output.writeMessageBegin("getNewConvertedAttachmentVersion", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetNewConvertedAttachmentVersionResult = new GetNewConvertedAttachmentVersionResult({ validError: err });
                output.writeMessageBegin("getNewConvertedAttachmentVersion", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetNewConvertedAttachmentVersionResult = new GetNewConvertedAttachmentVersionResult({ error: err });
                output.writeMessageBegin("getNewConvertedAttachmentVersion", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getNewConvertedAttachmentVersion", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_exportAsXML(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Buffer>((resolve, reject): void => {
            try {
                const args: ExportAsXMLArgs = ExportAsXMLArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.exportAsXML(args.token, args.documentId, args.accessPolicy, args.allowedAttachmentFileExt, args.allowedAttachmentType));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Buffer): void => {
            const result: ExportAsXMLResult = new ExportAsXMLResult({ success: data });
            output.writeMessageBegin("exportAsXML", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ExportAsXMLResult = new ExportAsXMLResult({ validError: err });
                output.writeMessageBegin("exportAsXML", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ExportAsXMLResult = new ExportAsXMLResult({ error: err });
                output.writeMessageBegin("exportAsXML", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("exportAsXML", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_exportAsXMLv2(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Buffer>((resolve, reject): void => {
            try {
                const args: ExportAsXMLv2Args = ExportAsXMLv2Args.read(input);
                input.readMessageEnd();
                resolve(this._handler.exportAsXMLv2(args.token, args.documentId, args.accessPolicy, args.allowedAttachmentFileExt, args.allowedAttachmentType));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Buffer): void => {
            const result: ExportAsXMLv2Result = new ExportAsXMLv2Result({ success: data });
            output.writeMessageBegin("exportAsXMLv2", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ExportAsXMLv2Result = new ExportAsXMLv2Result({ validError: err });
                output.writeMessageBegin("exportAsXMLv2", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ExportAsXMLv2Result = new ExportAsXMLv2Result({ error: err });
                output.writeMessageBegin("exportAsXMLv2", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("exportAsXMLv2", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_importFromXML(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Document.Document>((resolve, reject): void => {
            try {
                const args: ImportFromXMLArgs = ImportFromXMLArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.importFromXML(args.token, args.xml));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Document.Document): void => {
            const result: ImportFromXMLResult = new ImportFromXMLResult({ success: data });
            output.writeMessageBegin("importFromXML", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ImportFromXMLResult = new ImportFromXMLResult({ validError: err });
                output.writeMessageBegin("importFromXML", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ImportFromXMLResult = new ImportFromXMLResult({ error: err });
                output.writeMessageBegin("importFromXML", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("importFromXML", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getDocContentItemsForChangeType(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<ContentItem.ContentItem>>((resolve, reject): void => {
            try {
                const args: GetDocContentItemsForChangeTypeArgs = GetDocContentItemsForChangeTypeArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getDocContentItemsForChangeType(args.token, args.documentId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<ContentItem.ContentItem>): void => {
            const result: GetDocContentItemsForChangeTypeResult = new GetDocContentItemsForChangeTypeResult({ success: data });
            output.writeMessageBegin("getDocContentItemsForChangeType", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetDocContentItemsForChangeTypeResult = new GetDocContentItemsForChangeTypeResult({ validError: err });
                output.writeMessageBegin("getDocContentItemsForChangeType", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetDocContentItemsForChangeTypeResult = new GetDocContentItemsForChangeTypeResult({ error: err });
                output.writeMessageBegin("getDocContentItemsForChangeType", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getDocContentItemsForChangeType", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_downloadDocumentTemplate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Buffer>((resolve, reject): void => {
            try {
                const args: DownloadDocumentTemplateArgs = DownloadDocumentTemplateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.downloadDocumentTemplate(args.token, args.documentId, args.accessPolicy, args.pdfPostDecorators));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Buffer): void => {
            const result: DownloadDocumentTemplateResult = new DownloadDocumentTemplateResult({ success: data });
            output.writeMessageBegin("downloadDocumentTemplate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: DownloadDocumentTemplateResult = new DownloadDocumentTemplateResult({ validError: err });
                output.writeMessageBegin("downloadDocumentTemplate", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: DownloadDocumentTemplateResult = new DownloadDocumentTemplateResult({ error: err });
                output.writeMessageBegin("downloadDocumentTemplate", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("downloadDocumentTemplate", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllDocumentExecutionsByFilter(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocumentExecution.DocumentExecution>>((resolve, reject): void => {
            try {
                const args: GetAllDocumentExecutionsByFilterArgs = GetAllDocumentExecutionsByFilterArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllDocumentExecutionsByFilter(args.token, args.documentId, args.filter, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocumentExecution.DocumentExecution>): void => {
            const result: GetAllDocumentExecutionsByFilterResult = new GetAllDocumentExecutionsByFilterResult({ success: data });
            output.writeMessageBegin("getAllDocumentExecutionsByFilter", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllDocumentExecutionsByFilterResult = new GetAllDocumentExecutionsByFilterResult({ validError: err });
                output.writeMessageBegin("getAllDocumentExecutionsByFilter", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllDocumentExecutionsByFilterResult = new GetAllDocumentExecutionsByFilterResult({ error: err });
                output.writeMessageBegin("getAllDocumentExecutionsByFilter", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllDocumentExecutionsByFilter", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getDocumentId(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: GetDocumentIdArgs = GetDocumentIdArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getDocumentId(args.token, args.sType, args.value, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: GetDocumentIdResult = new GetDocumentIdResult({ success: data });
            output.writeMessageBegin("getDocumentId", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetDocumentIdResult = new GetDocumentIdResult({ validError: err });
                output.writeMessageBegin("getDocumentId", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetDocumentIdResult = new GetDocumentIdResult({ error: err });
                output.writeMessageBegin("getDocumentId", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getDocumentId", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeDocumentName(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeDocumentNameArgs = ChangeDocumentNameArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeDocumentName(args.token, args.docId, args.docName, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeDocumentNameResult = new ChangeDocumentNameResult({ success: data });
            output.writeMessageBegin("changeDocumentName", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeDocumentNameResult = new ChangeDocumentNameResult({ validError: err });
                output.writeMessageBegin("changeDocumentName", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeDocumentNameResult = new ChangeDocumentNameResult({ error: err });
                output.writeMessageBegin("changeDocumentName", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeDocumentName", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeAttachmentOrder(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeAttachmentOrderArgs = ChangeAttachmentOrderArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeAttachmentOrder(args.token, args.documentId, args.orderMap, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeAttachmentOrderResult = new ChangeAttachmentOrderResult({ success: data });
            output.writeMessageBegin("changeAttachmentOrder", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeAttachmentOrderResult = new ChangeAttachmentOrderResult({ validError: err });
                output.writeMessageBegin("changeAttachmentOrder", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeAttachmentOrderResult = new ChangeAttachmentOrderResult({ error: err });
                output.writeMessageBegin("changeAttachmentOrder", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeAttachmentOrder", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_compareAttachmentsURL(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: CompareAttachmentsURLArgs = CompareAttachmentsURLArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.compareAttachmentsURL(args.token, args.attachmentId1, args.attachmentId2, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: CompareAttachmentsURLResult = new CompareAttachmentsURLResult({ success: data });
            output.writeMessageBegin("compareAttachmentsURL", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CompareAttachmentsURLResult = new CompareAttachmentsURLResult({ validError: err });
                output.writeMessageBegin("compareAttachmentsURL", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CompareAttachmentsURLResult = new CompareAttachmentsURLResult({ error: err });
                output.writeMessageBegin("compareAttachmentsURL", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("compareAttachmentsURL", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getDocumentDecisionXml(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: GetDocumentDecisionXmlArgs = GetDocumentDecisionXmlArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getDocumentDecisionXml(args.token, args.documentId, args.linkId, args.cardId, args.comment));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: GetDocumentDecisionXmlResult = new GetDocumentDecisionXmlResult({ success: data });
            output.writeMessageBegin("getDocumentDecisionXml", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetDocumentDecisionXmlResult = new GetDocumentDecisionXmlResult({ validError: err });
                output.writeMessageBegin("getDocumentDecisionXml", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetDocumentDecisionXmlResult = new GetDocumentDecisionXmlResult({ error: err });
                output.writeMessageBegin("getDocumentDecisionXml", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getDocumentDecisionXml", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getReassignDocXml(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: GetReassignDocXmlArgs = GetReassignDocXmlArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getReassignDocXml(args.token, args.documentId, args.cardId, args.documentReassign));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: GetReassignDocXmlResult = new GetReassignDocXmlResult({ success: data });
            output.writeMessageBegin("getReassignDocXml", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetReassignDocXmlResult = new GetReassignDocXmlResult({ validError: err });
                output.writeMessageBegin("getReassignDocXml", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetReassignDocXmlResult = new GetReassignDocXmlResult({ error: err });
                output.writeMessageBegin("getReassignDocXml", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getReassignDocXml", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_addAnswerers(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: AddAnswerersArgs = AddAnswerersArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.addAnswerers(args.token, args.cardId, args.users, args.deadlineDate, args.comment, args.requireMyParticipation, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: AddAnswerersResult = new AddAnswerersResult({ success: data });
            output.writeMessageBegin("addAnswerers", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: AddAnswerersResult = new AddAnswerersResult({ validError: err });
                output.writeMessageBegin("addAnswerers", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: AddAnswerersResult = new AddAnswerersResult({ error: err });
                output.writeMessageBegin("addAnswerers", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addAnswerers", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_addAnswerersToLinkedDocument(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: AddAnswerersToLinkedDocumentArgs = AddAnswerersToLinkedDocumentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.addAnswerersToLinkedDocument(args.token, args.docId, args.users, args.deadlineDate, args.comment, args.requireMyParticipation, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: AddAnswerersToLinkedDocumentResult = new AddAnswerersToLinkedDocumentResult({ success: data });
            output.writeMessageBegin("addAnswerersToLinkedDocument", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: AddAnswerersToLinkedDocumentResult = new AddAnswerersToLinkedDocumentResult({ validError: err });
                output.writeMessageBegin("addAnswerersToLinkedDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: AddAnswerersToLinkedDocumentResult = new AddAnswerersToLinkedDocumentResult({ error: err });
                output.writeMessageBegin("addAnswerersToLinkedDocument", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addAnswerersToLinkedDocument", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createMeetingQuestion(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Document.Document>((resolve, reject): void => {
            try {
                const args: CreateMeetingQuestionArgs = CreateMeetingQuestionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createMeetingQuestion(args.token, args.document, args.users, args.holderLinks, args.securityClassificationsId, args.attachments, args.docRelations, args.meetingDocumentId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Document.Document): void => {
            const result: CreateMeetingQuestionResult = new CreateMeetingQuestionResult({ success: data });
            output.writeMessageBegin("createMeetingQuestion", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CreateMeetingQuestionResult = new CreateMeetingQuestionResult({ validError: err });
                output.writeMessageBegin("createMeetingQuestion", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CreateMeetingQuestionResult = new CreateMeetingQuestionResult({ error: err });
                output.writeMessageBegin("createMeetingQuestion", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createMeetingQuestion", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeExternalNumber(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeExternalNumberArgs = ChangeExternalNumberArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeExternalNumber(args.token, args.documentId, args.externalId, args.externalNumber, args.externalRegDate, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeExternalNumberResult = new ChangeExternalNumberResult({ success: data });
            output.writeMessageBegin("changeExternalNumber", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ChangeExternalNumberResult = new ChangeExternalNumberResult({ validError: err });
                output.writeMessageBegin("changeExternalNumber", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ChangeExternalNumberResult = new ChangeExternalNumberResult({ error: err });
                output.writeMessageBegin("changeExternalNumber", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeExternalNumber", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAvailableSubStatuses(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Set<DocPatternStageSubStatus.DocPatternStageSubStatus>>((resolve, reject): void => {
            try {
                const args: GetAvailableSubStatusesArgs = GetAvailableSubStatusesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAvailableSubStatuses(args.token, args.documentId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Set<DocPatternStageSubStatus.DocPatternStageSubStatus>): void => {
            const result: GetAvailableSubStatusesResult = new GetAvailableSubStatusesResult({ success: data });
            output.writeMessageBegin("getAvailableSubStatuses", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAvailableSubStatusesResult = new GetAvailableSubStatusesResult({ validError: err });
                output.writeMessageBegin("getAvailableSubStatuses", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAvailableSubStatusesResult = new GetAvailableSubStatusesResult({ error: err });
                output.writeMessageBegin("getAvailableSubStatuses", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAvailableSubStatuses", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_cardWorkingStart(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<DocumentExecution.DocumentExecution>((resolve, reject): void => {
            try {
                const args: CardWorkingStartArgs = CardWorkingStartArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.cardWorkingStart(args.token, args.cardId, args.workComment));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DocumentExecution.DocumentExecution): void => {
            const result: CardWorkingStartResult = new CardWorkingStartResult({ success: data });
            output.writeMessageBegin("cardWorkingStart", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CardWorkingStartResult = new CardWorkingStartResult({ validError: err });
                output.writeMessageBegin("cardWorkingStart", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CardWorkingStartResult = new CardWorkingStartResult({ error: err });
                output.writeMessageBegin("cardWorkingStart", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("cardWorkingStart", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_cardWorkingLog(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<DocumentExecution.DocumentExecution>((resolve, reject): void => {
            try {
                const args: CardWorkingLogArgs = CardWorkingLogArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.cardWorkingLog(args.token, args.cardId, args.workComment));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DocumentExecution.DocumentExecution): void => {
            const result: CardWorkingLogResult = new CardWorkingLogResult({ success: data });
            output.writeMessageBegin("cardWorkingLog", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CardWorkingLogResult = new CardWorkingLogResult({ validError: err });
                output.writeMessageBegin("cardWorkingLog", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CardWorkingLogResult = new CardWorkingLogResult({ error: err });
                output.writeMessageBegin("cardWorkingLog", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("cardWorkingLog", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_cardWorkingStop(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<DocumentExecution.DocumentExecution>((resolve, reject): void => {
            try {
                const args: CardWorkingStopArgs = CardWorkingStopArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.cardWorkingStop(args.token, args.cardId, args.workComment));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DocumentExecution.DocumentExecution): void => {
            const result: CardWorkingStopResult = new CardWorkingStopResult({ success: data });
            output.writeMessageBegin("cardWorkingStop", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CardWorkingStopResult = new CardWorkingStopResult({ validError: err });
                output.writeMessageBegin("cardWorkingStop", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CardWorkingStopResult = new CardWorkingStopResult({ error: err });
                output.writeMessageBegin("cardWorkingStop", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("cardWorkingStop", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getEnabledSubStatuses(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Map<SubStatusKey.SubStatusKey, Array<DocPatternStageSubStatus.DocPatternStageSubStatus>>>((resolve, reject): void => {
            try {
                const args: GetEnabledSubStatusesArgs = GetEnabledSubStatusesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getEnabledSubStatuses(args.token, args.documentId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Map<SubStatusKey.SubStatusKey, Array<DocPatternStageSubStatus.DocPatternStageSubStatus>>): void => {
            const result: GetEnabledSubStatusesResult = new GetEnabledSubStatusesResult({ success: data });
            output.writeMessageBegin("getEnabledSubStatuses", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetEnabledSubStatusesResult = new GetEnabledSubStatusesResult({ validError: err });
                output.writeMessageBegin("getEnabledSubStatuses", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetEnabledSubStatusesResult = new GetEnabledSubStatusesResult({ error: err });
                output.writeMessageBegin("getEnabledSubStatuses", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getEnabledSubStatuses", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_updateUserTag(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<DocumentTag.DocumentTag>((resolve, reject): void => {
            try {
                const args: UpdateUserTagArgs = UpdateUserTagArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.updateUserTag(args.token, args.docTag, args.fdelete));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: DocumentTag.DocumentTag): void => {
            const result: UpdateUserTagResult = new UpdateUserTagResult({ success: data });
            output.writeMessageBegin("updateUserTag", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: UpdateUserTagResult = new UpdateUserTagResult({ validError: err });
                output.writeMessageBegin("updateUserTag", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: UpdateUserTagResult = new UpdateUserTagResult({ error: err });
                output.writeMessageBegin("updateUserTag", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("updateUserTag", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getUserTags(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DocumentTag.DocumentTag>>((resolve, reject): void => {
            try {
                const args: GetUserTagsArgs = GetUserTagsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getUserTags(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DocumentTag.DocumentTag>): void => {
            const result: GetUserTagsResult = new GetUserTagsResult({ success: data });
            output.writeMessageBegin("getUserTags", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetUserTagsResult = new GetUserTagsResult({ validError: err });
                output.writeMessageBegin("getUserTags", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetUserTagsResult = new GetUserTagsResult({ error: err });
                output.writeMessageBegin("getUserTags", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getUserTags", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_updateTagOrders(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: UpdateTagOrdersArgs = UpdateTagOrdersArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.updateTagOrders(args.token, args.oredrMap));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: UpdateTagOrdersResult = new UpdateTagOrdersResult({ success: data });
            output.writeMessageBegin("updateTagOrders", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: UpdateTagOrdersResult = new UpdateTagOrdersResult({ validError: err });
                output.writeMessageBegin("updateTagOrders", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: UpdateTagOrdersResult = new UpdateTagOrdersResult({ error: err });
                output.writeMessageBegin("updateTagOrders", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("updateTagOrders", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_documentFieldByKey(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: DocumentFieldByKeyArgs = DocumentFieldByKeyArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.documentFieldByKey(args.token, args.documentId, args.key, args.keyType));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: DocumentFieldByKeyResult = new DocumentFieldByKeyResult({ success: data });
            output.writeMessageBegin("documentFieldByKey", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: DocumentFieldByKeyResult = new DocumentFieldByKeyResult({ validError: err });
                output.writeMessageBegin("documentFieldByKey", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: DocumentFieldByKeyResult = new DocumentFieldByKeyResult({ error: err });
                output.writeMessageBegin("documentFieldByKey", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("documentFieldByKey", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_addDecoration(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: AddDecorationArgs = AddDecorationArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.addDecoration(args.token, args.attachmentId, args.decoratorKeys));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: AddDecorationResult = new AddDecorationResult({ success: data });
            output.writeMessageBegin("addDecoration", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: AddDecorationResult = new AddDecorationResult({ validError: err });
                output.writeMessageBegin("addDecoration", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: AddDecorationResult = new AddDecorationResult({ error: err });
                output.writeMessageBegin("addDecoration", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addDecoration", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
}
