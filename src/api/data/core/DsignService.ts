/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import * as thrift from "thrift";
import * as core from "./";
import * as DigitalSign from "./DigitalSign";
import * as SignInfo from "./SignInfo";
import * as PrivateKeyInfo from "./PrivateKeyInfo";
import * as ExtSignOperation from "./ExtSignOperation";
import * as ExtSignServer from "./ExtSignServer";
import * as BulkSignJob from "./BulkSignJob";
import * as BulkSignInfo from "./BulkSignInfo";
export interface IGetTimeStampTokenArgsArgs {
    token: string;
    data: string;
}
export class GetTimeStampTokenArgs {
    public token: string;
    public data: string;
    constructor(args: IGetTimeStampTokenArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.data != null) {
            this.data = args.data;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[data] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetTimeStampTokenArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.data != null) {
            output.writeFieldBegin("data", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.data);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetTimeStampTokenArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_1: string = input.readString();
                        _args.token = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_2: string = input.readString();
                        _args.data = value_2;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.data !== undefined) {
            return new GetTimeStampTokenArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetTimeStampTokenArgs from input");
        }
    }
}
export interface ISignAttachmentArgsArgs {
    token: string;
    attachmentId: string;
    signatures: Array<string>;
}
export class SignAttachmentArgs {
    public token: string;
    public attachmentId: string;
    public signatures: Array<string>;
    constructor(args: ISignAttachmentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId != null) {
            this.attachmentId = args.attachmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId] is unset!");
        }
        if (args != null && args.signatures != null) {
            this.signatures = args.signatures;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[signatures] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SignAttachmentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId != null) {
            output.writeFieldBegin("attachmentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId);
            output.writeFieldEnd();
        }
        if (this.signatures != null) {
            output.writeFieldBegin("signatures", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.signatures.length);
            this.signatures.forEach((value_3: string): void => {
                output.writeString(value_3);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SignAttachmentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_4: string = input.readString();
                        _args.token = value_4;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_5: string = input.readString();
                        _args.attachmentId = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_6: Array<string> = new Array<string>();
                        const metadata_1: thrift.TList = input.readListBegin();
                        const size_1: number = metadata_1.size;
                        for (let i_1: number = 0; i_1 < size_1; i_1++) {
                            const value_7: string = input.readString();
                            value_6.push(value_7);
                        }
                        input.readListEnd();
                        _args.signatures = value_6;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId !== undefined && _args.signatures !== undefined) {
            return new SignAttachmentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SignAttachmentArgs from input");
        }
    }
}
export interface ISignAttachmentUsingServerKeyStorageArgsArgs {
    token: string;
    attachmentId: string;
    pKeyId: string;
    password: string;
}
export class SignAttachmentUsingServerKeyStorageArgs {
    public token: string;
    public attachmentId: string;
    public pKeyId: string;
    public password: string;
    constructor(args: ISignAttachmentUsingServerKeyStorageArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId != null) {
            this.attachmentId = args.attachmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId] is unset!");
        }
        if (args != null && args.pKeyId != null) {
            this.pKeyId = args.pKeyId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[pKeyId] is unset!");
        }
        if (args != null && args.password != null) {
            this.password = args.password;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[password] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SignAttachmentUsingServerKeyStorageArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId != null) {
            output.writeFieldBegin("attachmentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId);
            output.writeFieldEnd();
        }
        if (this.pKeyId != null) {
            output.writeFieldBegin("pKeyId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.pKeyId);
            output.writeFieldEnd();
        }
        if (this.password != null) {
            output.writeFieldBegin("password", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.password);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SignAttachmentUsingServerKeyStorageArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_8: string = input.readString();
                        _args.token = value_8;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_9: string = input.readString();
                        _args.attachmentId = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_10: string = input.readString();
                        _args.pKeyId = value_10;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_11: string = input.readString();
                        _args.password = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId !== undefined && _args.pKeyId !== undefined && _args.password !== undefined) {
            return new SignAttachmentUsingServerKeyStorageArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SignAttachmentUsingServerKeyStorageArgs from input");
        }
    }
}
export interface IGetAllDigitalSignsArgsArgs {
    token: string;
    documentId: string;
    filter: core.KazFilter;
}
export class GetAllDigitalSignsArgs {
    public token: string;
    public documentId: string;
    public filter: core.KazFilter;
    constructor(args: IGetAllDigitalSignsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDigitalSignsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 3);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDigitalSignsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_12: string = input.readString();
                        _args.token = value_12;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_13: string = input.readString();
                        _args.documentId = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_14: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_14;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.filter !== undefined) {
            return new GetAllDigitalSignsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllDigitalSignsArgs from input");
        }
    }
}
export interface IGetCertificateInfoArgsArgs {
    token: string;
    digitalSignId: string;
}
export class GetCertificateInfoArgs {
    public token: string;
    public digitalSignId: string;
    constructor(args: IGetCertificateInfoArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.digitalSignId != null) {
            this.digitalSignId = args.digitalSignId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[digitalSignId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCertificateInfoArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.digitalSignId != null) {
            output.writeFieldBegin("digitalSignId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.digitalSignId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCertificateInfoArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_15: string = input.readString();
                        _args.token = value_15;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_16: string = input.readString();
                        _args.digitalSignId = value_16;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.digitalSignId !== undefined) {
            return new GetCertificateInfoArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetCertificateInfoArgs from input");
        }
    }
}
export interface IGetCertificateInfoListByUserArgsArgs {
    token: string;
    userId: string;
}
export class GetCertificateInfoListByUserArgs {
    public token: string;
    public userId: string;
    constructor(args: IGetCertificateInfoListByUserArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.userId != null) {
            this.userId = args.userId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCertificateInfoListByUserArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.userId != null) {
            output.writeFieldBegin("userId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.userId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCertificateInfoListByUserArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_17: string = input.readString();
                        _args.token = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_18: string = input.readString();
                        _args.userId = value_18;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.userId !== undefined) {
            return new GetCertificateInfoListByUserArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetCertificateInfoListByUserArgs from input");
        }
    }
}
export interface IGetSignInfoByCertificateArgsArgs {
    token: string;
    data: string;
}
export class GetSignInfoByCertificateArgs {
    public token: string;
    public data: string;
    constructor(args: IGetSignInfoByCertificateArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.data != null) {
            this.data = args.data;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[data] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetSignInfoByCertificateArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.data != null) {
            output.writeFieldBegin("data", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.data);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetSignInfoByCertificateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_19: string = input.readString();
                        _args.token = value_19;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_20: string = input.readString();
                        _args.data = value_20;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.data !== undefined) {
            return new GetSignInfoByCertificateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetSignInfoByCertificateArgs from input");
        }
    }
}
export interface IGetSignInfoArgsArgs {
    digitalSignId: string;
}
export class GetSignInfoArgs {
    public digitalSignId: string;
    constructor(args: IGetSignInfoArgsArgs) {
        if (args != null && args.digitalSignId != null) {
            this.digitalSignId = args.digitalSignId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[digitalSignId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetSignInfoArgs");
        if (this.digitalSignId != null) {
            output.writeFieldBegin("digitalSignId", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.digitalSignId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetSignInfoArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_21: string = input.readString();
                        _args.digitalSignId = value_21;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.digitalSignId !== undefined) {
            return new GetSignInfoArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetSignInfoArgs from input");
        }
    }
}
export interface IGetAllPrivateKeysArgsArgs {
    token: string;
    filter: core.KazFilter;
}
export class GetAllPrivateKeysArgs {
    public token: string;
    public filter: core.KazFilter;
    constructor(args: IGetAllPrivateKeysArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllPrivateKeysArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllPrivateKeysArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_22: string = input.readString();
                        _args.token = value_22;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_23: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_23;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllPrivateKeysArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllPrivateKeysArgs from input");
        }
    }
}
export interface IGetCountPrivateKeysArgsArgs {
    token: string;
    filter: core.KazFilter;
}
export class GetCountPrivateKeysArgs {
    public token: string;
    public filter: core.KazFilter;
    constructor(args: IGetCountPrivateKeysArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountPrivateKeysArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountPrivateKeysArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_24: string = input.readString();
                        _args.token = value_24;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_25: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_25;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetCountPrivateKeysArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetCountPrivateKeysArgs from input");
        }
    }
}
export interface IAddKeyToSecureStorageArgsArgs {
    token: string;
    key1: Buffer;
    password: string;
    name: string;
    fileExt: string;
    privateKeyIndexInJKS: string;
}
export class AddKeyToSecureStorageArgs {
    public token: string;
    public key1: Buffer;
    public password: string;
    public name: string;
    public fileExt: string;
    public privateKeyIndexInJKS: string;
    constructor(args: IAddKeyToSecureStorageArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.key1 != null) {
            this.key1 = args.key1;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[key1] is unset!");
        }
        if (args != null && args.password != null) {
            this.password = args.password;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[password] is unset!");
        }
        if (args != null && args.name != null) {
            this.name = args.name;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[name] is unset!");
        }
        if (args != null && args.fileExt != null) {
            this.fileExt = args.fileExt;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[fileExt] is unset!");
        }
        if (args != null && args.privateKeyIndexInJKS != null) {
            this.privateKeyIndexInJKS = args.privateKeyIndexInJKS;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[privateKeyIndexInJKS] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddKeyToSecureStorageArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.key1 != null) {
            output.writeFieldBegin("key1", thrift.Thrift.Type.STRING, 2);
            output.writeBinary(this.key1);
            output.writeFieldEnd();
        }
        if (this.password != null) {
            output.writeFieldBegin("password", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.password);
            output.writeFieldEnd();
        }
        if (this.name != null) {
            output.writeFieldBegin("name", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.name);
            output.writeFieldEnd();
        }
        if (this.fileExt != null) {
            output.writeFieldBegin("fileExt", thrift.Thrift.Type.STRING, 5);
            output.writeString(this.fileExt);
            output.writeFieldEnd();
        }
        if (this.privateKeyIndexInJKS != null) {
            output.writeFieldBegin("privateKeyIndexInJKS", thrift.Thrift.Type.STRING, 6);
            output.writeString(this.privateKeyIndexInJKS);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddKeyToSecureStorageArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_26: string = input.readString();
                        _args.token = value_26;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_27: Buffer = input.readBinary();
                        _args.key1 = value_27;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_28: string = input.readString();
                        _args.password = value_28;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_29: string = input.readString();
                        _args.name = value_29;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_30: string = input.readString();
                        _args.fileExt = value_30;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_31: string = input.readString();
                        _args.privateKeyIndexInJKS = value_31;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.key1 !== undefined && _args.password !== undefined && _args.name !== undefined && _args.fileExt !== undefined && _args.privateKeyIndexInJKS !== undefined) {
            return new AddKeyToSecureStorageArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddKeyToSecureStorageArgs from input");
        }
    }
}
export interface IRemoveKeyFromSecureStorageArgsArgs {
    token: string;
    id: string;
}
export class RemoveKeyFromSecureStorageArgs {
    public token: string;
    public id: string;
    constructor(args: IRemoveKeyFromSecureStorageArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.id != null) {
            this.id = args.id;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[id] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveKeyFromSecureStorageArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.id != null) {
            output.writeFieldBegin("id", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.id);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveKeyFromSecureStorageArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_32: string = input.readString();
                        _args.token = value_32;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_33: string = input.readString();
                        _args.id = value_33;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.id !== undefined) {
            return new RemoveKeyFromSecureStorageArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveKeyFromSecureStorageArgs from input");
        }
    }
}
export interface IGetDigitalSignByAttachmentIdArgsArgs {
    token: string;
    attachmentId: string;
}
export class GetDigitalSignByAttachmentIdArgs {
    public token: string;
    public attachmentId: string;
    constructor(args: IGetDigitalSignByAttachmentIdArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId != null) {
            this.attachmentId = args.attachmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDigitalSignByAttachmentIdArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId != null) {
            output.writeFieldBegin("attachmentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDigitalSignByAttachmentIdArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_34: string = input.readString();
                        _args.token = value_34;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_35: string = input.readString();
                        _args.attachmentId = value_35;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId !== undefined) {
            return new GetDigitalSignByAttachmentIdArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetDigitalSignByAttachmentIdArgs from input");
        }
    }
}
export interface IAddExternalSignToAttachmentArgsArgs {
    token: string;
    attachmentId: string;
    p7s: Array<Buffer>;
}
export class AddExternalSignToAttachmentArgs {
    public token: string;
    public attachmentId: string;
    public p7s: Array<Buffer>;
    constructor(args: IAddExternalSignToAttachmentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId != null) {
            this.attachmentId = args.attachmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId] is unset!");
        }
        if (args != null && args.p7s != null) {
            this.p7s = args.p7s;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[p7s] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddExternalSignToAttachmentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId != null) {
            output.writeFieldBegin("attachmentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId);
            output.writeFieldEnd();
        }
        if (this.p7s != null) {
            output.writeFieldBegin("p7s", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.p7s.length);
            this.p7s.forEach((value_36: Buffer): void => {
                output.writeBinary(value_36);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddExternalSignToAttachmentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_37: string = input.readString();
                        _args.token = value_37;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_38: string = input.readString();
                        _args.attachmentId = value_38;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_39: Array<Buffer> = new Array<Buffer>();
                        const metadata_2: thrift.TList = input.readListBegin();
                        const size_2: number = metadata_2.size;
                        for (let i_2: number = 0; i_2 < size_2; i_2++) {
                            const value_40: Buffer = input.readBinary();
                            value_39.push(value_40);
                        }
                        input.readListEnd();
                        _args.p7s = value_39;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId !== undefined && _args.p7s !== undefined) {
            return new AddExternalSignToAttachmentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddExternalSignToAttachmentArgs from input");
        }
    }
}
export interface ISingAnyDataArgsArgs {
    token: string;
    keyInfoList: Array<core.SignKeyInfo>;
    dataToSignList: Array<core.SignData>;
}
export class SingAnyDataArgs {
    public token: string;
    public keyInfoList: Array<core.SignKeyInfo>;
    public dataToSignList: Array<core.SignData>;
    constructor(args: ISingAnyDataArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.keyInfoList != null) {
            this.keyInfoList = args.keyInfoList;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[keyInfoList] is unset!");
        }
        if (args != null && args.dataToSignList != null) {
            this.dataToSignList = args.dataToSignList;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[dataToSignList] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SingAnyDataArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.keyInfoList != null) {
            output.writeFieldBegin("keyInfoList", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.keyInfoList.length);
            this.keyInfoList.forEach((value_41: core.SignKeyInfo): void => {
                value_41.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.dataToSignList != null) {
            output.writeFieldBegin("dataToSignList", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.dataToSignList.length);
            this.dataToSignList.forEach((value_42: core.SignData): void => {
                value_42.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SingAnyDataArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_43: string = input.readString();
                        _args.token = value_43;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_44: Array<core.SignKeyInfo> = new Array<core.SignKeyInfo>();
                        const metadata_3: thrift.TList = input.readListBegin();
                        const size_3: number = metadata_3.size;
                        for (let i_3: number = 0; i_3 < size_3; i_3++) {
                            const value_45: core.SignKeyInfo = core.SignKeyInfo.read(input);
                            value_44.push(value_45);
                        }
                        input.readListEnd();
                        _args.keyInfoList = value_44;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_46: Array<core.SignData> = new Array<core.SignData>();
                        const metadata_4: thrift.TList = input.readListBegin();
                        const size_4: number = metadata_4.size;
                        for (let i_4: number = 0; i_4 < size_4; i_4++) {
                            const value_47: core.SignData = core.SignData.read(input);
                            value_46.push(value_47);
                        }
                        input.readListEnd();
                        _args.dataToSignList = value_46;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.keyInfoList !== undefined && _args.dataToSignList !== undefined) {
            return new SingAnyDataArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SingAnyDataArgs from input");
        }
    }
}
export interface ISignInExternalServiceArgsArgs {
    token: string;
    serviceKey: string;
    dataToSignList: Array<core.SignData>;
}
export class SignInExternalServiceArgs {
    public token: string;
    public serviceKey: string;
    public dataToSignList: Array<core.SignData>;
    constructor(args: ISignInExternalServiceArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.serviceKey != null) {
            this.serviceKey = args.serviceKey;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[serviceKey] is unset!");
        }
        if (args != null && args.dataToSignList != null) {
            this.dataToSignList = args.dataToSignList;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[dataToSignList] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SignInExternalServiceArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.serviceKey != null) {
            output.writeFieldBegin("serviceKey", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.serviceKey);
            output.writeFieldEnd();
        }
        if (this.dataToSignList != null) {
            output.writeFieldBegin("dataToSignList", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.dataToSignList.length);
            this.dataToSignList.forEach((value_48: core.SignData): void => {
                value_48.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SignInExternalServiceArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_49: string = input.readString();
                        _args.token = value_49;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_50: string = input.readString();
                        _args.serviceKey = value_50;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_51: Array<core.SignData> = new Array<core.SignData>();
                        const metadata_5: thrift.TList = input.readListBegin();
                        const size_5: number = metadata_5.size;
                        for (let i_5: number = 0; i_5 < size_5; i_5++) {
                            const value_52: core.SignData = core.SignData.read(input);
                            value_51.push(value_52);
                        }
                        input.readListEnd();
                        _args.dataToSignList = value_51;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.serviceKey !== undefined && _args.dataToSignList !== undefined) {
            return new SignInExternalServiceArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SignInExternalServiceArgs from input");
        }
    }
}
export interface ICheckSignStatusInExternalServiceArgsArgs {
    token: string;
    serviceKey: string;
    signOperation: ExtSignOperation.ExtSignOperation;
}
export class CheckSignStatusInExternalServiceArgs {
    public token: string;
    public serviceKey: string;
    public signOperation: ExtSignOperation.ExtSignOperation;
    constructor(args: ICheckSignStatusInExternalServiceArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.serviceKey != null) {
            this.serviceKey = args.serviceKey;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[serviceKey] is unset!");
        }
        if (args != null && args.signOperation != null) {
            this.signOperation = args.signOperation;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[signOperation] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CheckSignStatusInExternalServiceArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.serviceKey != null) {
            output.writeFieldBegin("serviceKey", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.serviceKey);
            output.writeFieldEnd();
        }
        if (this.signOperation != null) {
            output.writeFieldBegin("signOperation", thrift.Thrift.Type.STRUCT, 3);
            this.signOperation.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CheckSignStatusInExternalServiceArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_53: string = input.readString();
                        _args.token = value_53;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_54: string = input.readString();
                        _args.serviceKey = value_54;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_55: ExtSignOperation.ExtSignOperation = ExtSignOperation.ExtSignOperation.read(input);
                        _args.signOperation = value_55;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.serviceKey !== undefined && _args.signOperation !== undefined) {
            return new CheckSignStatusInExternalServiceArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CheckSignStatusInExternalServiceArgs from input");
        }
    }
}
export interface IExtractPublicKeyInfoArgsArgs {
    token: string;
    keyInfo: core.SignKeyInfo;
}
export class ExtractPublicKeyInfoArgs {
    public token: string;
    public keyInfo: core.SignKeyInfo;
    constructor(args: IExtractPublicKeyInfoArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.keyInfo != null) {
            this.keyInfo = args.keyInfo;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[keyInfo] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExtractPublicKeyInfoArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.keyInfo != null) {
            output.writeFieldBegin("keyInfo", thrift.Thrift.Type.STRUCT, 2);
            this.keyInfo.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExtractPublicKeyInfoArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_56: string = input.readString();
                        _args.token = value_56;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_57: core.SignKeyInfo = core.SignKeyInfo.read(input);
                        _args.keyInfo = value_57;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.keyInfo !== undefined) {
            return new ExtractPublicKeyInfoArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExtractPublicKeyInfoArgs from input");
        }
    }
}
export interface IGetAllExternalSignServiceInfosArgsArgs {
    token: string;
    filter: core.KazFilter;
}
export class GetAllExternalSignServiceInfosArgs {
    public token: string;
    public filter: core.KazFilter;
    constructor(args: IGetAllExternalSignServiceInfosArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllExternalSignServiceInfosArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllExternalSignServiceInfosArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_58: string = input.readString();
                        _args.token = value_58;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_59: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_59;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllExternalSignServiceInfosArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllExternalSignServiceInfosArgs from input");
        }
    }
}
export interface IGetCurrentBulkSignJobArgsArgs {
    token: string;
}
export class GetCurrentBulkSignJobArgs {
    public token: string;
    constructor(args: IGetCurrentBulkSignJobArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCurrentBulkSignJobArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCurrentBulkSignJobArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_60: string = input.readString();
                        _args.token = value_60;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined) {
            return new GetCurrentBulkSignJobArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetCurrentBulkSignJobArgs from input");
        }
    }
}
export interface IGetFullBulkSignJobArgsArgs {
    token: string;
    bulkId: string;
    filter: core.KazFilter;
}
export class GetFullBulkSignJobArgs {
    public token: string;
    public bulkId: string;
    public filter: core.KazFilter;
    constructor(args: IGetFullBulkSignJobArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.bulkId != null) {
            this.bulkId = args.bulkId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[bulkId] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetFullBulkSignJobArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.bulkId != null) {
            output.writeFieldBegin("bulkId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.bulkId);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 3);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetFullBulkSignJobArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_61: string = input.readString();
                        _args.token = value_61;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_62: string = input.readString();
                        _args.bulkId = value_62;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_63: core.KazFilter = core.KazFilter.read(input);
                        _args.filter = value_63;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.bulkId !== undefined && _args.filter !== undefined) {
            return new GetFullBulkSignJobArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetFullBulkSignJobArgs from input");
        }
    }
}
export interface IRemoveFromCurrentBulkSignJobArgsArgs {
    token: string;
    bulkId: string;
    signDocId: string;
    signAttId: string;
    attId: string;
}
export class RemoveFromCurrentBulkSignJobArgs {
    public token: string;
    public bulkId: string;
    public signDocId: string;
    public signAttId: string;
    public attId: string;
    constructor(args: IRemoveFromCurrentBulkSignJobArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.bulkId != null) {
            this.bulkId = args.bulkId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[bulkId] is unset!");
        }
        if (args != null && args.signDocId != null) {
            this.signDocId = args.signDocId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[signDocId] is unset!");
        }
        if (args != null && args.signAttId != null) {
            this.signAttId = args.signAttId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[signAttId] is unset!");
        }
        if (args != null && args.attId != null) {
            this.attId = args.attId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveFromCurrentBulkSignJobArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.bulkId != null) {
            output.writeFieldBegin("bulkId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.bulkId);
            output.writeFieldEnd();
        }
        if (this.signDocId != null) {
            output.writeFieldBegin("signDocId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.signDocId);
            output.writeFieldEnd();
        }
        if (this.signAttId != null) {
            output.writeFieldBegin("signAttId", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.signAttId);
            output.writeFieldEnd();
        }
        if (this.attId != null) {
            output.writeFieldBegin("attId", thrift.Thrift.Type.STRING, 5);
            output.writeString(this.attId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveFromCurrentBulkSignJobArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_64: string = input.readString();
                        _args.token = value_64;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_65: string = input.readString();
                        _args.bulkId = value_65;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_66: string = input.readString();
                        _args.signDocId = value_66;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_67: string = input.readString();
                        _args.signAttId = value_67;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_68: string = input.readString();
                        _args.attId = value_68;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.bulkId !== undefined && _args.signDocId !== undefined && _args.signAttId !== undefined && _args.attId !== undefined) {
            return new RemoveFromCurrentBulkSignJobArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveFromCurrentBulkSignJobArgs from input");
        }
    }
}
export interface IAddToCurrentBulkSignJobArgsArgs {
    token: string;
    bulkId: string;
    accessPolicy: core.DocumentAccessPolicy;
    attId: string;
}
export class AddToCurrentBulkSignJobArgs {
    public token: string;
    public bulkId: string;
    public accessPolicy: core.DocumentAccessPolicy;
    public attId: string;
    constructor(args: IAddToCurrentBulkSignJobArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.bulkId != null) {
            this.bulkId = args.bulkId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[bulkId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
        if (args != null && args.attId != null) {
            this.attId = args.attId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddToCurrentBulkSignJobArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.bulkId != null) {
            output.writeFieldBegin("bulkId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.bulkId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        if (this.attId != null) {
            output.writeFieldBegin("attId", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.attId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddToCurrentBulkSignJobArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_69: string = input.readString();
                        _args.token = value_69;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_70: string = input.readString();
                        _args.bulkId = value_70;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_71: core.DocumentAccessPolicy = core.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_71;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_72: string = input.readString();
                        _args.attId = value_72;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.bulkId !== undefined && _args.accessPolicy !== undefined && _args.attId !== undefined) {
            return new AddToCurrentBulkSignJobArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddToCurrentBulkSignJobArgs from input");
        }
    }
}
export interface ISignBulkJobArgsArgs {
    token: string;
    keyInfoList: Array<core.SignKeyInfo>;
    bulkId: string;
    setAutoDecision: boolean;
}
export class SignBulkJobArgs {
    public token: string;
    public keyInfoList: Array<core.SignKeyInfo>;
    public bulkId: string;
    public setAutoDecision: boolean;
    constructor(args: ISignBulkJobArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.keyInfoList != null) {
            this.keyInfoList = args.keyInfoList;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[keyInfoList] is unset!");
        }
        if (args != null && args.bulkId != null) {
            this.bulkId = args.bulkId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[bulkId] is unset!");
        }
        if (args != null && args.setAutoDecision != null) {
            this.setAutoDecision = args.setAutoDecision;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[setAutoDecision] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SignBulkJobArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.keyInfoList != null) {
            output.writeFieldBegin("keyInfoList", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.keyInfoList.length);
            this.keyInfoList.forEach((value_73: core.SignKeyInfo): void => {
                value_73.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.bulkId != null) {
            output.writeFieldBegin("bulkId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.bulkId);
            output.writeFieldEnd();
        }
        if (this.setAutoDecision != null) {
            output.writeFieldBegin("setAutoDecision", thrift.Thrift.Type.BOOL, 4);
            output.writeBool(this.setAutoDecision);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SignBulkJobArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_74: string = input.readString();
                        _args.token = value_74;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_75: Array<core.SignKeyInfo> = new Array<core.SignKeyInfo>();
                        const metadata_6: thrift.TList = input.readListBegin();
                        const size_6: number = metadata_6.size;
                        for (let i_6: number = 0; i_6 < size_6; i_6++) {
                            const value_76: core.SignKeyInfo = core.SignKeyInfo.read(input);
                            value_75.push(value_76);
                        }
                        input.readListEnd();
                        _args.keyInfoList = value_75;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_77: string = input.readString();
                        _args.bulkId = value_77;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_78: boolean = input.readBool();
                        _args.setAutoDecision = value_78;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.keyInfoList !== undefined && _args.bulkId !== undefined && _args.setAutoDecision !== undefined) {
            return new SignBulkJobArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SignBulkJobArgs from input");
        }
    }
}
export interface ICancelBulkJobArgsArgs {
    token: string;
    bulkId: string;
}
export class CancelBulkJobArgs {
    public token: string;
    public bulkId: string;
    constructor(args: ICancelBulkJobArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.bulkId != null) {
            this.bulkId = args.bulkId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[bulkId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CancelBulkJobArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.bulkId != null) {
            output.writeFieldBegin("bulkId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.bulkId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CancelBulkJobArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_79: string = input.readString();
                        _args.token = value_79;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_80: string = input.readString();
                        _args.bulkId = value_80;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.bulkId !== undefined) {
            return new CancelBulkJobArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CancelBulkJobArgs from input");
        }
    }
}
export interface ICloseBulkJobArgsArgs {
    token: string;
    bulkId: string;
    copyFailedDocs: boolean;
}
export class CloseBulkJobArgs {
    public token: string;
    public bulkId: string;
    public copyFailedDocs: boolean;
    constructor(args: ICloseBulkJobArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.bulkId != null) {
            this.bulkId = args.bulkId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[bulkId] is unset!");
        }
        if (args != null && args.copyFailedDocs != null) {
            this.copyFailedDocs = args.copyFailedDocs;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[copyFailedDocs] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CloseBulkJobArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.bulkId != null) {
            output.writeFieldBegin("bulkId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.bulkId);
            output.writeFieldEnd();
        }
        if (this.copyFailedDocs != null) {
            output.writeFieldBegin("copyFailedDocs", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.copyFailedDocs);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CloseBulkJobArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_81: string = input.readString();
                        _args.token = value_81;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_82: string = input.readString();
                        _args.bulkId = value_82;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_83: boolean = input.readBool();
                        _args.copyFailedDocs = value_83;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.bulkId !== undefined && _args.copyFailedDocs !== undefined) {
            return new CloseBulkJobArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CloseBulkJobArgs from input");
        }
    }
}
export interface IGetTimeStampTokenResultArgs {
    success?: string;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetTimeStampTokenResult {
    public success?: string;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetTimeStampTokenResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetTimeStampTokenResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetTimeStampTokenResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_84: string = input.readString();
                        _args.success = value_84;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_85: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_85;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_86: core.ServerException = core.ServerException.read(input);
                        _args.error = value_86;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetTimeStampTokenResult(_args);
    }
}
export interface ISignAttachmentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class SignAttachmentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ISignAttachmentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SignAttachmentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SignAttachmentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_87: boolean = input.readBool();
                        _args.success = value_87;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_88: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_88;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_89: core.ServerException = core.ServerException.read(input);
                        _args.error = value_89;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SignAttachmentResult(_args);
    }
}
export interface ISignAttachmentUsingServerKeyStorageResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class SignAttachmentUsingServerKeyStorageResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ISignAttachmentUsingServerKeyStorageResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SignAttachmentUsingServerKeyStorageResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SignAttachmentUsingServerKeyStorageResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_90: boolean = input.readBool();
                        _args.success = value_90;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_91: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_91;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_92: core.ServerException = core.ServerException.read(input);
                        _args.error = value_92;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SignAttachmentUsingServerKeyStorageResult(_args);
    }
}
export interface IGetAllDigitalSignsResultArgs {
    success?: Array<DigitalSign.DigitalSign>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllDigitalSignsResult {
    public success?: Array<DigitalSign.DigitalSign>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllDigitalSignsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDigitalSignsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_93: DigitalSign.DigitalSign): void => {
                value_93.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDigitalSignsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_94: Array<DigitalSign.DigitalSign> = new Array<DigitalSign.DigitalSign>();
                        const metadata_7: thrift.TList = input.readListBegin();
                        const size_7: number = metadata_7.size;
                        for (let i_7: number = 0; i_7 < size_7; i_7++) {
                            const value_95: DigitalSign.DigitalSign = DigitalSign.DigitalSign.read(input);
                            value_94.push(value_95);
                        }
                        input.readListEnd();
                        _args.success = value_94;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_96: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_96;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_97: core.ServerException = core.ServerException.read(input);
                        _args.error = value_97;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllDigitalSignsResult(_args);
    }
}
export interface IGetCertificateInfoResultArgs {
    success?: Array<core.CertificateInfo>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetCertificateInfoResult {
    public success?: Array<core.CertificateInfo>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetCertificateInfoResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCertificateInfoResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_98: core.CertificateInfo): void => {
                value_98.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCertificateInfoResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_99: Array<core.CertificateInfo> = new Array<core.CertificateInfo>();
                        const metadata_8: thrift.TList = input.readListBegin();
                        const size_8: number = metadata_8.size;
                        for (let i_8: number = 0; i_8 < size_8; i_8++) {
                            const value_100: core.CertificateInfo = core.CertificateInfo.read(input);
                            value_99.push(value_100);
                        }
                        input.readListEnd();
                        _args.success = value_99;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_101: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_101;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_102: core.ServerException = core.ServerException.read(input);
                        _args.error = value_102;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetCertificateInfoResult(_args);
    }
}
export interface IGetCertificateInfoListByUserResultArgs {
    success?: Array<core.UserKeyData>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetCertificateInfoListByUserResult {
    public success?: Array<core.UserKeyData>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetCertificateInfoListByUserResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCertificateInfoListByUserResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_103: core.UserKeyData): void => {
                value_103.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCertificateInfoListByUserResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_104: Array<core.UserKeyData> = new Array<core.UserKeyData>();
                        const metadata_9: thrift.TList = input.readListBegin();
                        const size_9: number = metadata_9.size;
                        for (let i_9: number = 0; i_9 < size_9; i_9++) {
                            const value_105: core.UserKeyData = core.UserKeyData.read(input);
                            value_104.push(value_105);
                        }
                        input.readListEnd();
                        _args.success = value_104;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_106: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_106;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_107: core.ServerException = core.ServerException.read(input);
                        _args.error = value_107;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetCertificateInfoListByUserResult(_args);
    }
}
export interface IGetSignInfoByCertificateResultArgs {
    success?: core.CertificateInfo;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetSignInfoByCertificateResult {
    public success?: core.CertificateInfo;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetSignInfoByCertificateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetSignInfoByCertificateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetSignInfoByCertificateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_108: core.CertificateInfo = core.CertificateInfo.read(input);
                        _args.success = value_108;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_109: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_109;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_110: core.ServerException = core.ServerException.read(input);
                        _args.error = value_110;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetSignInfoByCertificateResult(_args);
    }
}
export interface IGetSignInfoResultArgs {
    success?: SignInfo.SignInfo;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetSignInfoResult {
    public success?: SignInfo.SignInfo;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetSignInfoResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetSignInfoResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetSignInfoResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_111: SignInfo.SignInfo = SignInfo.SignInfo.read(input);
                        _args.success = value_111;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_112: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_112;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_113: core.ServerException = core.ServerException.read(input);
                        _args.error = value_113;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetSignInfoResult(_args);
    }
}
export interface IGetAllPrivateKeysResultArgs {
    success?: Array<PrivateKeyInfo.PrivateKeyInfo>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllPrivateKeysResult {
    public success?: Array<PrivateKeyInfo.PrivateKeyInfo>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllPrivateKeysResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllPrivateKeysResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_114: PrivateKeyInfo.PrivateKeyInfo): void => {
                value_114.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllPrivateKeysResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_115: Array<PrivateKeyInfo.PrivateKeyInfo> = new Array<PrivateKeyInfo.PrivateKeyInfo>();
                        const metadata_10: thrift.TList = input.readListBegin();
                        const size_10: number = metadata_10.size;
                        for (let i_10: number = 0; i_10 < size_10; i_10++) {
                            const value_116: PrivateKeyInfo.PrivateKeyInfo = PrivateKeyInfo.PrivateKeyInfo.read(input);
                            value_115.push(value_116);
                        }
                        input.readListEnd();
                        _args.success = value_115;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_117: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_117;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_118: core.ServerException = core.ServerException.read(input);
                        _args.error = value_118;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllPrivateKeysResult(_args);
    }
}
export interface IGetCountPrivateKeysResultArgs {
    success?: number;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetCountPrivateKeysResult {
    public success?: number;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetCountPrivateKeysResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountPrivateKeysResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
            output.writeI32(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountPrivateKeysResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_119: number = input.readI32();
                        _args.success = value_119;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_120: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_120;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_121: core.ServerException = core.ServerException.read(input);
                        _args.error = value_121;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetCountPrivateKeysResult(_args);
    }
}
export interface IAddKeyToSecureStorageResultArgs {
    success?: PrivateKeyInfo.PrivateKeyInfo;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class AddKeyToSecureStorageResult {
    public success?: PrivateKeyInfo.PrivateKeyInfo;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IAddKeyToSecureStorageResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddKeyToSecureStorageResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddKeyToSecureStorageResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_122: PrivateKeyInfo.PrivateKeyInfo = PrivateKeyInfo.PrivateKeyInfo.read(input);
                        _args.success = value_122;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_123: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_123;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_124: core.ServerException = core.ServerException.read(input);
                        _args.error = value_124;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AddKeyToSecureStorageResult(_args);
    }
}
export interface IRemoveKeyFromSecureStorageResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class RemoveKeyFromSecureStorageResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IRemoveKeyFromSecureStorageResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveKeyFromSecureStorageResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveKeyFromSecureStorageResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_125: boolean = input.readBool();
                        _args.success = value_125;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_126: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_126;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_127: core.ServerException = core.ServerException.read(input);
                        _args.error = value_127;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveKeyFromSecureStorageResult(_args);
    }
}
export interface IGetDigitalSignByAttachmentIdResultArgs {
    success?: Map<string, boolean>;
}
export class GetDigitalSignByAttachmentIdResult {
    public success?: Map<string, boolean>;
    constructor(args?: IGetDigitalSignByAttachmentIdResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDigitalSignByAttachmentIdResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.MAP, 0);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.BOOL, this.success.size);
            this.success.forEach((value_128: boolean, key_1: string): void => {
                output.writeString(key_1);
                output.writeBool(value_128);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDigitalSignByAttachmentIdResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_129: Map<string, boolean> = new Map<string, boolean>();
                        const metadata_11: thrift.TMap = input.readMapBegin();
                        const size_11: number = metadata_11.size;
                        for (let i_11: number = 0; i_11 < size_11; i_11++) {
                            const key_2: string = input.readString();
                            const value_130: boolean = input.readBool();
                            value_129.set(key_2, value_130);
                        }
                        input.readMapEnd();
                        _args.success = value_129;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetDigitalSignByAttachmentIdResult(_args);
    }
}
export interface IAddExternalSignToAttachmentResultArgs {
    success?: boolean;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class AddExternalSignToAttachmentResult {
    public success?: boolean;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IAddExternalSignToAttachmentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddExternalSignToAttachmentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddExternalSignToAttachmentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_131: boolean = input.readBool();
                        _args.success = value_131;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_132: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_132;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_133: core.ServerException = core.ServerException.read(input);
                        _args.error = value_133;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AddExternalSignToAttachmentResult(_args);
    }
}
export interface ISingAnyDataResultArgs {
    success?: Array<core.SignData>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class SingAnyDataResult {
    public success?: Array<core.SignData>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ISingAnyDataResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SingAnyDataResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_134: core.SignData): void => {
                value_134.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SingAnyDataResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_135: Array<core.SignData> = new Array<core.SignData>();
                        const metadata_12: thrift.TList = input.readListBegin();
                        const size_12: number = metadata_12.size;
                        for (let i_12: number = 0; i_12 < size_12; i_12++) {
                            const value_136: core.SignData = core.SignData.read(input);
                            value_135.push(value_136);
                        }
                        input.readListEnd();
                        _args.success = value_135;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_137: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_137;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_138: core.ServerException = core.ServerException.read(input);
                        _args.error = value_138;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SingAnyDataResult(_args);
    }
}
export interface ISignInExternalServiceResultArgs {
    success?: ExtSignOperation.ExtSignOperation;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class SignInExternalServiceResult {
    public success?: ExtSignOperation.ExtSignOperation;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ISignInExternalServiceResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SignInExternalServiceResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SignInExternalServiceResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_139: ExtSignOperation.ExtSignOperation = ExtSignOperation.ExtSignOperation.read(input);
                        _args.success = value_139;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_140: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_140;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_141: core.ServerException = core.ServerException.read(input);
                        _args.error = value_141;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SignInExternalServiceResult(_args);
    }
}
export interface ICheckSignStatusInExternalServiceResultArgs {
    success?: ExtSignOperation.ExtSignOperation;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CheckSignStatusInExternalServiceResult {
    public success?: ExtSignOperation.ExtSignOperation;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICheckSignStatusInExternalServiceResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CheckSignStatusInExternalServiceResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CheckSignStatusInExternalServiceResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_142: ExtSignOperation.ExtSignOperation = ExtSignOperation.ExtSignOperation.read(input);
                        _args.success = value_142;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_143: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_143;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_144: core.ServerException = core.ServerException.read(input);
                        _args.error = value_144;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CheckSignStatusInExternalServiceResult(_args);
    }
}
export interface IExtractPublicKeyInfoResultArgs {
    success?: core.CertificateInfo;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class ExtractPublicKeyInfoResult {
    public success?: core.CertificateInfo;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IExtractPublicKeyInfoResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExtractPublicKeyInfoResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExtractPublicKeyInfoResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_145: core.CertificateInfo = core.CertificateInfo.read(input);
                        _args.success = value_145;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_146: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_146;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_147: core.ServerException = core.ServerException.read(input);
                        _args.error = value_147;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExtractPublicKeyInfoResult(_args);
    }
}
export interface IGetAllExternalSignServiceInfosResultArgs {
    success?: Array<ExtSignServer.ExtSignServer>;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetAllExternalSignServiceInfosResult {
    public success?: Array<ExtSignServer.ExtSignServer>;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetAllExternalSignServiceInfosResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllExternalSignServiceInfosResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_148: ExtSignServer.ExtSignServer): void => {
                value_148.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllExternalSignServiceInfosResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_149: Array<ExtSignServer.ExtSignServer> = new Array<ExtSignServer.ExtSignServer>();
                        const metadata_13: thrift.TList = input.readListBegin();
                        const size_13: number = metadata_13.size;
                        for (let i_13: number = 0; i_13 < size_13; i_13++) {
                            const value_150: ExtSignServer.ExtSignServer = ExtSignServer.ExtSignServer.read(input);
                            value_149.push(value_150);
                        }
                        input.readListEnd();
                        _args.success = value_149;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_151: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_151;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_152: core.ServerException = core.ServerException.read(input);
                        _args.error = value_152;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllExternalSignServiceInfosResult(_args);
    }
}
export interface IGetCurrentBulkSignJobResultArgs {
    success?: BulkSignJob.BulkSignJob;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetCurrentBulkSignJobResult {
    public success?: BulkSignJob.BulkSignJob;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetCurrentBulkSignJobResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCurrentBulkSignJobResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCurrentBulkSignJobResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_153: BulkSignJob.BulkSignJob = BulkSignJob.BulkSignJob.read(input);
                        _args.success = value_153;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_154: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_154;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_155: core.ServerException = core.ServerException.read(input);
                        _args.error = value_155;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetCurrentBulkSignJobResult(_args);
    }
}
export interface IGetFullBulkSignJobResultArgs {
    success?: BulkSignJob.BulkSignJob;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class GetFullBulkSignJobResult {
    public success?: BulkSignJob.BulkSignJob;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IGetFullBulkSignJobResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetFullBulkSignJobResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetFullBulkSignJobResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_156: BulkSignJob.BulkSignJob = BulkSignJob.BulkSignJob.read(input);
                        _args.success = value_156;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_157: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_157;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_158: core.ServerException = core.ServerException.read(input);
                        _args.error = value_158;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetFullBulkSignJobResult(_args);
    }
}
export interface IRemoveFromCurrentBulkSignJobResultArgs {
    success?: BulkSignInfo.BulkSignInfo;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class RemoveFromCurrentBulkSignJobResult {
    public success?: BulkSignInfo.BulkSignInfo;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IRemoveFromCurrentBulkSignJobResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveFromCurrentBulkSignJobResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveFromCurrentBulkSignJobResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_159: BulkSignInfo.BulkSignInfo = BulkSignInfo.BulkSignInfo.read(input);
                        _args.success = value_159;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_160: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_160;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_161: core.ServerException = core.ServerException.read(input);
                        _args.error = value_161;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveFromCurrentBulkSignJobResult(_args);
    }
}
export interface IAddToCurrentBulkSignJobResultArgs {
    success?: BulkSignInfo.BulkSignInfo;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class AddToCurrentBulkSignJobResult {
    public success?: BulkSignInfo.BulkSignInfo;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: IAddToCurrentBulkSignJobResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AddToCurrentBulkSignJobResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AddToCurrentBulkSignJobResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_162: BulkSignInfo.BulkSignInfo = BulkSignInfo.BulkSignInfo.read(input);
                        _args.success = value_162;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_163: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_163;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_164: core.ServerException = core.ServerException.read(input);
                        _args.error = value_164;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AddToCurrentBulkSignJobResult(_args);
    }
}
export interface ISignBulkJobResultArgs {
    success?: BulkSignJob.BulkSignJob;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class SignBulkJobResult {
    public success?: BulkSignJob.BulkSignJob;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ISignBulkJobResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SignBulkJobResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SignBulkJobResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_165: BulkSignJob.BulkSignJob = BulkSignJob.BulkSignJob.read(input);
                        _args.success = value_165;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_166: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_166;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_167: core.ServerException = core.ServerException.read(input);
                        _args.error = value_167;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SignBulkJobResult(_args);
    }
}
export interface ICancelBulkJobResultArgs {
    success?: BulkSignJob.BulkSignJob;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CancelBulkJobResult {
    public success?: BulkSignJob.BulkSignJob;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICancelBulkJobResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CancelBulkJobResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CancelBulkJobResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_168: BulkSignJob.BulkSignJob = BulkSignJob.BulkSignJob.read(input);
                        _args.success = value_168;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_169: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_169;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_170: core.ServerException = core.ServerException.read(input);
                        _args.error = value_170;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CancelBulkJobResult(_args);
    }
}
export interface ICloseBulkJobResultArgs {
    success?: BulkSignJob.BulkSignJob;
    validError?: core.PreconditionException;
    error?: core.ServerException;
}
export class CloseBulkJobResult {
    public success?: BulkSignJob.BulkSignJob;
    public validError?: core.PreconditionException;
    public error?: core.ServerException;
    constructor(args?: ICloseBulkJobResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CloseBulkJobResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CloseBulkJobResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_171: BulkSignJob.BulkSignJob = BulkSignJob.BulkSignJob.read(input);
                        _args.success = value_171;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_172: core.PreconditionException = core.PreconditionException.read(input);
                        _args.validError = value_172;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_173: core.ServerException = core.ServerException.read(input);
                        _args.error = value_173;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CloseBulkJobResult(_args);
    }
}
export class Client {
    public _seqid: number;
    public _reqs: {
        [name: number]: (err: Error | object | undefined, val?: any) => void;
    };
    public output: thrift.TTransport;
    public protocol: new (trans: thrift.TTransport) => thrift.TProtocol;
    constructor(output: thrift.TTransport, protocol: new (trans: thrift.TTransport) => thrift.TProtocol) {
        this._seqid = 0;
        this._reqs = {};
        this.output = output;
        this.protocol = protocol;
    }
    public incrementSeqId(): number {
        return this._seqid += 1;
    }
    public getTimeStampToken(token: string, data: string): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getTimeStampToken(token, data, requestId);
        });
    }
    public signAttachment(token: string, attachmentId: string, signatures: Array<string>): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_signAttachment(token, attachmentId, signatures, requestId);
        });
    }
    public signAttachmentUsingServerKeyStorage(token: string, attachmentId: string, pKeyId: string, password: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_signAttachmentUsingServerKeyStorage(token, attachmentId, pKeyId, password, requestId);
        });
    }
    public getAllDigitalSigns(token: string, documentId: string, filter: core.KazFilter): Promise<Array<DigitalSign.DigitalSign>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<DigitalSign.DigitalSign>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllDigitalSigns(token, documentId, filter, requestId);
        });
    }
    public getCertificateInfo(token: string, digitalSignId: string): Promise<Array<core.CertificateInfo>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<core.CertificateInfo>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getCertificateInfo(token, digitalSignId, requestId);
        });
    }
    public getCertificateInfoListByUser(token: string, userId: string): Promise<Array<core.UserKeyData>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<core.UserKeyData>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getCertificateInfoListByUser(token, userId, requestId);
        });
    }
    public getSignInfoByCertificate(token: string, data: string): Promise<core.CertificateInfo> {
        const requestId: number = this.incrementSeqId();
        return new Promise<core.CertificateInfo>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getSignInfoByCertificate(token, data, requestId);
        });
    }
    public getSignInfo(digitalSignId: string): Promise<SignInfo.SignInfo> {
        const requestId: number = this.incrementSeqId();
        return new Promise<SignInfo.SignInfo>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getSignInfo(digitalSignId, requestId);
        });
    }
    public getAllPrivateKeys(token: string, filter: core.KazFilter): Promise<Array<PrivateKeyInfo.PrivateKeyInfo>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<PrivateKeyInfo.PrivateKeyInfo>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllPrivateKeys(token, filter, requestId);
        });
    }
    public getCountPrivateKeys(token: string, filter: core.KazFilter): Promise<number> {
        const requestId: number = this.incrementSeqId();
        return new Promise<number>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getCountPrivateKeys(token, filter, requestId);
        });
    }
    public addKeyToSecureStorage(token: string, key1: Buffer, password: string, name: string, fileExt: string, privateKeyIndexInJKS: string): Promise<PrivateKeyInfo.PrivateKeyInfo> {
        const requestId: number = this.incrementSeqId();
        return new Promise<PrivateKeyInfo.PrivateKeyInfo>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_addKeyToSecureStorage(token, key1, password, name, fileExt, privateKeyIndexInJKS, requestId);
        });
    }
    public removeKeyFromSecureStorage(token: string, id: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeKeyFromSecureStorage(token, id, requestId);
        });
    }
    public getDigitalSignByAttachmentId(token: string, attachmentId: string): Promise<Map<string, boolean>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Map<string, boolean>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getDigitalSignByAttachmentId(token, attachmentId, requestId);
        });
    }
    public addExternalSignToAttachment(token: string, attachmentId: string, p7s: Array<Buffer>): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_addExternalSignToAttachment(token, attachmentId, p7s, requestId);
        });
    }
    public singAnyData(token: string, keyInfoList: Array<core.SignKeyInfo>, dataToSignList: Array<core.SignData>): Promise<Array<core.SignData>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<core.SignData>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_singAnyData(token, keyInfoList, dataToSignList, requestId);
        });
    }
    public signInExternalService(token: string, serviceKey: string, dataToSignList: Array<core.SignData>): Promise<ExtSignOperation.ExtSignOperation> {
        const requestId: number = this.incrementSeqId();
        return new Promise<ExtSignOperation.ExtSignOperation>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_signInExternalService(token, serviceKey, dataToSignList, requestId);
        });
    }
    public checkSignStatusInExternalService(token: string, serviceKey: string, signOperation: ExtSignOperation.ExtSignOperation): Promise<ExtSignOperation.ExtSignOperation> {
        const requestId: number = this.incrementSeqId();
        return new Promise<ExtSignOperation.ExtSignOperation>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_checkSignStatusInExternalService(token, serviceKey, signOperation, requestId);
        });
    }
    public extractPublicKeyInfo(token: string, keyInfo: core.SignKeyInfo): Promise<core.CertificateInfo> {
        const requestId: number = this.incrementSeqId();
        return new Promise<core.CertificateInfo>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_extractPublicKeyInfo(token, keyInfo, requestId);
        });
    }
    public getAllExternalSignServiceInfos(token: string, filter: core.KazFilter): Promise<Array<ExtSignServer.ExtSignServer>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<ExtSignServer.ExtSignServer>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllExternalSignServiceInfos(token, filter, requestId);
        });
    }
    public getCurrentBulkSignJob(token: string): Promise<BulkSignJob.BulkSignJob> {
        const requestId: number = this.incrementSeqId();
        return new Promise<BulkSignJob.BulkSignJob>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getCurrentBulkSignJob(token, requestId);
        });
    }
    public getFullBulkSignJob(token: string, bulkId: string, filter: core.KazFilter): Promise<BulkSignJob.BulkSignJob> {
        const requestId: number = this.incrementSeqId();
        return new Promise<BulkSignJob.BulkSignJob>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getFullBulkSignJob(token, bulkId, filter, requestId);
        });
    }
    public removeFromCurrentBulkSignJob(token: string, bulkId: string, signDocId: string, signAttId: string, attId: string): Promise<BulkSignInfo.BulkSignInfo> {
        const requestId: number = this.incrementSeqId();
        return new Promise<BulkSignInfo.BulkSignInfo>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeFromCurrentBulkSignJob(token, bulkId, signDocId, signAttId, attId, requestId);
        });
    }
    public addToCurrentBulkSignJob(token: string, bulkId: string, accessPolicy: core.DocumentAccessPolicy, attId: string): Promise<BulkSignInfo.BulkSignInfo> {
        const requestId: number = this.incrementSeqId();
        return new Promise<BulkSignInfo.BulkSignInfo>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_addToCurrentBulkSignJob(token, bulkId, accessPolicy, attId, requestId);
        });
    }
    public signBulkJob(token: string, keyInfoList: Array<core.SignKeyInfo>, bulkId: string, setAutoDecision: boolean): Promise<BulkSignJob.BulkSignJob> {
        const requestId: number = this.incrementSeqId();
        return new Promise<BulkSignJob.BulkSignJob>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_signBulkJob(token, keyInfoList, bulkId, setAutoDecision, requestId);
        });
    }
    public cancelBulkJob(token: string, bulkId: string): Promise<BulkSignJob.BulkSignJob> {
        const requestId: number = this.incrementSeqId();
        return new Promise<BulkSignJob.BulkSignJob>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_cancelBulkJob(token, bulkId, requestId);
        });
    }
    public closeBulkJob(token: string, bulkId: string, copyFailedDocs: boolean): Promise<BulkSignJob.BulkSignJob> {
        const requestId: number = this.incrementSeqId();
        return new Promise<BulkSignJob.BulkSignJob>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_closeBulkJob(token, bulkId, copyFailedDocs, requestId);
        });
    }
    public send_getTimeStampToken(token: string, data: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getTimeStampToken", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetTimeStampTokenArgs = new GetTimeStampTokenArgs({ token, data });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_signAttachment(token: string, attachmentId: string, signatures: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("signAttachment", thrift.Thrift.MessageType.CALL, requestId);
        const args: SignAttachmentArgs = new SignAttachmentArgs({ token, attachmentId, signatures });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_signAttachmentUsingServerKeyStorage(token: string, attachmentId: string, pKeyId: string, password: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("signAttachmentUsingServerKeyStorage", thrift.Thrift.MessageType.CALL, requestId);
        const args: SignAttachmentUsingServerKeyStorageArgs = new SignAttachmentUsingServerKeyStorageArgs({ token, attachmentId, pKeyId, password });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllDigitalSigns(token: string, documentId: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllDigitalSigns", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllDigitalSignsArgs = new GetAllDigitalSignsArgs({ token, documentId, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getCertificateInfo(token: string, digitalSignId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getCertificateInfo", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetCertificateInfoArgs = new GetCertificateInfoArgs({ token, digitalSignId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getCertificateInfoListByUser(token: string, userId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getCertificateInfoListByUser", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetCertificateInfoListByUserArgs = new GetCertificateInfoListByUserArgs({ token, userId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getSignInfoByCertificate(token: string, data: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getSignInfoByCertificate", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetSignInfoByCertificateArgs = new GetSignInfoByCertificateArgs({ token, data });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getSignInfo(digitalSignId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getSignInfo", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetSignInfoArgs = new GetSignInfoArgs({ digitalSignId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllPrivateKeys(token: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllPrivateKeys", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllPrivateKeysArgs = new GetAllPrivateKeysArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getCountPrivateKeys(token: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getCountPrivateKeys", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetCountPrivateKeysArgs = new GetCountPrivateKeysArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_addKeyToSecureStorage(token: string, key1: Buffer, password: string, name: string, fileExt: string, privateKeyIndexInJKS: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("addKeyToSecureStorage", thrift.Thrift.MessageType.CALL, requestId);
        const args: AddKeyToSecureStorageArgs = new AddKeyToSecureStorageArgs({ token, key1, password, name, fileExt, privateKeyIndexInJKS });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeKeyFromSecureStorage(token: string, id: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeKeyFromSecureStorage", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveKeyFromSecureStorageArgs = new RemoveKeyFromSecureStorageArgs({ token, id });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getDigitalSignByAttachmentId(token: string, attachmentId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getDigitalSignByAttachmentId", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetDigitalSignByAttachmentIdArgs = new GetDigitalSignByAttachmentIdArgs({ token, attachmentId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_addExternalSignToAttachment(token: string, attachmentId: string, p7s: Array<Buffer>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("addExternalSignToAttachment", thrift.Thrift.MessageType.CALL, requestId);
        const args: AddExternalSignToAttachmentArgs = new AddExternalSignToAttachmentArgs({ token, attachmentId, p7s });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_singAnyData(token: string, keyInfoList: Array<core.SignKeyInfo>, dataToSignList: Array<core.SignData>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("singAnyData", thrift.Thrift.MessageType.CALL, requestId);
        const args: SingAnyDataArgs = new SingAnyDataArgs({ token, keyInfoList, dataToSignList });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_signInExternalService(token: string, serviceKey: string, dataToSignList: Array<core.SignData>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("signInExternalService", thrift.Thrift.MessageType.CALL, requestId);
        const args: SignInExternalServiceArgs = new SignInExternalServiceArgs({ token, serviceKey, dataToSignList });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_checkSignStatusInExternalService(token: string, serviceKey: string, signOperation: ExtSignOperation.ExtSignOperation, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("checkSignStatusInExternalService", thrift.Thrift.MessageType.CALL, requestId);
        const args: CheckSignStatusInExternalServiceArgs = new CheckSignStatusInExternalServiceArgs({ token, serviceKey, signOperation });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_extractPublicKeyInfo(token: string, keyInfo: core.SignKeyInfo, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("extractPublicKeyInfo", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExtractPublicKeyInfoArgs = new ExtractPublicKeyInfoArgs({ token, keyInfo });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllExternalSignServiceInfos(token: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllExternalSignServiceInfos", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllExternalSignServiceInfosArgs = new GetAllExternalSignServiceInfosArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getCurrentBulkSignJob(token: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getCurrentBulkSignJob", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetCurrentBulkSignJobArgs = new GetCurrentBulkSignJobArgs({ token });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getFullBulkSignJob(token: string, bulkId: string, filter: core.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getFullBulkSignJob", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetFullBulkSignJobArgs = new GetFullBulkSignJobArgs({ token, bulkId, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeFromCurrentBulkSignJob(token: string, bulkId: string, signDocId: string, signAttId: string, attId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeFromCurrentBulkSignJob", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveFromCurrentBulkSignJobArgs = new RemoveFromCurrentBulkSignJobArgs({ token, bulkId, signDocId, signAttId, attId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_addToCurrentBulkSignJob(token: string, bulkId: string, accessPolicy: core.DocumentAccessPolicy, attId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("addToCurrentBulkSignJob", thrift.Thrift.MessageType.CALL, requestId);
        const args: AddToCurrentBulkSignJobArgs = new AddToCurrentBulkSignJobArgs({ token, bulkId, accessPolicy, attId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_signBulkJob(token: string, keyInfoList: Array<core.SignKeyInfo>, bulkId: string, setAutoDecision: boolean, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("signBulkJob", thrift.Thrift.MessageType.CALL, requestId);
        const args: SignBulkJobArgs = new SignBulkJobArgs({ token, keyInfoList, bulkId, setAutoDecision });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_cancelBulkJob(token: string, bulkId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("cancelBulkJob", thrift.Thrift.MessageType.CALL, requestId);
        const args: CancelBulkJobArgs = new CancelBulkJobArgs({ token, bulkId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_closeBulkJob(token: string, bulkId: string, copyFailedDocs: boolean, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("closeBulkJob", thrift.Thrift.MessageType.CALL, requestId);
        const args: CloseBulkJobArgs = new CloseBulkJobArgs({ token, bulkId, copyFailedDocs });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public recv_getTimeStampToken(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetTimeStampTokenResult = GetTimeStampTokenResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getTimeStampToken failed: unknown result"));
                }
            }
        }
    }
    public recv_signAttachment(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SignAttachmentResult = SignAttachmentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "signAttachment failed: unknown result"));
                }
            }
        }
    }
    public recv_signAttachmentUsingServerKeyStorage(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SignAttachmentUsingServerKeyStorageResult = SignAttachmentUsingServerKeyStorageResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "signAttachmentUsingServerKeyStorage failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllDigitalSigns(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllDigitalSignsResult = GetAllDigitalSignsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllDigitalSigns failed: unknown result"));
                }
            }
        }
    }
    public recv_getCertificateInfo(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetCertificateInfoResult = GetCertificateInfoResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getCertificateInfo failed: unknown result"));
                }
            }
        }
    }
    public recv_getCertificateInfoListByUser(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetCertificateInfoListByUserResult = GetCertificateInfoListByUserResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getCertificateInfoListByUser failed: unknown result"));
                }
            }
        }
    }
    public recv_getSignInfoByCertificate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetSignInfoByCertificateResult = GetSignInfoByCertificateResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getSignInfoByCertificate failed: unknown result"));
                }
            }
        }
    }
    public recv_getSignInfo(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetSignInfoResult = GetSignInfoResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getSignInfo failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllPrivateKeys(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllPrivateKeysResult = GetAllPrivateKeysResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllPrivateKeys failed: unknown result"));
                }
            }
        }
    }
    public recv_getCountPrivateKeys(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetCountPrivateKeysResult = GetCountPrivateKeysResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getCountPrivateKeys failed: unknown result"));
                }
            }
        }
    }
    public recv_addKeyToSecureStorage(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AddKeyToSecureStorageResult = AddKeyToSecureStorageResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addKeyToSecureStorage failed: unknown result"));
                }
            }
        }
    }
    public recv_removeKeyFromSecureStorage(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveKeyFromSecureStorageResult = RemoveKeyFromSecureStorageResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeKeyFromSecureStorage failed: unknown result"));
                }
            }
        }
    }
    public recv_getDigitalSignByAttachmentId(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetDigitalSignByAttachmentIdResult = GetDigitalSignByAttachmentIdResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getDigitalSignByAttachmentId failed: unknown result"));
            }
        }
    }
    public recv_addExternalSignToAttachment(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AddExternalSignToAttachmentResult = AddExternalSignToAttachmentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addExternalSignToAttachment failed: unknown result"));
                }
            }
        }
    }
    public recv_singAnyData(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SingAnyDataResult = SingAnyDataResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "singAnyData failed: unknown result"));
                }
            }
        }
    }
    public recv_signInExternalService(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SignInExternalServiceResult = SignInExternalServiceResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "signInExternalService failed: unknown result"));
                }
            }
        }
    }
    public recv_checkSignStatusInExternalService(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CheckSignStatusInExternalServiceResult = CheckSignStatusInExternalServiceResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "checkSignStatusInExternalService failed: unknown result"));
                }
            }
        }
    }
    public recv_extractPublicKeyInfo(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExtractPublicKeyInfoResult = ExtractPublicKeyInfoResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "extractPublicKeyInfo failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllExternalSignServiceInfos(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllExternalSignServiceInfosResult = GetAllExternalSignServiceInfosResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllExternalSignServiceInfos failed: unknown result"));
                }
            }
        }
    }
    public recv_getCurrentBulkSignJob(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetCurrentBulkSignJobResult = GetCurrentBulkSignJobResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getCurrentBulkSignJob failed: unknown result"));
                }
            }
        }
    }
    public recv_getFullBulkSignJob(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetFullBulkSignJobResult = GetFullBulkSignJobResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getFullBulkSignJob failed: unknown result"));
                }
            }
        }
    }
    public recv_removeFromCurrentBulkSignJob(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveFromCurrentBulkSignJobResult = RemoveFromCurrentBulkSignJobResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeFromCurrentBulkSignJob failed: unknown result"));
                }
            }
        }
    }
    public recv_addToCurrentBulkSignJob(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AddToCurrentBulkSignJobResult = AddToCurrentBulkSignJobResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addToCurrentBulkSignJob failed: unknown result"));
                }
            }
        }
    }
    public recv_signBulkJob(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SignBulkJobResult = SignBulkJobResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "signBulkJob failed: unknown result"));
                }
            }
        }
    }
    public recv_cancelBulkJob(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CancelBulkJobResult = CancelBulkJobResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "cancelBulkJob failed: unknown result"));
                }
            }
        }
    }
    public recv_closeBulkJob(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CloseBulkJobResult = CloseBulkJobResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "closeBulkJob failed: unknown result"));
                }
            }
        }
    }
}
export interface IHandler {
    getTimeStampToken(token: string, data: string): string | Promise<string>;
    signAttachment(token: string, attachmentId: string, signatures: Array<string>): boolean | Promise<boolean>;
    signAttachmentUsingServerKeyStorage(token: string, attachmentId: string, pKeyId: string, password: string): boolean | Promise<boolean>;
    getAllDigitalSigns(token: string, documentId: string, filter: core.KazFilter): Array<DigitalSign.DigitalSign> | Promise<Array<DigitalSign.DigitalSign>>;
    getCertificateInfo(token: string, digitalSignId: string): Array<core.CertificateInfo> | Promise<Array<core.CertificateInfo>>;
    getCertificateInfoListByUser(token: string, userId: string): Array<core.UserKeyData> | Promise<Array<core.UserKeyData>>;
    getSignInfoByCertificate(token: string, data: string): core.CertificateInfo | Promise<core.CertificateInfo>;
    getSignInfo(digitalSignId: string): SignInfo.SignInfo | Promise<SignInfo.SignInfo>;
    getAllPrivateKeys(token: string, filter: core.KazFilter): Array<PrivateKeyInfo.PrivateKeyInfo> | Promise<Array<PrivateKeyInfo.PrivateKeyInfo>>;
    getCountPrivateKeys(token: string, filter: core.KazFilter): number | Promise<number>;
    addKeyToSecureStorage(token: string, key1: Buffer, password: string, name: string, fileExt: string, privateKeyIndexInJKS: string): PrivateKeyInfo.PrivateKeyInfo | Promise<PrivateKeyInfo.PrivateKeyInfo>;
    removeKeyFromSecureStorage(token: string, id: string): boolean | Promise<boolean>;
    getDigitalSignByAttachmentId(token: string, attachmentId: string): Map<string, boolean> | Promise<Map<string, boolean>>;
    addExternalSignToAttachment(token: string, attachmentId: string, p7s: Array<Buffer>): boolean | Promise<boolean>;
    singAnyData(token: string, keyInfoList: Array<core.SignKeyInfo>, dataToSignList: Array<core.SignData>): Array<core.SignData> | Promise<Array<core.SignData>>;
    signInExternalService(token: string, serviceKey: string, dataToSignList: Array<core.SignData>): ExtSignOperation.ExtSignOperation | Promise<ExtSignOperation.ExtSignOperation>;
    checkSignStatusInExternalService(token: string, serviceKey: string, signOperation: ExtSignOperation.ExtSignOperation): ExtSignOperation.ExtSignOperation | Promise<ExtSignOperation.ExtSignOperation>;
    extractPublicKeyInfo(token: string, keyInfo: core.SignKeyInfo): core.CertificateInfo | Promise<core.CertificateInfo>;
    getAllExternalSignServiceInfos(token: string, filter: core.KazFilter): Array<ExtSignServer.ExtSignServer> | Promise<Array<ExtSignServer.ExtSignServer>>;
    getCurrentBulkSignJob(token: string): BulkSignJob.BulkSignJob | Promise<BulkSignJob.BulkSignJob>;
    getFullBulkSignJob(token: string, bulkId: string, filter: core.KazFilter): BulkSignJob.BulkSignJob | Promise<BulkSignJob.BulkSignJob>;
    removeFromCurrentBulkSignJob(token: string, bulkId: string, signDocId: string, signAttId: string, attId: string): BulkSignInfo.BulkSignInfo | Promise<BulkSignInfo.BulkSignInfo>;
    addToCurrentBulkSignJob(token: string, bulkId: string, accessPolicy: core.DocumentAccessPolicy, attId: string): BulkSignInfo.BulkSignInfo | Promise<BulkSignInfo.BulkSignInfo>;
    signBulkJob(token: string, keyInfoList: Array<core.SignKeyInfo>, bulkId: string, setAutoDecision: boolean): BulkSignJob.BulkSignJob | Promise<BulkSignJob.BulkSignJob>;
    cancelBulkJob(token: string, bulkId: string): BulkSignJob.BulkSignJob | Promise<BulkSignJob.BulkSignJob>;
    closeBulkJob(token: string, bulkId: string, copyFailedDocs: boolean): BulkSignJob.BulkSignJob | Promise<BulkSignJob.BulkSignJob>;
}
export class Processor {
    public _handler: IHandler;
    constructor(handler: IHandler) {
        this._handler = handler;
    }
    public process(input: thrift.TProtocol, output: thrift.TProtocol): void {
        const metadata: thrift.TMessage = input.readMessageBegin();
        const fname: string = metadata.fname;
        const requestId: number = metadata.rseqid;
        const methodName: string = "process_" + fname;
        switch (methodName) {
            case "process_getTimeStampToken": {
                this.process_getTimeStampToken(requestId, input, output);
                return;
            }
            case "process_signAttachment": {
                this.process_signAttachment(requestId, input, output);
                return;
            }
            case "process_signAttachmentUsingServerKeyStorage": {
                this.process_signAttachmentUsingServerKeyStorage(requestId, input, output);
                return;
            }
            case "process_getAllDigitalSigns": {
                this.process_getAllDigitalSigns(requestId, input, output);
                return;
            }
            case "process_getCertificateInfo": {
                this.process_getCertificateInfo(requestId, input, output);
                return;
            }
            case "process_getCertificateInfoListByUser": {
                this.process_getCertificateInfoListByUser(requestId, input, output);
                return;
            }
            case "process_getSignInfoByCertificate": {
                this.process_getSignInfoByCertificate(requestId, input, output);
                return;
            }
            case "process_getSignInfo": {
                this.process_getSignInfo(requestId, input, output);
                return;
            }
            case "process_getAllPrivateKeys": {
                this.process_getAllPrivateKeys(requestId, input, output);
                return;
            }
            case "process_getCountPrivateKeys": {
                this.process_getCountPrivateKeys(requestId, input, output);
                return;
            }
            case "process_addKeyToSecureStorage": {
                this.process_addKeyToSecureStorage(requestId, input, output);
                return;
            }
            case "process_removeKeyFromSecureStorage": {
                this.process_removeKeyFromSecureStorage(requestId, input, output);
                return;
            }
            case "process_getDigitalSignByAttachmentId": {
                this.process_getDigitalSignByAttachmentId(requestId, input, output);
                return;
            }
            case "process_addExternalSignToAttachment": {
                this.process_addExternalSignToAttachment(requestId, input, output);
                return;
            }
            case "process_singAnyData": {
                this.process_singAnyData(requestId, input, output);
                return;
            }
            case "process_signInExternalService": {
                this.process_signInExternalService(requestId, input, output);
                return;
            }
            case "process_checkSignStatusInExternalService": {
                this.process_checkSignStatusInExternalService(requestId, input, output);
                return;
            }
            case "process_extractPublicKeyInfo": {
                this.process_extractPublicKeyInfo(requestId, input, output);
                return;
            }
            case "process_getAllExternalSignServiceInfos": {
                this.process_getAllExternalSignServiceInfos(requestId, input, output);
                return;
            }
            case "process_getCurrentBulkSignJob": {
                this.process_getCurrentBulkSignJob(requestId, input, output);
                return;
            }
            case "process_getFullBulkSignJob": {
                this.process_getFullBulkSignJob(requestId, input, output);
                return;
            }
            case "process_removeFromCurrentBulkSignJob": {
                this.process_removeFromCurrentBulkSignJob(requestId, input, output);
                return;
            }
            case "process_addToCurrentBulkSignJob": {
                this.process_addToCurrentBulkSignJob(requestId, input, output);
                return;
            }
            case "process_signBulkJob": {
                this.process_signBulkJob(requestId, input, output);
                return;
            }
            case "process_cancelBulkJob": {
                this.process_cancelBulkJob(requestId, input, output);
                return;
            }
            case "process_closeBulkJob": {
                this.process_closeBulkJob(requestId, input, output);
                return;
            }
            default: {
                input.skip(thrift.Thrift.Type.STRUCT);
                input.readMessageEnd();
                const errMessage = "Unknown function " + fname;
                const err = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                output.writeMessageBegin(fname, thrift.Thrift.MessageType.EXCEPTION, requestId);
                err.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        }
    }
    public process_getTimeStampToken(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: GetTimeStampTokenArgs = GetTimeStampTokenArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getTimeStampToken(args.token, args.data));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: GetTimeStampTokenResult = new GetTimeStampTokenResult({ success: data });
            output.writeMessageBegin("getTimeStampToken", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetTimeStampTokenResult = new GetTimeStampTokenResult({ validError: err });
                output.writeMessageBegin("getTimeStampToken", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetTimeStampTokenResult = new GetTimeStampTokenResult({ error: err });
                output.writeMessageBegin("getTimeStampToken", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getTimeStampToken", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_signAttachment(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: SignAttachmentArgs = SignAttachmentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.signAttachment(args.token, args.attachmentId, args.signatures));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: SignAttachmentResult = new SignAttachmentResult({ success: data });
            output.writeMessageBegin("signAttachment", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: SignAttachmentResult = new SignAttachmentResult({ validError: err });
                output.writeMessageBegin("signAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: SignAttachmentResult = new SignAttachmentResult({ error: err });
                output.writeMessageBegin("signAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("signAttachment", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_signAttachmentUsingServerKeyStorage(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: SignAttachmentUsingServerKeyStorageArgs = SignAttachmentUsingServerKeyStorageArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.signAttachmentUsingServerKeyStorage(args.token, args.attachmentId, args.pKeyId, args.password));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: SignAttachmentUsingServerKeyStorageResult = new SignAttachmentUsingServerKeyStorageResult({ success: data });
            output.writeMessageBegin("signAttachmentUsingServerKeyStorage", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: SignAttachmentUsingServerKeyStorageResult = new SignAttachmentUsingServerKeyStorageResult({ validError: err });
                output.writeMessageBegin("signAttachmentUsingServerKeyStorage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: SignAttachmentUsingServerKeyStorageResult = new SignAttachmentUsingServerKeyStorageResult({ error: err });
                output.writeMessageBegin("signAttachmentUsingServerKeyStorage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("signAttachmentUsingServerKeyStorage", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllDigitalSigns(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<DigitalSign.DigitalSign>>((resolve, reject): void => {
            try {
                const args: GetAllDigitalSignsArgs = GetAllDigitalSignsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllDigitalSigns(args.token, args.documentId, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<DigitalSign.DigitalSign>): void => {
            const result: GetAllDigitalSignsResult = new GetAllDigitalSignsResult({ success: data });
            output.writeMessageBegin("getAllDigitalSigns", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllDigitalSignsResult = new GetAllDigitalSignsResult({ validError: err });
                output.writeMessageBegin("getAllDigitalSigns", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllDigitalSignsResult = new GetAllDigitalSignsResult({ error: err });
                output.writeMessageBegin("getAllDigitalSigns", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllDigitalSigns", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getCertificateInfo(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<core.CertificateInfo>>((resolve, reject): void => {
            try {
                const args: GetCertificateInfoArgs = GetCertificateInfoArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getCertificateInfo(args.token, args.digitalSignId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<core.CertificateInfo>): void => {
            const result: GetCertificateInfoResult = new GetCertificateInfoResult({ success: data });
            output.writeMessageBegin("getCertificateInfo", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetCertificateInfoResult = new GetCertificateInfoResult({ validError: err });
                output.writeMessageBegin("getCertificateInfo", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetCertificateInfoResult = new GetCertificateInfoResult({ error: err });
                output.writeMessageBegin("getCertificateInfo", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getCertificateInfo", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getCertificateInfoListByUser(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<core.UserKeyData>>((resolve, reject): void => {
            try {
                const args: GetCertificateInfoListByUserArgs = GetCertificateInfoListByUserArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getCertificateInfoListByUser(args.token, args.userId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<core.UserKeyData>): void => {
            const result: GetCertificateInfoListByUserResult = new GetCertificateInfoListByUserResult({ success: data });
            output.writeMessageBegin("getCertificateInfoListByUser", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetCertificateInfoListByUserResult = new GetCertificateInfoListByUserResult({ validError: err });
                output.writeMessageBegin("getCertificateInfoListByUser", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetCertificateInfoListByUserResult = new GetCertificateInfoListByUserResult({ error: err });
                output.writeMessageBegin("getCertificateInfoListByUser", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getCertificateInfoListByUser", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getSignInfoByCertificate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<core.CertificateInfo>((resolve, reject): void => {
            try {
                const args: GetSignInfoByCertificateArgs = GetSignInfoByCertificateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getSignInfoByCertificate(args.token, args.data));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: core.CertificateInfo): void => {
            const result: GetSignInfoByCertificateResult = new GetSignInfoByCertificateResult({ success: data });
            output.writeMessageBegin("getSignInfoByCertificate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetSignInfoByCertificateResult = new GetSignInfoByCertificateResult({ validError: err });
                output.writeMessageBegin("getSignInfoByCertificate", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetSignInfoByCertificateResult = new GetSignInfoByCertificateResult({ error: err });
                output.writeMessageBegin("getSignInfoByCertificate", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getSignInfoByCertificate", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getSignInfo(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<SignInfo.SignInfo>((resolve, reject): void => {
            try {
                const args: GetSignInfoArgs = GetSignInfoArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getSignInfo(args.digitalSignId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: SignInfo.SignInfo): void => {
            const result: GetSignInfoResult = new GetSignInfoResult({ success: data });
            output.writeMessageBegin("getSignInfo", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetSignInfoResult = new GetSignInfoResult({ validError: err });
                output.writeMessageBegin("getSignInfo", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetSignInfoResult = new GetSignInfoResult({ error: err });
                output.writeMessageBegin("getSignInfo", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getSignInfo", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllPrivateKeys(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<PrivateKeyInfo.PrivateKeyInfo>>((resolve, reject): void => {
            try {
                const args: GetAllPrivateKeysArgs = GetAllPrivateKeysArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllPrivateKeys(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<PrivateKeyInfo.PrivateKeyInfo>): void => {
            const result: GetAllPrivateKeysResult = new GetAllPrivateKeysResult({ success: data });
            output.writeMessageBegin("getAllPrivateKeys", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllPrivateKeysResult = new GetAllPrivateKeysResult({ validError: err });
                output.writeMessageBegin("getAllPrivateKeys", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllPrivateKeysResult = new GetAllPrivateKeysResult({ error: err });
                output.writeMessageBegin("getAllPrivateKeys", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllPrivateKeys", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getCountPrivateKeys(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<number>((resolve, reject): void => {
            try {
                const args: GetCountPrivateKeysArgs = GetCountPrivateKeysArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getCountPrivateKeys(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): void => {
            const result: GetCountPrivateKeysResult = new GetCountPrivateKeysResult({ success: data });
            output.writeMessageBegin("getCountPrivateKeys", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetCountPrivateKeysResult = new GetCountPrivateKeysResult({ validError: err });
                output.writeMessageBegin("getCountPrivateKeys", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetCountPrivateKeysResult = new GetCountPrivateKeysResult({ error: err });
                output.writeMessageBegin("getCountPrivateKeys", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getCountPrivateKeys", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_addKeyToSecureStorage(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<PrivateKeyInfo.PrivateKeyInfo>((resolve, reject): void => {
            try {
                const args: AddKeyToSecureStorageArgs = AddKeyToSecureStorageArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.addKeyToSecureStorage(args.token, args.key1, args.password, args.name, args.fileExt, args.privateKeyIndexInJKS));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: PrivateKeyInfo.PrivateKeyInfo): void => {
            const result: AddKeyToSecureStorageResult = new AddKeyToSecureStorageResult({ success: data });
            output.writeMessageBegin("addKeyToSecureStorage", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: AddKeyToSecureStorageResult = new AddKeyToSecureStorageResult({ validError: err });
                output.writeMessageBegin("addKeyToSecureStorage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: AddKeyToSecureStorageResult = new AddKeyToSecureStorageResult({ error: err });
                output.writeMessageBegin("addKeyToSecureStorage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addKeyToSecureStorage", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeKeyFromSecureStorage(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemoveKeyFromSecureStorageArgs = RemoveKeyFromSecureStorageArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeKeyFromSecureStorage(args.token, args.id));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemoveKeyFromSecureStorageResult = new RemoveKeyFromSecureStorageResult({ success: data });
            output.writeMessageBegin("removeKeyFromSecureStorage", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: RemoveKeyFromSecureStorageResult = new RemoveKeyFromSecureStorageResult({ validError: err });
                output.writeMessageBegin("removeKeyFromSecureStorage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: RemoveKeyFromSecureStorageResult = new RemoveKeyFromSecureStorageResult({ error: err });
                output.writeMessageBegin("removeKeyFromSecureStorage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeKeyFromSecureStorage", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getDigitalSignByAttachmentId(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Map<string, boolean>>((resolve, reject): void => {
            try {
                const args: GetDigitalSignByAttachmentIdArgs = GetDigitalSignByAttachmentIdArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getDigitalSignByAttachmentId(args.token, args.attachmentId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Map<string, boolean>): void => {
            const result: GetDigitalSignByAttachmentIdResult = new GetDigitalSignByAttachmentIdResult({ success: data });
            output.writeMessageBegin("getDigitalSignByAttachmentId", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("getDigitalSignByAttachmentId", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_addExternalSignToAttachment(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: AddExternalSignToAttachmentArgs = AddExternalSignToAttachmentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.addExternalSignToAttachment(args.token, args.attachmentId, args.p7s));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: AddExternalSignToAttachmentResult = new AddExternalSignToAttachmentResult({ success: data });
            output.writeMessageBegin("addExternalSignToAttachment", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: AddExternalSignToAttachmentResult = new AddExternalSignToAttachmentResult({ validError: err });
                output.writeMessageBegin("addExternalSignToAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: AddExternalSignToAttachmentResult = new AddExternalSignToAttachmentResult({ error: err });
                output.writeMessageBegin("addExternalSignToAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addExternalSignToAttachment", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_singAnyData(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<core.SignData>>((resolve, reject): void => {
            try {
                const args: SingAnyDataArgs = SingAnyDataArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.singAnyData(args.token, args.keyInfoList, args.dataToSignList));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<core.SignData>): void => {
            const result: SingAnyDataResult = new SingAnyDataResult({ success: data });
            output.writeMessageBegin("singAnyData", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: SingAnyDataResult = new SingAnyDataResult({ validError: err });
                output.writeMessageBegin("singAnyData", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: SingAnyDataResult = new SingAnyDataResult({ error: err });
                output.writeMessageBegin("singAnyData", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("singAnyData", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_signInExternalService(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<ExtSignOperation.ExtSignOperation>((resolve, reject): void => {
            try {
                const args: SignInExternalServiceArgs = SignInExternalServiceArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.signInExternalService(args.token, args.serviceKey, args.dataToSignList));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ExtSignOperation.ExtSignOperation): void => {
            const result: SignInExternalServiceResult = new SignInExternalServiceResult({ success: data });
            output.writeMessageBegin("signInExternalService", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: SignInExternalServiceResult = new SignInExternalServiceResult({ validError: err });
                output.writeMessageBegin("signInExternalService", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: SignInExternalServiceResult = new SignInExternalServiceResult({ error: err });
                output.writeMessageBegin("signInExternalService", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("signInExternalService", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_checkSignStatusInExternalService(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<ExtSignOperation.ExtSignOperation>((resolve, reject): void => {
            try {
                const args: CheckSignStatusInExternalServiceArgs = CheckSignStatusInExternalServiceArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.checkSignStatusInExternalService(args.token, args.serviceKey, args.signOperation));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ExtSignOperation.ExtSignOperation): void => {
            const result: CheckSignStatusInExternalServiceResult = new CheckSignStatusInExternalServiceResult({ success: data });
            output.writeMessageBegin("checkSignStatusInExternalService", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CheckSignStatusInExternalServiceResult = new CheckSignStatusInExternalServiceResult({ validError: err });
                output.writeMessageBegin("checkSignStatusInExternalService", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CheckSignStatusInExternalServiceResult = new CheckSignStatusInExternalServiceResult({ error: err });
                output.writeMessageBegin("checkSignStatusInExternalService", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("checkSignStatusInExternalService", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_extractPublicKeyInfo(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<core.CertificateInfo>((resolve, reject): void => {
            try {
                const args: ExtractPublicKeyInfoArgs = ExtractPublicKeyInfoArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.extractPublicKeyInfo(args.token, args.keyInfo));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: core.CertificateInfo): void => {
            const result: ExtractPublicKeyInfoResult = new ExtractPublicKeyInfoResult({ success: data });
            output.writeMessageBegin("extractPublicKeyInfo", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: ExtractPublicKeyInfoResult = new ExtractPublicKeyInfoResult({ validError: err });
                output.writeMessageBegin("extractPublicKeyInfo", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: ExtractPublicKeyInfoResult = new ExtractPublicKeyInfoResult({ error: err });
                output.writeMessageBegin("extractPublicKeyInfo", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("extractPublicKeyInfo", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllExternalSignServiceInfos(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<ExtSignServer.ExtSignServer>>((resolve, reject): void => {
            try {
                const args: GetAllExternalSignServiceInfosArgs = GetAllExternalSignServiceInfosArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllExternalSignServiceInfos(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<ExtSignServer.ExtSignServer>): void => {
            const result: GetAllExternalSignServiceInfosResult = new GetAllExternalSignServiceInfosResult({ success: data });
            output.writeMessageBegin("getAllExternalSignServiceInfos", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetAllExternalSignServiceInfosResult = new GetAllExternalSignServiceInfosResult({ validError: err });
                output.writeMessageBegin("getAllExternalSignServiceInfos", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetAllExternalSignServiceInfosResult = new GetAllExternalSignServiceInfosResult({ error: err });
                output.writeMessageBegin("getAllExternalSignServiceInfos", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllExternalSignServiceInfos", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getCurrentBulkSignJob(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<BulkSignJob.BulkSignJob>((resolve, reject): void => {
            try {
                const args: GetCurrentBulkSignJobArgs = GetCurrentBulkSignJobArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getCurrentBulkSignJob(args.token));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: BulkSignJob.BulkSignJob): void => {
            const result: GetCurrentBulkSignJobResult = new GetCurrentBulkSignJobResult({ success: data });
            output.writeMessageBegin("getCurrentBulkSignJob", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetCurrentBulkSignJobResult = new GetCurrentBulkSignJobResult({ validError: err });
                output.writeMessageBegin("getCurrentBulkSignJob", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetCurrentBulkSignJobResult = new GetCurrentBulkSignJobResult({ error: err });
                output.writeMessageBegin("getCurrentBulkSignJob", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getCurrentBulkSignJob", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getFullBulkSignJob(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<BulkSignJob.BulkSignJob>((resolve, reject): void => {
            try {
                const args: GetFullBulkSignJobArgs = GetFullBulkSignJobArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getFullBulkSignJob(args.token, args.bulkId, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: BulkSignJob.BulkSignJob): void => {
            const result: GetFullBulkSignJobResult = new GetFullBulkSignJobResult({ success: data });
            output.writeMessageBegin("getFullBulkSignJob", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: GetFullBulkSignJobResult = new GetFullBulkSignJobResult({ validError: err });
                output.writeMessageBegin("getFullBulkSignJob", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: GetFullBulkSignJobResult = new GetFullBulkSignJobResult({ error: err });
                output.writeMessageBegin("getFullBulkSignJob", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getFullBulkSignJob", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeFromCurrentBulkSignJob(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<BulkSignInfo.BulkSignInfo>((resolve, reject): void => {
            try {
                const args: RemoveFromCurrentBulkSignJobArgs = RemoveFromCurrentBulkSignJobArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeFromCurrentBulkSignJob(args.token, args.bulkId, args.signDocId, args.signAttId, args.attId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: BulkSignInfo.BulkSignInfo): void => {
            const result: RemoveFromCurrentBulkSignJobResult = new RemoveFromCurrentBulkSignJobResult({ success: data });
            output.writeMessageBegin("removeFromCurrentBulkSignJob", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: RemoveFromCurrentBulkSignJobResult = new RemoveFromCurrentBulkSignJobResult({ validError: err });
                output.writeMessageBegin("removeFromCurrentBulkSignJob", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: RemoveFromCurrentBulkSignJobResult = new RemoveFromCurrentBulkSignJobResult({ error: err });
                output.writeMessageBegin("removeFromCurrentBulkSignJob", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeFromCurrentBulkSignJob", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_addToCurrentBulkSignJob(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<BulkSignInfo.BulkSignInfo>((resolve, reject): void => {
            try {
                const args: AddToCurrentBulkSignJobArgs = AddToCurrentBulkSignJobArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.addToCurrentBulkSignJob(args.token, args.bulkId, args.accessPolicy, args.attId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: BulkSignInfo.BulkSignInfo): void => {
            const result: AddToCurrentBulkSignJobResult = new AddToCurrentBulkSignJobResult({ success: data });
            output.writeMessageBegin("addToCurrentBulkSignJob", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: AddToCurrentBulkSignJobResult = new AddToCurrentBulkSignJobResult({ validError: err });
                output.writeMessageBegin("addToCurrentBulkSignJob", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: AddToCurrentBulkSignJobResult = new AddToCurrentBulkSignJobResult({ error: err });
                output.writeMessageBegin("addToCurrentBulkSignJob", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addToCurrentBulkSignJob", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_signBulkJob(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<BulkSignJob.BulkSignJob>((resolve, reject): void => {
            try {
                const args: SignBulkJobArgs = SignBulkJobArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.signBulkJob(args.token, args.keyInfoList, args.bulkId, args.setAutoDecision));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: BulkSignJob.BulkSignJob): void => {
            const result: SignBulkJobResult = new SignBulkJobResult({ success: data });
            output.writeMessageBegin("signBulkJob", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: SignBulkJobResult = new SignBulkJobResult({ validError: err });
                output.writeMessageBegin("signBulkJob", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: SignBulkJobResult = new SignBulkJobResult({ error: err });
                output.writeMessageBegin("signBulkJob", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("signBulkJob", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_cancelBulkJob(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<BulkSignJob.BulkSignJob>((resolve, reject): void => {
            try {
                const args: CancelBulkJobArgs = CancelBulkJobArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.cancelBulkJob(args.token, args.bulkId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: BulkSignJob.BulkSignJob): void => {
            const result: CancelBulkJobResult = new CancelBulkJobResult({ success: data });
            output.writeMessageBegin("cancelBulkJob", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CancelBulkJobResult = new CancelBulkJobResult({ validError: err });
                output.writeMessageBegin("cancelBulkJob", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CancelBulkJobResult = new CancelBulkJobResult({ error: err });
                output.writeMessageBegin("cancelBulkJob", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("cancelBulkJob", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_closeBulkJob(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<BulkSignJob.BulkSignJob>((resolve, reject): void => {
            try {
                const args: CloseBulkJobArgs = CloseBulkJobArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.closeBulkJob(args.token, args.bulkId, args.copyFailedDocs));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: BulkSignJob.BulkSignJob): void => {
            const result: CloseBulkJobResult = new CloseBulkJobResult({ success: data });
            output.writeMessageBegin("closeBulkJob", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof core.PreconditionException) {
                const result: CloseBulkJobResult = new CloseBulkJobResult({ validError: err });
                output.writeMessageBegin("closeBulkJob", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof core.ServerException) {
                const result: CloseBulkJobResult = new CloseBulkJobResult({ error: err });
                output.writeMessageBegin("closeBulkJob", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("closeBulkJob", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
}
