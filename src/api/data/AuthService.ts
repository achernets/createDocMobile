/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import * as thrift from "thrift";
import * as Device from "./Device";
import * as __ROOT_NAMESPACE__ from "./";
import * as AuthSession from "./AuthSession";
import * as AuthCreds from "./AuthCreds";
import * as OtpSendChannelType from "./OtpSendChannelType";
import * as ServerSettings from "./ServerSettings";
import * as ExtInfo from "./ExtInfo";
export interface IAuthenticateArgsArgs {
    login: string;
    password: string;
    device: Device.Device;
    ip: string;
    findOpened: boolean;
    langCode: string;
    cacheVersion: number;
}
export class AuthenticateArgs {
    public login: string;
    public password: string;
    public device: Device.Device;
    public ip: string;
    public findOpened: boolean;
    public langCode: string;
    public cacheVersion: number;
    constructor(args: IAuthenticateArgsArgs) {
        if (args != null && args.login != null) {
            this.login = args.login;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[login] is unset!");
        }
        if (args != null && args.password != null) {
            this.password = args.password;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[password] is unset!");
        }
        if (args != null && args.device != null) {
            this.device = args.device;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[device] is unset!");
        }
        if (args != null && args.ip != null) {
            this.ip = args.ip;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[ip] is unset!");
        }
        if (args != null && args.findOpened != null) {
            this.findOpened = args.findOpened;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[findOpened] is unset!");
        }
        if (args != null && args.langCode != null) {
            this.langCode = args.langCode;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[langCode] is unset!");
        }
        if (args != null && args.cacheVersion != null) {
            this.cacheVersion = args.cacheVersion;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cacheVersion] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AuthenticateArgs");
        if (this.login != null) {
            output.writeFieldBegin("login", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.login);
            output.writeFieldEnd();
        }
        if (this.password != null) {
            output.writeFieldBegin("password", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.password);
            output.writeFieldEnd();
        }
        if (this.device != null) {
            output.writeFieldBegin("device", thrift.Thrift.Type.STRUCT, 3);
            this.device.write(output);
            output.writeFieldEnd();
        }
        if (this.ip != null) {
            output.writeFieldBegin("ip", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.ip);
            output.writeFieldEnd();
        }
        if (this.findOpened != null) {
            output.writeFieldBegin("findOpened", thrift.Thrift.Type.BOOL, 5);
            output.writeBool(this.findOpened);
            output.writeFieldEnd();
        }
        if (this.langCode != null) {
            output.writeFieldBegin("langCode", thrift.Thrift.Type.STRING, 6);
            output.writeString(this.langCode);
            output.writeFieldEnd();
        }
        if (this.cacheVersion != null) {
            output.writeFieldBegin("cacheVersion", thrift.Thrift.Type.I32, 7);
            output.writeI32(this.cacheVersion);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AuthenticateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_1: string = input.readString();
                        _args.login = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_2: string = input.readString();
                        _args.password = value_2;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_3: Device.Device = Device.Device.read(input);
                        _args.device = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_4: string = input.readString();
                        _args.ip = value_4;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_5: boolean = input.readBool();
                        _args.findOpened = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_6: string = input.readString();
                        _args.langCode = value_6;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 7:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_7: number = input.readI32();
                        _args.cacheVersion = value_7;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.login !== undefined && _args.password !== undefined && _args.device !== undefined && _args.ip !== undefined && _args.findOpened !== undefined && _args.langCode !== undefined && _args.cacheVersion !== undefined) {
            return new AuthenticateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AuthenticateArgs from input");
        }
    }
}
export interface IAuthenticateGuestArgsArgs {
    guestId: string;
    password: string;
    ip: string;
    langCode: string;
}
export class AuthenticateGuestArgs {
    public guestId: string;
    public password: string;
    public ip: string;
    public langCode: string;
    constructor(args: IAuthenticateGuestArgsArgs) {
        if (args != null && args.guestId != null) {
            this.guestId = args.guestId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[guestId] is unset!");
        }
        if (args != null && args.password != null) {
            this.password = args.password;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[password] is unset!");
        }
        if (args != null && args.ip != null) {
            this.ip = args.ip;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[ip] is unset!");
        }
        if (args != null && args.langCode != null) {
            this.langCode = args.langCode;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[langCode] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AuthenticateGuestArgs");
        if (this.guestId != null) {
            output.writeFieldBegin("guestId", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.guestId);
            output.writeFieldEnd();
        }
        if (this.password != null) {
            output.writeFieldBegin("password", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.password);
            output.writeFieldEnd();
        }
        if (this.ip != null) {
            output.writeFieldBegin("ip", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.ip);
            output.writeFieldEnd();
        }
        if (this.langCode != null) {
            output.writeFieldBegin("langCode", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.langCode);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AuthenticateGuestArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_8: string = input.readString();
                        _args.guestId = value_8;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_9: string = input.readString();
                        _args.password = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_10: string = input.readString();
                        _args.ip = value_10;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_11: string = input.readString();
                        _args.langCode = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.guestId !== undefined && _args.password !== undefined && _args.ip !== undefined && _args.langCode !== undefined) {
            return new AuthenticateGuestArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AuthenticateGuestArgs from input");
        }
    }
}
export interface IAuthenticateExtendedArgsArgs {
    authCreds: AuthCreds.AuthCreds;
    device: Device.Device;
    ip: string;
    findOpened: boolean;
    langCode: string;
    cacheVersion: number;
}
export class AuthenticateExtendedArgs {
    public authCreds: AuthCreds.AuthCreds;
    public device: Device.Device;
    public ip: string;
    public findOpened: boolean;
    public langCode: string;
    public cacheVersion: number;
    constructor(args: IAuthenticateExtendedArgsArgs) {
        if (args != null && args.authCreds != null) {
            this.authCreds = args.authCreds;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[authCreds] is unset!");
        }
        if (args != null && args.device != null) {
            this.device = args.device;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[device] is unset!");
        }
        if (args != null && args.ip != null) {
            this.ip = args.ip;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[ip] is unset!");
        }
        if (args != null && args.findOpened != null) {
            this.findOpened = args.findOpened;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[findOpened] is unset!");
        }
        if (args != null && args.langCode != null) {
            this.langCode = args.langCode;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[langCode] is unset!");
        }
        if (args != null && args.cacheVersion != null) {
            this.cacheVersion = args.cacheVersion;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cacheVersion] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AuthenticateExtendedArgs");
        if (this.authCreds != null) {
            output.writeFieldBegin("authCreds", thrift.Thrift.Type.STRUCT, 1);
            this.authCreds.write(output);
            output.writeFieldEnd();
        }
        if (this.device != null) {
            output.writeFieldBegin("device", thrift.Thrift.Type.STRUCT, 2);
            this.device.write(output);
            output.writeFieldEnd();
        }
        if (this.ip != null) {
            output.writeFieldBegin("ip", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.ip);
            output.writeFieldEnd();
        }
        if (this.findOpened != null) {
            output.writeFieldBegin("findOpened", thrift.Thrift.Type.BOOL, 4);
            output.writeBool(this.findOpened);
            output.writeFieldEnd();
        }
        if (this.langCode != null) {
            output.writeFieldBegin("langCode", thrift.Thrift.Type.STRING, 5);
            output.writeString(this.langCode);
            output.writeFieldEnd();
        }
        if (this.cacheVersion != null) {
            output.writeFieldBegin("cacheVersion", thrift.Thrift.Type.I32, 6);
            output.writeI32(this.cacheVersion);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AuthenticateExtendedArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_12: AuthCreds.AuthCreds = AuthCreds.AuthCreds.read(input);
                        _args.authCreds = value_12;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_13: Device.Device = Device.Device.read(input);
                        _args.device = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_14: string = input.readString();
                        _args.ip = value_14;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_15: boolean = input.readBool();
                        _args.findOpened = value_15;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_16: string = input.readString();
                        _args.langCode = value_16;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_17: number = input.readI32();
                        _args.cacheVersion = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.authCreds !== undefined && _args.device !== undefined && _args.ip !== undefined && _args.findOpened !== undefined && _args.langCode !== undefined && _args.cacheVersion !== undefined) {
            return new AuthenticateExtendedArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AuthenticateExtendedArgs from input");
        }
    }
}
export interface ICheckOTPArgsArgs {
    token: string;
    otp: string;
}
export class CheckOTPArgs {
    public token: string;
    public otp: string;
    constructor(args: ICheckOTPArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.otp != null) {
            this.otp = args.otp;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[otp] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CheckOTPArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.otp != null) {
            output.writeFieldBegin("otp", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.otp);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CheckOTPArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_18: string = input.readString();
                        _args.token = value_18;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_19: string = input.readString();
                        _args.otp = value_19;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.otp !== undefined) {
            return new CheckOTPArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CheckOTPArgs from input");
        }
    }
}
export interface IResendOTPArgsArgs {
    token: string;
    sendChannelType: OtpSendChannelType.OtpSendChannelType;
}
export class ResendOTPArgs {
    public token: string;
    public sendChannelType: OtpSendChannelType.OtpSendChannelType;
    constructor(args: IResendOTPArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.sendChannelType != null) {
            this.sendChannelType = args.sendChannelType;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[sendChannelType] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ResendOTPArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.sendChannelType != null) {
            output.writeFieldBegin("sendChannelType", thrift.Thrift.Type.I32, 2);
            output.writeI32(this.sendChannelType);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ResendOTPArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_20: string = input.readString();
                        _args.token = value_20;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_21: OtpSendChannelType.OtpSendChannelType = input.readI32();
                        _args.sendChannelType = value_21;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.sendChannelType !== undefined) {
            return new ResendOTPArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ResendOTPArgs from input");
        }
    }
}
export interface IRefreshAuthSessionArgsArgs {
    token: string;
}
export class RefreshAuthSessionArgs {
    public token: string;
    constructor(args: IRefreshAuthSessionArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RefreshAuthSessionArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RefreshAuthSessionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_22: string = input.readString();
                        _args.token = value_22;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined) {
            return new RefreshAuthSessionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RefreshAuthSessionArgs from input");
        }
    }
}
export interface IIsAuthSessionExpiredArgsArgs {
    token: string;
}
export class IsAuthSessionExpiredArgs {
    public token: string;
    constructor(args: IIsAuthSessionExpiredArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("IsAuthSessionExpiredArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): IsAuthSessionExpiredArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_23: string = input.readString();
                        _args.token = value_23;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined) {
            return new IsAuthSessionExpiredArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read IsAuthSessionExpiredArgs from input");
        }
    }
}
export interface IChangePasswordArgsArgs {
    token: string;
    oldPassword: string;
    password: string;
    confirmation: string;
}
export class ChangePasswordArgs {
    public token: string;
    public oldPassword: string;
    public password: string;
    public confirmation: string;
    constructor(args: IChangePasswordArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.oldPassword != null) {
            this.oldPassword = args.oldPassword;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[oldPassword] is unset!");
        }
        if (args != null && args.password != null) {
            this.password = args.password;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[password] is unset!");
        }
        if (args != null && args.confirmation != null) {
            this.confirmation = args.confirmation;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[confirmation] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangePasswordArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.oldPassword != null) {
            output.writeFieldBegin("oldPassword", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.oldPassword);
            output.writeFieldEnd();
        }
        if (this.password != null) {
            output.writeFieldBegin("password", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.password);
            output.writeFieldEnd();
        }
        if (this.confirmation != null) {
            output.writeFieldBegin("confirmation", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.confirmation);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangePasswordArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_24: string = input.readString();
                        _args.token = value_24;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_25: string = input.readString();
                        _args.oldPassword = value_25;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_26: string = input.readString();
                        _args.password = value_26;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_27: string = input.readString();
                        _args.confirmation = value_27;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.oldPassword !== undefined && _args.password !== undefined && _args.confirmation !== undefined) {
            return new ChangePasswordArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangePasswordArgs from input");
        }
    }
}
export interface IRequestResetPasswordArgsArgs {
    token: string;
    login: string;
}
export class RequestResetPasswordArgs {
    public token: string;
    public login: string;
    constructor(args: IRequestResetPasswordArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.login != null) {
            this.login = args.login;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[login] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RequestResetPasswordArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.login != null) {
            output.writeFieldBegin("login", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.login);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RequestResetPasswordArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_28: string = input.readString();
                        _args.token = value_28;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_29: string = input.readString();
                        _args.login = value_29;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.login !== undefined) {
            return new RequestResetPasswordArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RequestResetPasswordArgs from input");
        }
    }
}
export interface IFinishResetPasswordArgsArgs {
    login: string;
    confirmationCode: string;
    password: string;
    confirmation: string;
    langCode: string;
}
export class FinishResetPasswordArgs {
    public login: string;
    public confirmationCode: string;
    public password: string;
    public confirmation: string;
    public langCode: string;
    constructor(args: IFinishResetPasswordArgsArgs) {
        if (args != null && args.login != null) {
            this.login = args.login;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[login] is unset!");
        }
        if (args != null && args.confirmationCode != null) {
            this.confirmationCode = args.confirmationCode;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[confirmationCode] is unset!");
        }
        if (args != null && args.password != null) {
            this.password = args.password;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[password] is unset!");
        }
        if (args != null && args.confirmation != null) {
            this.confirmation = args.confirmation;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[confirmation] is unset!");
        }
        if (args != null && args.langCode != null) {
            this.langCode = args.langCode;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[langCode] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FinishResetPasswordArgs");
        if (this.login != null) {
            output.writeFieldBegin("login", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.login);
            output.writeFieldEnd();
        }
        if (this.confirmationCode != null) {
            output.writeFieldBegin("confirmationCode", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.confirmationCode);
            output.writeFieldEnd();
        }
        if (this.password != null) {
            output.writeFieldBegin("password", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.password);
            output.writeFieldEnd();
        }
        if (this.confirmation != null) {
            output.writeFieldBegin("confirmation", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.confirmation);
            output.writeFieldEnd();
        }
        if (this.langCode != null) {
            output.writeFieldBegin("langCode", thrift.Thrift.Type.STRING, 5);
            output.writeString(this.langCode);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FinishResetPasswordArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_30: string = input.readString();
                        _args.login = value_30;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_31: string = input.readString();
                        _args.confirmationCode = value_31;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_32: string = input.readString();
                        _args.password = value_32;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_33: string = input.readString();
                        _args.confirmation = value_33;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_34: string = input.readString();
                        _args.langCode = value_34;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.login !== undefined && _args.confirmationCode !== undefined && _args.password !== undefined && _args.confirmation !== undefined && _args.langCode !== undefined) {
            return new FinishResetPasswordArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read FinishResetPasswordArgs from input");
        }
    }
}
export interface ILogoutArgsArgs {
    token: string;
}
export class LogoutArgs {
    public token: string;
    constructor(args: ILogoutArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("LogoutArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): LogoutArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_35: string = input.readString();
                        _args.token = value_35;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined) {
            return new LogoutArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read LogoutArgs from input");
        }
    }
}
export interface IAuthenticateAsArgsArgs {
    token: string;
    toUserId: string;
}
export class AuthenticateAsArgs {
    public token: string;
    public toUserId: string;
    constructor(args: IAuthenticateAsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.toUserId != null) {
            this.toUserId = args.toUserId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toUserId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AuthenticateAsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.toUserId != null) {
            output.writeFieldBegin("toUserId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.toUserId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AuthenticateAsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_36: string = input.readString();
                        _args.token = value_36;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_37: string = input.readString();
                        _args.toUserId = value_37;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.toUserId !== undefined) {
            return new AuthenticateAsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AuthenticateAsArgs from input");
        }
    }
}
export interface IGetInfoArgsArgs {
}
export class GetInfoArgs {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetInfoArgs");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetInfoArgs {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetInfoArgs();
    }
}
export interface IGetSettingsArgsArgs {
}
export class GetSettingsArgs {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetSettingsArgs");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetSettingsArgs {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetSettingsArgs();
    }
}
export interface IExtendSessionArgsArgs {
    token: string;
    keyword: string;
}
export class ExtendSessionArgs {
    public token: string;
    public keyword: string;
    constructor(args: IExtendSessionArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.keyword != null) {
            this.keyword = args.keyword;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[keyword] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExtendSessionArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.keyword != null) {
            output.writeFieldBegin("keyword", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.keyword);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExtendSessionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_38: string = input.readString();
                        _args.token = value_38;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_39: string = input.readString();
                        _args.keyword = value_39;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.keyword !== undefined) {
            return new ExtendSessionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExtendSessionArgs from input");
        }
    }
}
export interface IGetAllLanguagesArgsArgs {
}
export class GetAllLanguagesArgs {
    constructor() {
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllLanguagesArgs");
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllLanguagesArgs {
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllLanguagesArgs();
    }
}
export interface IGenerateNewTokenForLangArgsArgs {
    token: string;
    newLang: string;
}
export class GenerateNewTokenForLangArgs {
    public token: string;
    public newLang: string;
    constructor(args: IGenerateNewTokenForLangArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.newLang != null) {
            this.newLang = args.newLang;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[newLang] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GenerateNewTokenForLangArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.newLang != null) {
            output.writeFieldBegin("newLang", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.newLang);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GenerateNewTokenForLangArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_40: string = input.readString();
                        _args.token = value_40;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_41: string = input.readString();
                        _args.newLang = value_41;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.newLang !== undefined) {
            return new GenerateNewTokenForLangArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GenerateNewTokenForLangArgs from input");
        }
    }
}
export interface IGetAllCustomTranslateArgsArgs {
    langCode: string;
}
export class GetAllCustomTranslateArgs {
    public langCode: string;
    constructor(args: IGetAllCustomTranslateArgsArgs) {
        if (args != null && args.langCode != null) {
            this.langCode = args.langCode;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[langCode] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllCustomTranslateArgs");
        if (this.langCode != null) {
            output.writeFieldBegin("langCode", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.langCode);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllCustomTranslateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_42: string = input.readString();
                        _args.langCode = value_42;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.langCode !== undefined) {
            return new GetAllCustomTranslateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllCustomTranslateArgs from input");
        }
    }
}
export interface IGetExtendedInfoArgsArgs {
    token: string;
}
export class GetExtendedInfoArgs {
    public token: string;
    constructor(args: IGetExtendedInfoArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetExtendedInfoArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetExtendedInfoArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_43: string = input.readString();
                        _args.token = value_43;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined) {
            return new GetExtendedInfoArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetExtendedInfoArgs from input");
        }
    }
}
export interface IIsModuleAllowedArgsArgs {
    param: string;
}
export class IsModuleAllowedArgs {
    public param: string;
    constructor(args: IIsModuleAllowedArgsArgs) {
        if (args != null && args.param != null) {
            this.param = args.param;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[param] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("IsModuleAllowedArgs");
        if (this.param != null) {
            output.writeFieldBegin("param", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.param);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): IsModuleAllowedArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_44: string = input.readString();
                        _args.param = value_44;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.param !== undefined) {
            return new IsModuleAllowedArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read IsModuleAllowedArgs from input");
        }
    }
}
export interface IGetOTPForSocketRegistrationArgsArgs {
    token: string;
}
export class GetOTPForSocketRegistrationArgs {
    public token: string;
    constructor(args: IGetOTPForSocketRegistrationArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetOTPForSocketRegistrationArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetOTPForSocketRegistrationArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_45: string = input.readString();
                        _args.token = value_45;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined) {
            return new GetOTPForSocketRegistrationArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetOTPForSocketRegistrationArgs from input");
        }
    }
}
export interface IGetOtpSendChannelsArgsArgs {
    token: string;
}
export class GetOtpSendChannelsArgs {
    public token: string;
    constructor(args: IGetOtpSendChannelsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetOtpSendChannelsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetOtpSendChannelsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_46: string = input.readString();
                        _args.token = value_46;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined) {
            return new GetOtpSendChannelsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetOtpSendChannelsArgs from input");
        }
    }
}
export interface IAuthenticateResultArgs {
    success?: AuthSession.AuthSession;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class AuthenticateResult {
    public success?: AuthSession.AuthSession;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IAuthenticateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AuthenticateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AuthenticateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_47: AuthSession.AuthSession = AuthSession.AuthSession.read(input);
                        _args.success = value_47;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_48: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_48;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_49: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_49;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AuthenticateResult(_args);
    }
}
export interface IAuthenticateGuestResultArgs {
    success?: AuthSession.AuthSession;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class AuthenticateGuestResult {
    public success?: AuthSession.AuthSession;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IAuthenticateGuestResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AuthenticateGuestResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AuthenticateGuestResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_50: AuthSession.AuthSession = AuthSession.AuthSession.read(input);
                        _args.success = value_50;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_51: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_51;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_52: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_52;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AuthenticateGuestResult(_args);
    }
}
export interface IAuthenticateExtendedResultArgs {
    success?: AuthSession.AuthSession;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class AuthenticateExtendedResult {
    public success?: AuthSession.AuthSession;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IAuthenticateExtendedResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AuthenticateExtendedResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AuthenticateExtendedResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_53: AuthSession.AuthSession = AuthSession.AuthSession.read(input);
                        _args.success = value_53;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_54: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_54;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_55: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_55;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AuthenticateExtendedResult(_args);
    }
}
export interface ICheckOTPResultArgs {
    success?: AuthSession.AuthSession;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class CheckOTPResult {
    public success?: AuthSession.AuthSession;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: ICheckOTPResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CheckOTPResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CheckOTPResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_56: AuthSession.AuthSession = AuthSession.AuthSession.read(input);
                        _args.success = value_56;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_57: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_57;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_58: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_58;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CheckOTPResult(_args);
    }
}
export interface IResendOTPResultArgs {
    success?: AuthSession.AuthSession;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class ResendOTPResult {
    public success?: AuthSession.AuthSession;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IResendOTPResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ResendOTPResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ResendOTPResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_59: AuthSession.AuthSession = AuthSession.AuthSession.read(input);
                        _args.success = value_59;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_60: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_60;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_61: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_61;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ResendOTPResult(_args);
    }
}
export interface IRefreshAuthSessionResultArgs {
    success?: AuthSession.AuthSession;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class RefreshAuthSessionResult {
    public success?: AuthSession.AuthSession;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IRefreshAuthSessionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RefreshAuthSessionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RefreshAuthSessionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_62: AuthSession.AuthSession = AuthSession.AuthSession.read(input);
                        _args.success = value_62;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_63: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_63;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_64: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_64;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RefreshAuthSessionResult(_args);
    }
}
export interface IIsAuthSessionExpiredResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class IsAuthSessionExpiredResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IIsAuthSessionExpiredResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("IsAuthSessionExpiredResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): IsAuthSessionExpiredResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_65: boolean = input.readBool();
                        _args.success = value_65;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_66: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_66;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_67: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_67;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new IsAuthSessionExpiredResult(_args);
    }
}
export interface IChangePasswordResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class ChangePasswordResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IChangePasswordResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangePasswordResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangePasswordResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_68: boolean = input.readBool();
                        _args.success = value_68;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_69: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_69;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_70: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_70;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangePasswordResult(_args);
    }
}
export interface IRequestResetPasswordResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class RequestResetPasswordResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IRequestResetPasswordResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RequestResetPasswordResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RequestResetPasswordResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_71: boolean = input.readBool();
                        _args.success = value_71;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_72: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_72;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_73: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_73;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RequestResetPasswordResult(_args);
    }
}
export interface IFinishResetPasswordResultArgs {
    success?: AuthSession.AuthSession;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class FinishResetPasswordResult {
    public success?: AuthSession.AuthSession;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IFinishResetPasswordResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FinishResetPasswordResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FinishResetPasswordResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_74: AuthSession.AuthSession = AuthSession.AuthSession.read(input);
                        _args.success = value_74;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_75: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_75;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_76: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_76;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FinishResetPasswordResult(_args);
    }
}
export interface ILogoutResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class LogoutResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: ILogoutResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("LogoutResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): LogoutResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_77: boolean = input.readBool();
                        _args.success = value_77;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_78: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_78;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_79: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_79;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new LogoutResult(_args);
    }
}
export interface IAuthenticateAsResultArgs {
    success?: AuthSession.AuthSession;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class AuthenticateAsResult {
    public success?: AuthSession.AuthSession;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IAuthenticateAsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AuthenticateAsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AuthenticateAsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_80: AuthSession.AuthSession = AuthSession.AuthSession.read(input);
                        _args.success = value_80;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_81: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_81;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_82: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_82;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AuthenticateAsResult(_args);
    }
}
export interface IGetInfoResultArgs {
    success?: Map<string, string>;
}
export class GetInfoResult {
    public success?: Map<string, string>;
    constructor(args?: IGetInfoResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetInfoResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.MAP, 0);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.STRING, this.success.size);
            this.success.forEach((value_83: string, key_1: string): void => {
                output.writeString(key_1);
                output.writeString(value_83);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetInfoResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_84: Map<string, string> = new Map<string, string>();
                        const metadata_1: thrift.TMap = input.readMapBegin();
                        const size_1: number = metadata_1.size;
                        for (let i_1: number = 0; i_1 < size_1; i_1++) {
                            const key_2: string = input.readString();
                            const value_85: string = input.readString();
                            value_84.set(key_2, value_85);
                        }
                        input.readMapEnd();
                        _args.success = value_84;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetInfoResult(_args);
    }
}
export interface IGetSettingsResultArgs {
    success?: ServerSettings.ServerSettings;
}
export class GetSettingsResult {
    public success?: ServerSettings.ServerSettings;
    constructor(args?: IGetSettingsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetSettingsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetSettingsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_86: ServerSettings.ServerSettings = ServerSettings.ServerSettings.read(input);
                        _args.success = value_86;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetSettingsResult(_args);
    }
}
export interface IExtendSessionResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class ExtendSessionResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IExtendSessionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExtendSessionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExtendSessionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_87: boolean = input.readBool();
                        _args.success = value_87;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_88: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_88;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_89: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_89;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExtendSessionResult(_args);
    }
}
export interface IGetAllLanguagesResultArgs {
    success?: Map<string, string>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllLanguagesResult {
    public success?: Map<string, string>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllLanguagesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllLanguagesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.MAP, 0);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.STRING, this.success.size);
            this.success.forEach((value_90: string, key_3: string): void => {
                output.writeString(key_3);
                output.writeString(value_90);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllLanguagesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_91: Map<string, string> = new Map<string, string>();
                        const metadata_2: thrift.TMap = input.readMapBegin();
                        const size_2: number = metadata_2.size;
                        for (let i_2: number = 0; i_2 < size_2; i_2++) {
                            const key_4: string = input.readString();
                            const value_92: string = input.readString();
                            value_91.set(key_4, value_92);
                        }
                        input.readMapEnd();
                        _args.success = value_91;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_93: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_93;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_94: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_94;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllLanguagesResult(_args);
    }
}
export interface IGenerateNewTokenForLangResultArgs {
    success?: string;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GenerateNewTokenForLangResult {
    public success?: string;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGenerateNewTokenForLangResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GenerateNewTokenForLangResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GenerateNewTokenForLangResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_95: string = input.readString();
                        _args.success = value_95;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_96: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_96;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_97: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_97;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GenerateNewTokenForLangResult(_args);
    }
}
export interface IGetAllCustomTranslateResultArgs {
    success?: Map<string, string>;
}
export class GetAllCustomTranslateResult {
    public success?: Map<string, string>;
    constructor(args?: IGetAllCustomTranslateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllCustomTranslateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.MAP, 0);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.STRING, this.success.size);
            this.success.forEach((value_98: string, key_5: string): void => {
                output.writeString(key_5);
                output.writeString(value_98);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllCustomTranslateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_99: Map<string, string> = new Map<string, string>();
                        const metadata_3: thrift.TMap = input.readMapBegin();
                        const size_3: number = metadata_3.size;
                        for (let i_3: number = 0; i_3 < size_3; i_3++) {
                            const key_6: string = input.readString();
                            const value_100: string = input.readString();
                            value_99.set(key_6, value_100);
                        }
                        input.readMapEnd();
                        _args.success = value_99;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllCustomTranslateResult(_args);
    }
}
export interface IGetExtendedInfoResultArgs {
    success?: ExtInfo.ExtInfo;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetExtendedInfoResult {
    public success?: ExtInfo.ExtInfo;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetExtendedInfoResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetExtendedInfoResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetExtendedInfoResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_101: ExtInfo.ExtInfo = ExtInfo.ExtInfo.read(input);
                        _args.success = value_101;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_102: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_102;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_103: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_103;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetExtendedInfoResult(_args);
    }
}
export interface IIsModuleAllowedResultArgs {
    success?: string;
}
export class IsModuleAllowedResult {
    public success?: string;
    constructor(args?: IIsModuleAllowedResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("IsModuleAllowedResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): IsModuleAllowedResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_104: string = input.readString();
                        _args.success = value_104;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new IsModuleAllowedResult(_args);
    }
}
export interface IGetOTPForSocketRegistrationResultArgs {
    success?: string;
}
export class GetOTPForSocketRegistrationResult {
    public success?: string;
    constructor(args?: IGetOTPForSocketRegistrationResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetOTPForSocketRegistrationResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetOTPForSocketRegistrationResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_105: string = input.readString();
                        _args.success = value_105;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetOTPForSocketRegistrationResult(_args);
    }
}
export interface IGetOtpSendChannelsResultArgs {
    success?: Set<OtpSendChannelType.OtpSendChannelType>;
}
export class GetOtpSendChannelsResult {
    public success?: Set<OtpSendChannelType.OtpSendChannelType>;
    constructor(args?: IGetOtpSendChannelsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetOtpSendChannelsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.SET, 0);
            output.writeSetBegin(thrift.Thrift.Type.I32, this.success.size);
            this.success.forEach((value_106: OtpSendChannelType.OtpSendChannelType): void => {
                output.writeI32(value_106);
            });
            output.writeSetEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetOtpSendChannelsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.SET) {
                        const value_107: Set<OtpSendChannelType.OtpSendChannelType> = new Set<OtpSendChannelType.OtpSendChannelType>();
                        const metadata_4: thrift.TSet = input.readSetBegin();
                        const size_4: number = metadata_4.size;
                        for (let i_4: number = 0; i_4 < size_4; i_4++) {
                            const value_108: OtpSendChannelType.OtpSendChannelType = input.readI32();
                            value_107.add(value_108);
                        }
                        input.readSetEnd();
                        _args.success = value_107;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetOtpSendChannelsResult(_args);
    }
}
export class Client {
    public _seqid: number;
    public _reqs: {
        [name: number]: (err: Error | object | undefined, val?: any) => void;
    };
    public output: thrift.TTransport;
    public protocol: new (trans: thrift.TTransport) => thrift.TProtocol;
    constructor(output: thrift.TTransport, protocol: new (trans: thrift.TTransport) => thrift.TProtocol) {
        this._seqid = 0;
        this._reqs = {};
        this.output = output;
        this.protocol = protocol;
    }
    public incrementSeqId(): number {
        return this._seqid += 1;
    }
    public authenticate(login: string, password: string, device: Device.Device, ip: string, findOpened: boolean, langCode: string, cacheVersion: number): Promise<AuthSession.AuthSession> {
        const requestId: number = this.incrementSeqId();
        return new Promise<AuthSession.AuthSession>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_authenticate(login, password, device, ip, findOpened, langCode, cacheVersion, requestId);
        });
    }
    public authenticateGuest(guestId: string, password: string, ip: string, langCode: string): Promise<AuthSession.AuthSession> {
        const requestId: number = this.incrementSeqId();
        return new Promise<AuthSession.AuthSession>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_authenticateGuest(guestId, password, ip, langCode, requestId);
        });
    }
    public authenticateExtended(authCreds: AuthCreds.AuthCreds, device: Device.Device, ip: string, findOpened: boolean, langCode: string, cacheVersion: number): Promise<AuthSession.AuthSession> {
        const requestId: number = this.incrementSeqId();
        return new Promise<AuthSession.AuthSession>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_authenticateExtended(authCreds, device, ip, findOpened, langCode, cacheVersion, requestId);
        });
    }
    public checkOTP(token: string, otp: string): Promise<AuthSession.AuthSession> {
        const requestId: number = this.incrementSeqId();
        return new Promise<AuthSession.AuthSession>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_checkOTP(token, otp, requestId);
        });
    }
    public resendOTP(token: string, sendChannelType: OtpSendChannelType.OtpSendChannelType): Promise<AuthSession.AuthSession> {
        const requestId: number = this.incrementSeqId();
        return new Promise<AuthSession.AuthSession>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_resendOTP(token, sendChannelType, requestId);
        });
    }
    public refreshAuthSession(token: string): Promise<AuthSession.AuthSession> {
        const requestId: number = this.incrementSeqId();
        return new Promise<AuthSession.AuthSession>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_refreshAuthSession(token, requestId);
        });
    }
    public isAuthSessionExpired(token: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_isAuthSessionExpired(token, requestId);
        });
    }
    public changePassword(token: string, oldPassword: string, password: string, confirmation: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changePassword(token, oldPassword, password, confirmation, requestId);
        });
    }
    public requestResetPassword(token: string, login: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_requestResetPassword(token, login, requestId);
        });
    }
    public finishResetPassword(login: string, confirmationCode: string, password: string, confirmation: string, langCode: string): Promise<AuthSession.AuthSession> {
        const requestId: number = this.incrementSeqId();
        return new Promise<AuthSession.AuthSession>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_finishResetPassword(login, confirmationCode, password, confirmation, langCode, requestId);
        });
    }
    public logout(token: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_logout(token, requestId);
        });
    }
    public authenticateAs(token: string, toUserId: string): Promise<AuthSession.AuthSession> {
        const requestId: number = this.incrementSeqId();
        return new Promise<AuthSession.AuthSession>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_authenticateAs(token, toUserId, requestId);
        });
    }
    public getInfo(): Promise<Map<string, string>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Map<string, string>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getInfo(requestId);
        });
    }
    public getSettings(): Promise<ServerSettings.ServerSettings> {
        const requestId: number = this.incrementSeqId();
        return new Promise<ServerSettings.ServerSettings>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getSettings(requestId);
        });
    }
    public extendSession(token: string, keyword: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_extendSession(token, keyword, requestId);
        });
    }
    public getAllLanguages(): Promise<Map<string, string>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Map<string, string>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllLanguages(requestId);
        });
    }
    public generateNewTokenForLang(token: string, newLang: string): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_generateNewTokenForLang(token, newLang, requestId);
        });
    }
    public getAllCustomTranslate(langCode: string): Promise<Map<string, string>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Map<string, string>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllCustomTranslate(langCode, requestId);
        });
    }
    public getExtendedInfo(token: string): Promise<ExtInfo.ExtInfo> {
        const requestId: number = this.incrementSeqId();
        return new Promise<ExtInfo.ExtInfo>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getExtendedInfo(token, requestId);
        });
    }
    public isModuleAllowed(param: string): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_isModuleAllowed(param, requestId);
        });
    }
    public getOTPForSocketRegistration(token: string): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getOTPForSocketRegistration(token, requestId);
        });
    }
    public getOtpSendChannels(token: string): Promise<Set<OtpSendChannelType.OtpSendChannelType>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Set<OtpSendChannelType.OtpSendChannelType>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getOtpSendChannels(token, requestId);
        });
    }
    public send_authenticate(login: string, password: string, device: Device.Device, ip: string, findOpened: boolean, langCode: string, cacheVersion: number, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("authenticate", thrift.Thrift.MessageType.CALL, requestId);
        const args: AuthenticateArgs = new AuthenticateArgs({ login, password, device, ip, findOpened, langCode, cacheVersion });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_authenticateGuest(guestId: string, password: string, ip: string, langCode: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("authenticateGuest", thrift.Thrift.MessageType.CALL, requestId);
        const args: AuthenticateGuestArgs = new AuthenticateGuestArgs({ guestId, password, ip, langCode });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_authenticateExtended(authCreds: AuthCreds.AuthCreds, device: Device.Device, ip: string, findOpened: boolean, langCode: string, cacheVersion: number, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("authenticateExtended", thrift.Thrift.MessageType.CALL, requestId);
        const args: AuthenticateExtendedArgs = new AuthenticateExtendedArgs({ authCreds, device, ip, findOpened, langCode, cacheVersion });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_checkOTP(token: string, otp: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("checkOTP", thrift.Thrift.MessageType.CALL, requestId);
        const args: CheckOTPArgs = new CheckOTPArgs({ token, otp });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_resendOTP(token: string, sendChannelType: OtpSendChannelType.OtpSendChannelType, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("resendOTP", thrift.Thrift.MessageType.CALL, requestId);
        const args: ResendOTPArgs = new ResendOTPArgs({ token, sendChannelType });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_refreshAuthSession(token: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("refreshAuthSession", thrift.Thrift.MessageType.CALL, requestId);
        const args: RefreshAuthSessionArgs = new RefreshAuthSessionArgs({ token });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_isAuthSessionExpired(token: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("isAuthSessionExpired", thrift.Thrift.MessageType.CALL, requestId);
        const args: IsAuthSessionExpiredArgs = new IsAuthSessionExpiredArgs({ token });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changePassword(token: string, oldPassword: string, password: string, confirmation: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changePassword", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangePasswordArgs = new ChangePasswordArgs({ token, oldPassword, password, confirmation });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_requestResetPassword(token: string, login: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("requestResetPassword", thrift.Thrift.MessageType.CALL, requestId);
        const args: RequestResetPasswordArgs = new RequestResetPasswordArgs({ token, login });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_finishResetPassword(login: string, confirmationCode: string, password: string, confirmation: string, langCode: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("finishResetPassword", thrift.Thrift.MessageType.CALL, requestId);
        const args: FinishResetPasswordArgs = new FinishResetPasswordArgs({ login, confirmationCode, password, confirmation, langCode });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_logout(token: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("logout", thrift.Thrift.MessageType.CALL, requestId);
        const args: LogoutArgs = new LogoutArgs({ token });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_authenticateAs(token: string, toUserId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("authenticateAs", thrift.Thrift.MessageType.CALL, requestId);
        const args: AuthenticateAsArgs = new AuthenticateAsArgs({ token, toUserId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getInfo(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getInfo", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetInfoArgs = new GetInfoArgs();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getSettings(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getSettings", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetSettingsArgs = new GetSettingsArgs();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_extendSession(token: string, keyword: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("extendSession", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExtendSessionArgs = new ExtendSessionArgs({ token, keyword });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllLanguages(requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllLanguages", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllLanguagesArgs = new GetAllLanguagesArgs();
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_generateNewTokenForLang(token: string, newLang: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("generateNewTokenForLang", thrift.Thrift.MessageType.CALL, requestId);
        const args: GenerateNewTokenForLangArgs = new GenerateNewTokenForLangArgs({ token, newLang });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllCustomTranslate(langCode: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllCustomTranslate", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllCustomTranslateArgs = new GetAllCustomTranslateArgs({ langCode });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getExtendedInfo(token: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getExtendedInfo", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetExtendedInfoArgs = new GetExtendedInfoArgs({ token });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_isModuleAllowed(param: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("isModuleAllowed", thrift.Thrift.MessageType.CALL, requestId);
        const args: IsModuleAllowedArgs = new IsModuleAllowedArgs({ param });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getOTPForSocketRegistration(token: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getOTPForSocketRegistration", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetOTPForSocketRegistrationArgs = new GetOTPForSocketRegistrationArgs({ token });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getOtpSendChannels(token: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getOtpSendChannels", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetOtpSendChannelsArgs = new GetOtpSendChannelsArgs({ token });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public recv_authenticate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AuthenticateResult = AuthenticateResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "authenticate failed: unknown result"));
                }
            }
        }
    }
    public recv_authenticateGuest(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AuthenticateGuestResult = AuthenticateGuestResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "authenticateGuest failed: unknown result"));
                }
            }
        }
    }
    public recv_authenticateExtended(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AuthenticateExtendedResult = AuthenticateExtendedResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "authenticateExtended failed: unknown result"));
                }
            }
        }
    }
    public recv_checkOTP(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CheckOTPResult = CheckOTPResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "checkOTP failed: unknown result"));
                }
            }
        }
    }
    public recv_resendOTP(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ResendOTPResult = ResendOTPResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "resendOTP failed: unknown result"));
                }
            }
        }
    }
    public recv_refreshAuthSession(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RefreshAuthSessionResult = RefreshAuthSessionResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "refreshAuthSession failed: unknown result"));
                }
            }
        }
    }
    public recv_isAuthSessionExpired(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: IsAuthSessionExpiredResult = IsAuthSessionExpiredResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "isAuthSessionExpired failed: unknown result"));
                }
            }
        }
    }
    public recv_changePassword(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangePasswordResult = ChangePasswordResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changePassword failed: unknown result"));
                }
            }
        }
    }
    public recv_requestResetPassword(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RequestResetPasswordResult = RequestResetPasswordResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "requestResetPassword failed: unknown result"));
                }
            }
        }
    }
    public recv_finishResetPassword(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: FinishResetPasswordResult = FinishResetPasswordResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "finishResetPassword failed: unknown result"));
                }
            }
        }
    }
    public recv_logout(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: LogoutResult = LogoutResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "logout failed: unknown result"));
                }
            }
        }
    }
    public recv_authenticateAs(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AuthenticateAsResult = AuthenticateAsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "authenticateAs failed: unknown result"));
                }
            }
        }
    }
    public recv_getInfo(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetInfoResult = GetInfoResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getInfo failed: unknown result"));
            }
        }
    }
    public recv_getSettings(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetSettingsResult = GetSettingsResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getSettings failed: unknown result"));
            }
        }
    }
    public recv_extendSession(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExtendSessionResult = ExtendSessionResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "extendSession failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllLanguages(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllLanguagesResult = GetAllLanguagesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllLanguages failed: unknown result"));
                }
            }
        }
    }
    public recv_generateNewTokenForLang(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GenerateNewTokenForLangResult = GenerateNewTokenForLangResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "generateNewTokenForLang failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllCustomTranslate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllCustomTranslateResult = GetAllCustomTranslateResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllCustomTranslate failed: unknown result"));
            }
        }
    }
    public recv_getExtendedInfo(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetExtendedInfoResult = GetExtendedInfoResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getExtendedInfo failed: unknown result"));
                }
            }
        }
    }
    public recv_isModuleAllowed(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: IsModuleAllowedResult = IsModuleAllowedResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "isModuleAllowed failed: unknown result"));
            }
        }
    }
    public recv_getOTPForSocketRegistration(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetOTPForSocketRegistrationResult = GetOTPForSocketRegistrationResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getOTPForSocketRegistration failed: unknown result"));
            }
        }
    }
    public recv_getOtpSendChannels(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetOtpSendChannelsResult = GetOtpSendChannelsResult.read(input);
            input.readMessageEnd();
            if (result.success != null) {
                return callback(undefined, result.success);
            }
            else {
                return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getOtpSendChannels failed: unknown result"));
            }
        }
    }
}
export interface IHandler {
    authenticate(login: string, password: string, device: Device.Device, ip: string, findOpened: boolean, langCode: string, cacheVersion: number): AuthSession.AuthSession | Promise<AuthSession.AuthSession>;
    authenticateGuest(guestId: string, password: string, ip: string, langCode: string): AuthSession.AuthSession | Promise<AuthSession.AuthSession>;
    authenticateExtended(authCreds: AuthCreds.AuthCreds, device: Device.Device, ip: string, findOpened: boolean, langCode: string, cacheVersion: number): AuthSession.AuthSession | Promise<AuthSession.AuthSession>;
    checkOTP(token: string, otp: string): AuthSession.AuthSession | Promise<AuthSession.AuthSession>;
    resendOTP(token: string, sendChannelType: OtpSendChannelType.OtpSendChannelType): AuthSession.AuthSession | Promise<AuthSession.AuthSession>;
    refreshAuthSession(token: string): AuthSession.AuthSession | Promise<AuthSession.AuthSession>;
    isAuthSessionExpired(token: string): boolean | Promise<boolean>;
    changePassword(token: string, oldPassword: string, password: string, confirmation: string): boolean | Promise<boolean>;
    requestResetPassword(token: string, login: string): boolean | Promise<boolean>;
    finishResetPassword(login: string, confirmationCode: string, password: string, confirmation: string, langCode: string): AuthSession.AuthSession | Promise<AuthSession.AuthSession>;
    logout(token: string): boolean | Promise<boolean>;
    authenticateAs(token: string, toUserId: string): AuthSession.AuthSession | Promise<AuthSession.AuthSession>;
    getInfo(): Map<string, string> | Promise<Map<string, string>>;
    getSettings(): ServerSettings.ServerSettings | Promise<ServerSettings.ServerSettings>;
    extendSession(token: string, keyword: string): boolean | Promise<boolean>;
    getAllLanguages(): Map<string, string> | Promise<Map<string, string>>;
    generateNewTokenForLang(token: string, newLang: string): string | Promise<string>;
    getAllCustomTranslate(langCode: string): Map<string, string> | Promise<Map<string, string>>;
    getExtendedInfo(token: string): ExtInfo.ExtInfo | Promise<ExtInfo.ExtInfo>;
    isModuleAllowed(param: string): string | Promise<string>;
    getOTPForSocketRegistration(token: string): string | Promise<string>;
    getOtpSendChannels(token: string): Set<OtpSendChannelType.OtpSendChannelType> | Promise<Set<OtpSendChannelType.OtpSendChannelType>>;
}
export class Processor {
    public _handler: IHandler;
    constructor(handler: IHandler) {
        this._handler = handler;
    }
    public process(input: thrift.TProtocol, output: thrift.TProtocol): void {
        const metadata: thrift.TMessage = input.readMessageBegin();
        const fname: string = metadata.fname;
        const requestId: number = metadata.rseqid;
        const methodName: string = "process_" + fname;
        switch (methodName) {
            case "process_authenticate": {
                this.process_authenticate(requestId, input, output);
                return;
            }
            case "process_authenticateGuest": {
                this.process_authenticateGuest(requestId, input, output);
                return;
            }
            case "process_authenticateExtended": {
                this.process_authenticateExtended(requestId, input, output);
                return;
            }
            case "process_checkOTP": {
                this.process_checkOTP(requestId, input, output);
                return;
            }
            case "process_resendOTP": {
                this.process_resendOTP(requestId, input, output);
                return;
            }
            case "process_refreshAuthSession": {
                this.process_refreshAuthSession(requestId, input, output);
                return;
            }
            case "process_isAuthSessionExpired": {
                this.process_isAuthSessionExpired(requestId, input, output);
                return;
            }
            case "process_changePassword": {
                this.process_changePassword(requestId, input, output);
                return;
            }
            case "process_requestResetPassword": {
                this.process_requestResetPassword(requestId, input, output);
                return;
            }
            case "process_finishResetPassword": {
                this.process_finishResetPassword(requestId, input, output);
                return;
            }
            case "process_logout": {
                this.process_logout(requestId, input, output);
                return;
            }
            case "process_authenticateAs": {
                this.process_authenticateAs(requestId, input, output);
                return;
            }
            case "process_getInfo": {
                this.process_getInfo(requestId, input, output);
                return;
            }
            case "process_getSettings": {
                this.process_getSettings(requestId, input, output);
                return;
            }
            case "process_extendSession": {
                this.process_extendSession(requestId, input, output);
                return;
            }
            case "process_getAllLanguages": {
                this.process_getAllLanguages(requestId, input, output);
                return;
            }
            case "process_generateNewTokenForLang": {
                this.process_generateNewTokenForLang(requestId, input, output);
                return;
            }
            case "process_getAllCustomTranslate": {
                this.process_getAllCustomTranslate(requestId, input, output);
                return;
            }
            case "process_getExtendedInfo": {
                this.process_getExtendedInfo(requestId, input, output);
                return;
            }
            case "process_isModuleAllowed": {
                this.process_isModuleAllowed(requestId, input, output);
                return;
            }
            case "process_getOTPForSocketRegistration": {
                this.process_getOTPForSocketRegistration(requestId, input, output);
                return;
            }
            case "process_getOtpSendChannels": {
                this.process_getOtpSendChannels(requestId, input, output);
                return;
            }
            default: {
                input.skip(thrift.Thrift.Type.STRUCT);
                input.readMessageEnd();
                const errMessage = "Unknown function " + fname;
                const err = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                output.writeMessageBegin(fname, thrift.Thrift.MessageType.EXCEPTION, requestId);
                err.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        }
    }
    public process_authenticate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<AuthSession.AuthSession>((resolve, reject): void => {
            try {
                const args: AuthenticateArgs = AuthenticateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.authenticate(args.login, args.password, args.device, args.ip, args.findOpened, args.langCode, args.cacheVersion));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: AuthSession.AuthSession): void => {
            const result: AuthenticateResult = new AuthenticateResult({ success: data });
            output.writeMessageBegin("authenticate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: AuthenticateResult = new AuthenticateResult({ validError: err });
                output.writeMessageBegin("authenticate", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: AuthenticateResult = new AuthenticateResult({ error: err });
                output.writeMessageBegin("authenticate", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("authenticate", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_authenticateGuest(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<AuthSession.AuthSession>((resolve, reject): void => {
            try {
                const args: AuthenticateGuestArgs = AuthenticateGuestArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.authenticateGuest(args.guestId, args.password, args.ip, args.langCode));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: AuthSession.AuthSession): void => {
            const result: AuthenticateGuestResult = new AuthenticateGuestResult({ success: data });
            output.writeMessageBegin("authenticateGuest", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: AuthenticateGuestResult = new AuthenticateGuestResult({ validError: err });
                output.writeMessageBegin("authenticateGuest", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: AuthenticateGuestResult = new AuthenticateGuestResult({ error: err });
                output.writeMessageBegin("authenticateGuest", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("authenticateGuest", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_authenticateExtended(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<AuthSession.AuthSession>((resolve, reject): void => {
            try {
                const args: AuthenticateExtendedArgs = AuthenticateExtendedArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.authenticateExtended(args.authCreds, args.device, args.ip, args.findOpened, args.langCode, args.cacheVersion));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: AuthSession.AuthSession): void => {
            const result: AuthenticateExtendedResult = new AuthenticateExtendedResult({ success: data });
            output.writeMessageBegin("authenticateExtended", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: AuthenticateExtendedResult = new AuthenticateExtendedResult({ validError: err });
                output.writeMessageBegin("authenticateExtended", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: AuthenticateExtendedResult = new AuthenticateExtendedResult({ error: err });
                output.writeMessageBegin("authenticateExtended", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("authenticateExtended", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_checkOTP(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<AuthSession.AuthSession>((resolve, reject): void => {
            try {
                const args: CheckOTPArgs = CheckOTPArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.checkOTP(args.token, args.otp));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: AuthSession.AuthSession): void => {
            const result: CheckOTPResult = new CheckOTPResult({ success: data });
            output.writeMessageBegin("checkOTP", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: CheckOTPResult = new CheckOTPResult({ validError: err });
                output.writeMessageBegin("checkOTP", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: CheckOTPResult = new CheckOTPResult({ error: err });
                output.writeMessageBegin("checkOTP", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("checkOTP", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_resendOTP(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<AuthSession.AuthSession>((resolve, reject): void => {
            try {
                const args: ResendOTPArgs = ResendOTPArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.resendOTP(args.token, args.sendChannelType));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: AuthSession.AuthSession): void => {
            const result: ResendOTPResult = new ResendOTPResult({ success: data });
            output.writeMessageBegin("resendOTP", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: ResendOTPResult = new ResendOTPResult({ validError: err });
                output.writeMessageBegin("resendOTP", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: ResendOTPResult = new ResendOTPResult({ error: err });
                output.writeMessageBegin("resendOTP", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("resendOTP", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_refreshAuthSession(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<AuthSession.AuthSession>((resolve, reject): void => {
            try {
                const args: RefreshAuthSessionArgs = RefreshAuthSessionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.refreshAuthSession(args.token));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: AuthSession.AuthSession): void => {
            const result: RefreshAuthSessionResult = new RefreshAuthSessionResult({ success: data });
            output.writeMessageBegin("refreshAuthSession", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: RefreshAuthSessionResult = new RefreshAuthSessionResult({ validError: err });
                output.writeMessageBegin("refreshAuthSession", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: RefreshAuthSessionResult = new RefreshAuthSessionResult({ error: err });
                output.writeMessageBegin("refreshAuthSession", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("refreshAuthSession", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_isAuthSessionExpired(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: IsAuthSessionExpiredArgs = IsAuthSessionExpiredArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.isAuthSessionExpired(args.token));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: IsAuthSessionExpiredResult = new IsAuthSessionExpiredResult({ success: data });
            output.writeMessageBegin("isAuthSessionExpired", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: IsAuthSessionExpiredResult = new IsAuthSessionExpiredResult({ validError: err });
                output.writeMessageBegin("isAuthSessionExpired", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: IsAuthSessionExpiredResult = new IsAuthSessionExpiredResult({ error: err });
                output.writeMessageBegin("isAuthSessionExpired", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("isAuthSessionExpired", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changePassword(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangePasswordArgs = ChangePasswordArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changePassword(args.token, args.oldPassword, args.password, args.confirmation));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangePasswordResult = new ChangePasswordResult({ success: data });
            output.writeMessageBegin("changePassword", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: ChangePasswordResult = new ChangePasswordResult({ validError: err });
                output.writeMessageBegin("changePassword", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: ChangePasswordResult = new ChangePasswordResult({ error: err });
                output.writeMessageBegin("changePassword", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changePassword", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_requestResetPassword(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RequestResetPasswordArgs = RequestResetPasswordArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.requestResetPassword(args.token, args.login));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RequestResetPasswordResult = new RequestResetPasswordResult({ success: data });
            output.writeMessageBegin("requestResetPassword", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: RequestResetPasswordResult = new RequestResetPasswordResult({ validError: err });
                output.writeMessageBegin("requestResetPassword", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: RequestResetPasswordResult = new RequestResetPasswordResult({ error: err });
                output.writeMessageBegin("requestResetPassword", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("requestResetPassword", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_finishResetPassword(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<AuthSession.AuthSession>((resolve, reject): void => {
            try {
                const args: FinishResetPasswordArgs = FinishResetPasswordArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.finishResetPassword(args.login, args.confirmationCode, args.password, args.confirmation, args.langCode));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: AuthSession.AuthSession): void => {
            const result: FinishResetPasswordResult = new FinishResetPasswordResult({ success: data });
            output.writeMessageBegin("finishResetPassword", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: FinishResetPasswordResult = new FinishResetPasswordResult({ validError: err });
                output.writeMessageBegin("finishResetPassword", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: FinishResetPasswordResult = new FinishResetPasswordResult({ error: err });
                output.writeMessageBegin("finishResetPassword", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("finishResetPassword", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_logout(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: LogoutArgs = LogoutArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.logout(args.token));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: LogoutResult = new LogoutResult({ success: data });
            output.writeMessageBegin("logout", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: LogoutResult = new LogoutResult({ validError: err });
                output.writeMessageBegin("logout", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: LogoutResult = new LogoutResult({ error: err });
                output.writeMessageBegin("logout", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("logout", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_authenticateAs(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<AuthSession.AuthSession>((resolve, reject): void => {
            try {
                const args: AuthenticateAsArgs = AuthenticateAsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.authenticateAs(args.token, args.toUserId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: AuthSession.AuthSession): void => {
            const result: AuthenticateAsResult = new AuthenticateAsResult({ success: data });
            output.writeMessageBegin("authenticateAs", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: AuthenticateAsResult = new AuthenticateAsResult({ validError: err });
                output.writeMessageBegin("authenticateAs", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: AuthenticateAsResult = new AuthenticateAsResult({ error: err });
                output.writeMessageBegin("authenticateAs", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("authenticateAs", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getInfo(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Map<string, string>>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.getInfo());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Map<string, string>): void => {
            const result: GetInfoResult = new GetInfoResult({ success: data });
            output.writeMessageBegin("getInfo", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("getInfo", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_getSettings(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<ServerSettings.ServerSettings>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.getSettings());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ServerSettings.ServerSettings): void => {
            const result: GetSettingsResult = new GetSettingsResult({ success: data });
            output.writeMessageBegin("getSettings", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("getSettings", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_extendSession(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ExtendSessionArgs = ExtendSessionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.extendSession(args.token, args.keyword));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ExtendSessionResult = new ExtendSessionResult({ success: data });
            output.writeMessageBegin("extendSession", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: ExtendSessionResult = new ExtendSessionResult({ validError: err });
                output.writeMessageBegin("extendSession", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: ExtendSessionResult = new ExtendSessionResult({ error: err });
                output.writeMessageBegin("extendSession", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("extendSession", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllLanguages(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Map<string, string>>((resolve, reject): void => {
            try {
                input.readMessageEnd();
                resolve(this._handler.getAllLanguages());
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Map<string, string>): void => {
            const result: GetAllLanguagesResult = new GetAllLanguagesResult({ success: data });
            output.writeMessageBegin("getAllLanguages", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllLanguagesResult = new GetAllLanguagesResult({ validError: err });
                output.writeMessageBegin("getAllLanguages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllLanguagesResult = new GetAllLanguagesResult({ error: err });
                output.writeMessageBegin("getAllLanguages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllLanguages", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_generateNewTokenForLang(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: GenerateNewTokenForLangArgs = GenerateNewTokenForLangArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.generateNewTokenForLang(args.token, args.newLang));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: GenerateNewTokenForLangResult = new GenerateNewTokenForLangResult({ success: data });
            output.writeMessageBegin("generateNewTokenForLang", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GenerateNewTokenForLangResult = new GenerateNewTokenForLangResult({ validError: err });
                output.writeMessageBegin("generateNewTokenForLang", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GenerateNewTokenForLangResult = new GenerateNewTokenForLangResult({ error: err });
                output.writeMessageBegin("generateNewTokenForLang", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("generateNewTokenForLang", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllCustomTranslate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Map<string, string>>((resolve, reject): void => {
            try {
                const args: GetAllCustomTranslateArgs = GetAllCustomTranslateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllCustomTranslate(args.langCode));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Map<string, string>): void => {
            const result: GetAllCustomTranslateResult = new GetAllCustomTranslateResult({ success: data });
            output.writeMessageBegin("getAllCustomTranslate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("getAllCustomTranslate", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_getExtendedInfo(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<ExtInfo.ExtInfo>((resolve, reject): void => {
            try {
                const args: GetExtendedInfoArgs = GetExtendedInfoArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getExtendedInfo(args.token));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ExtInfo.ExtInfo): void => {
            const result: GetExtendedInfoResult = new GetExtendedInfoResult({ success: data });
            output.writeMessageBegin("getExtendedInfo", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetExtendedInfoResult = new GetExtendedInfoResult({ validError: err });
                output.writeMessageBegin("getExtendedInfo", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetExtendedInfoResult = new GetExtendedInfoResult({ error: err });
                output.writeMessageBegin("getExtendedInfo", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getExtendedInfo", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_isModuleAllowed(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: IsModuleAllowedArgs = IsModuleAllowedArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.isModuleAllowed(args.param));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: IsModuleAllowedResult = new IsModuleAllowedResult({ success: data });
            output.writeMessageBegin("isModuleAllowed", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("isModuleAllowed", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_getOTPForSocketRegistration(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: GetOTPForSocketRegistrationArgs = GetOTPForSocketRegistrationArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getOTPForSocketRegistration(args.token));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: GetOTPForSocketRegistrationResult = new GetOTPForSocketRegistrationResult({ success: data });
            output.writeMessageBegin("getOTPForSocketRegistration", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("getOTPForSocketRegistration", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
    public process_getOtpSendChannels(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Set<OtpSendChannelType.OtpSendChannelType>>((resolve, reject): void => {
            try {
                const args: GetOtpSendChannelsArgs = GetOtpSendChannelsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getOtpSendChannels(args.token));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Set<OtpSendChannelType.OtpSendChannelType>): void => {
            const result: GetOtpSendChannelsResult = new GetOtpSendChannelsResult({ success: data });
            output.writeMessageBegin("getOtpSendChannels", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("getOtpSendChannels", thrift.Thrift.MessageType.EXCEPTION, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        });
    }
}
