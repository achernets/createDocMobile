/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import { Int64 } from "thrift";
import * as thrift from "thrift";
import * as __ROOT_NAMESPACE__ from "./";
import * as ExternalModule from "./ExternalModule";
import * as UserAcc from "./UserAcc";
import * as UserExt from "./UserExt";
import * as CopyPersonalAccessSettings from "./CopyPersonalAccessSettings";
import * as License from "./License";
import * as LicenseModulePage from "./LicenseModulePage";
import * as LicenseModule from "./LicenseModule";
import * as CharMatchingDictionary from "./CharMatchingDictionary";
import * as JobTask from "./JobTask";
import * as UserOptions from "./UserOptions";
export interface IGetAvailableFileStorageListArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetAvailableFileStorageListArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetAvailableFileStorageListArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAvailableFileStorageListArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAvailableFileStorageListArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_1: string = input.readString();
                        _args.token = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_2: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_2;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAvailableFileStorageListArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAvailableFileStorageListArgs from input");
        }
    }
}
export interface ICreateOrUpdateFileStorageArgsArgs {
    token: string;
    fileStorage: __ROOT_NAMESPACE__.FileStorage;
    password: string;
    accountsToAdd: Array<__ROOT_NAMESPACE__.Account>;
    accountsToRemove: Array<__ROOT_NAMESPACE__.Account>;
}
export class CreateOrUpdateFileStorageArgs {
    public token: string;
    public fileStorage: __ROOT_NAMESPACE__.FileStorage;
    public password: string;
    public accountsToAdd: Array<__ROOT_NAMESPACE__.Account>;
    public accountsToRemove: Array<__ROOT_NAMESPACE__.Account>;
    constructor(args: ICreateOrUpdateFileStorageArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.fileStorage != null) {
            this.fileStorage = args.fileStorage;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[fileStorage] is unset!");
        }
        if (args != null && args.password != null) {
            this.password = args.password;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[password] is unset!");
        }
        if (args != null && args.accountsToAdd != null) {
            this.accountsToAdd = args.accountsToAdd;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accountsToAdd] is unset!");
        }
        if (args != null && args.accountsToRemove != null) {
            this.accountsToRemove = args.accountsToRemove;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accountsToRemove] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateFileStorageArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.fileStorage != null) {
            output.writeFieldBegin("fileStorage", thrift.Thrift.Type.STRUCT, 2);
            this.fileStorage.write(output);
            output.writeFieldEnd();
        }
        if (this.password != null) {
            output.writeFieldBegin("password", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.password);
            output.writeFieldEnd();
        }
        if (this.accountsToAdd != null) {
            output.writeFieldBegin("accountsToAdd", thrift.Thrift.Type.LIST, 4);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.accountsToAdd.length);
            this.accountsToAdd.forEach((value_3: __ROOT_NAMESPACE__.Account): void => {
                value_3.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.accountsToRemove != null) {
            output.writeFieldBegin("accountsToRemove", thrift.Thrift.Type.LIST, 5);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.accountsToRemove.length);
            this.accountsToRemove.forEach((value_4: __ROOT_NAMESPACE__.Account): void => {
                value_4.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateFileStorageArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_5: string = input.readString();
                        _args.token = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_6: __ROOT_NAMESPACE__.FileStorage = __ROOT_NAMESPACE__.FileStorage.read(input);
                        _args.fileStorage = value_6;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_7: string = input.readString();
                        _args.password = value_7;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_8: Array<__ROOT_NAMESPACE__.Account> = new Array<__ROOT_NAMESPACE__.Account>();
                        const metadata_1: thrift.TList = input.readListBegin();
                        const size_1: number = metadata_1.size;
                        for (let i_1: number = 0; i_1 < size_1; i_1++) {
                            const value_9: __ROOT_NAMESPACE__.Account = __ROOT_NAMESPACE__.Account.read(input);
                            value_8.push(value_9);
                        }
                        input.readListEnd();
                        _args.accountsToAdd = value_8;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_10: Array<__ROOT_NAMESPACE__.Account> = new Array<__ROOT_NAMESPACE__.Account>();
                        const metadata_2: thrift.TList = input.readListBegin();
                        const size_2: number = metadata_2.size;
                        for (let i_2: number = 0; i_2 < size_2; i_2++) {
                            const value_11: __ROOT_NAMESPACE__.Account = __ROOT_NAMESPACE__.Account.read(input);
                            value_10.push(value_11);
                        }
                        input.readListEnd();
                        _args.accountsToRemove = value_10;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.fileStorage !== undefined && _args.password !== undefined && _args.accountsToAdd !== undefined && _args.accountsToRemove !== undefined) {
            return new CreateOrUpdateFileStorageArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateOrUpdateFileStorageArgs from input");
        }
    }
}
export interface IGetAllFileStoragesArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetAllFileStoragesArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetAllFileStoragesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllFileStoragesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllFileStoragesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_12: string = input.readString();
                        _args.token = value_12;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_13: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllFileStoragesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllFileStoragesArgs from input");
        }
    }
}
export interface IGetCountAllFileStoragesArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetCountAllFileStoragesArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetCountAllFileStoragesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllFileStoragesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllFileStoragesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_14: string = input.readString();
                        _args.token = value_14;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_15: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_15;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetCountAllFileStoragesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetCountAllFileStoragesArgs from input");
        }
    }
}
export interface IRemoveFileStoragesArgsArgs {
    token: string;
    fileStorageIds: Array<string>;
    password: string;
}
export class RemoveFileStoragesArgs {
    public token: string;
    public fileStorageIds: Array<string>;
    public password: string;
    constructor(args: IRemoveFileStoragesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.fileStorageIds != null) {
            this.fileStorageIds = args.fileStorageIds;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[fileStorageIds] is unset!");
        }
        if (args != null && args.password != null) {
            this.password = args.password;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[password] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveFileStoragesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.fileStorageIds != null) {
            output.writeFieldBegin("fileStorageIds", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.fileStorageIds.length);
            this.fileStorageIds.forEach((value_16: string): void => {
                output.writeString(value_16);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.password != null) {
            output.writeFieldBegin("password", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.password);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveFileStoragesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_17: string = input.readString();
                        _args.token = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_18: Array<string> = new Array<string>();
                        const metadata_3: thrift.TList = input.readListBegin();
                        const size_3: number = metadata_3.size;
                        for (let i_3: number = 0; i_3 < size_3; i_3++) {
                            const value_19: string = input.readString();
                            value_18.push(value_19);
                        }
                        input.readListEnd();
                        _args.fileStorageIds = value_18;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_20: string = input.readString();
                        _args.password = value_20;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.fileStorageIds !== undefined && _args.password !== undefined) {
            return new RemoveFileStoragesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveFileStoragesArgs from input");
        }
    }
}
export interface IMoveAttachmentArgsArgs {
    token: string;
    docId: string;
    fileStorageId: string;
    onlyLatest: boolean;
}
export class MoveAttachmentArgs {
    public token: string;
    public docId: string;
    public fileStorageId: string;
    public onlyLatest: boolean;
    constructor(args: IMoveAttachmentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docId != null) {
            this.docId = args.docId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docId] is unset!");
        }
        if (args != null && args.fileStorageId != null) {
            this.fileStorageId = args.fileStorageId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[fileStorageId] is unset!");
        }
        if (args != null && args.onlyLatest != null) {
            this.onlyLatest = args.onlyLatest;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[onlyLatest] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MoveAttachmentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docId != null) {
            output.writeFieldBegin("docId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.docId);
            output.writeFieldEnd();
        }
        if (this.fileStorageId != null) {
            output.writeFieldBegin("fileStorageId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.fileStorageId);
            output.writeFieldEnd();
        }
        if (this.onlyLatest != null) {
            output.writeFieldBegin("onlyLatest", thrift.Thrift.Type.BOOL, 4);
            output.writeBool(this.onlyLatest);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MoveAttachmentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_21: string = input.readString();
                        _args.token = value_21;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_22: string = input.readString();
                        _args.docId = value_22;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_23: string = input.readString();
                        _args.fileStorageId = value_23;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_24: boolean = input.readBool();
                        _args.onlyLatest = value_24;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docId !== undefined && _args.fileStorageId !== undefined && _args.onlyLatest !== undefined) {
            return new MoveAttachmentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read MoveAttachmentArgs from input");
        }
    }
}
export interface ICreateOrUpdateNewsArgsArgs {
    token: string;
    news: __ROOT_NAMESPACE__.News;
    accountIDsToAdd: Set<string>;
    accountIDsToRemove: Set<string>;
}
export class CreateOrUpdateNewsArgs {
    public token: string;
    public news: __ROOT_NAMESPACE__.News;
    public accountIDsToAdd: Set<string>;
    public accountIDsToRemove: Set<string>;
    constructor(args: ICreateOrUpdateNewsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.news != null) {
            this.news = args.news;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[news] is unset!");
        }
        if (args != null && args.accountIDsToAdd != null) {
            this.accountIDsToAdd = args.accountIDsToAdd;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accountIDsToAdd] is unset!");
        }
        if (args != null && args.accountIDsToRemove != null) {
            this.accountIDsToRemove = args.accountIDsToRemove;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accountIDsToRemove] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateNewsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.news != null) {
            output.writeFieldBegin("news", thrift.Thrift.Type.STRUCT, 2);
            this.news.write(output);
            output.writeFieldEnd();
        }
        if (this.accountIDsToAdd != null) {
            output.writeFieldBegin("accountIDsToAdd", thrift.Thrift.Type.SET, 3);
            output.writeSetBegin(thrift.Thrift.Type.STRING, this.accountIDsToAdd.size);
            this.accountIDsToAdd.forEach((value_25: string): void => {
                output.writeString(value_25);
            });
            output.writeSetEnd();
            output.writeFieldEnd();
        }
        if (this.accountIDsToRemove != null) {
            output.writeFieldBegin("accountIDsToRemove", thrift.Thrift.Type.SET, 4);
            output.writeSetBegin(thrift.Thrift.Type.STRING, this.accountIDsToRemove.size);
            this.accountIDsToRemove.forEach((value_26: string): void => {
                output.writeString(value_26);
            });
            output.writeSetEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateNewsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_27: string = input.readString();
                        _args.token = value_27;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_28: __ROOT_NAMESPACE__.News = __ROOT_NAMESPACE__.News.read(input);
                        _args.news = value_28;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.SET) {
                        const value_29: Set<string> = new Set<string>();
                        const metadata_4: thrift.TSet = input.readSetBegin();
                        const size_4: number = metadata_4.size;
                        for (let i_4: number = 0; i_4 < size_4; i_4++) {
                            const value_30: string = input.readString();
                            value_29.add(value_30);
                        }
                        input.readSetEnd();
                        _args.accountIDsToAdd = value_29;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.SET) {
                        const value_31: Set<string> = new Set<string>();
                        const metadata_5: thrift.TSet = input.readSetBegin();
                        const size_5: number = metadata_5.size;
                        for (let i_5: number = 0; i_5 < size_5; i_5++) {
                            const value_32: string = input.readString();
                            value_31.add(value_32);
                        }
                        input.readSetEnd();
                        _args.accountIDsToRemove = value_31;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.news !== undefined && _args.accountIDsToAdd !== undefined && _args.accountIDsToRemove !== undefined) {
            return new CreateOrUpdateNewsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateOrUpdateNewsArgs from input");
        }
    }
}
export interface IRemoveNewsArgsArgs {
    token: string;
    newsId: string;
}
export class RemoveNewsArgs {
    public token: string;
    public newsId: string;
    constructor(args: IRemoveNewsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.newsId != null) {
            this.newsId = args.newsId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[newsId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveNewsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.newsId != null) {
            output.writeFieldBegin("newsId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.newsId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveNewsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_33: string = input.readString();
                        _args.token = value_33;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_34: string = input.readString();
                        _args.newsId = value_34;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.newsId !== undefined) {
            return new RemoveNewsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveNewsArgs from input");
        }
    }
}
export interface IGetAllExternalModulesArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetAllExternalModulesArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetAllExternalModulesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllExternalModulesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllExternalModulesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_35: string = input.readString();
                        _args.token = value_35;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_36: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_36;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllExternalModulesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllExternalModulesArgs from input");
        }
    }
}
export interface IGetCountAllExternalModulesArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetCountAllExternalModulesArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetCountAllExternalModulesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllExternalModulesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllExternalModulesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_37: string = input.readString();
                        _args.token = value_37;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_38: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_38;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetCountAllExternalModulesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetCountAllExternalModulesArgs from input");
        }
    }
}
export interface ICreateOrUpdateExternalModuleArgsArgs {
    token: string;
    externalModule: ExternalModule.ExternalModule;
    userLoginForNewRegistration: string;
    secretKey: string;
    addAccountIds: Set<string>;
    deleteAccountIds: Set<string>;
}
export class CreateOrUpdateExternalModuleArgs {
    public token: string;
    public externalModule: ExternalModule.ExternalModule;
    public userLoginForNewRegistration: string;
    public secretKey: string;
    public addAccountIds: Set<string>;
    public deleteAccountIds: Set<string>;
    constructor(args: ICreateOrUpdateExternalModuleArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.externalModule != null) {
            this.externalModule = args.externalModule;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[externalModule] is unset!");
        }
        if (args != null && args.userLoginForNewRegistration != null) {
            this.userLoginForNewRegistration = args.userLoginForNewRegistration;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userLoginForNewRegistration] is unset!");
        }
        if (args != null && args.secretKey != null) {
            this.secretKey = args.secretKey;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[secretKey] is unset!");
        }
        if (args != null && args.addAccountIds != null) {
            this.addAccountIds = args.addAccountIds;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[addAccountIds] is unset!");
        }
        if (args != null && args.deleteAccountIds != null) {
            this.deleteAccountIds = args.deleteAccountIds;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[deleteAccountIds] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateExternalModuleArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.externalModule != null) {
            output.writeFieldBegin("externalModule", thrift.Thrift.Type.STRUCT, 2);
            this.externalModule.write(output);
            output.writeFieldEnd();
        }
        if (this.userLoginForNewRegistration != null) {
            output.writeFieldBegin("userLoginForNewRegistration", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.userLoginForNewRegistration);
            output.writeFieldEnd();
        }
        if (this.secretKey != null) {
            output.writeFieldBegin("secretKey", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.secretKey);
            output.writeFieldEnd();
        }
        if (this.addAccountIds != null) {
            output.writeFieldBegin("addAccountIds", thrift.Thrift.Type.SET, 5);
            output.writeSetBegin(thrift.Thrift.Type.STRING, this.addAccountIds.size);
            this.addAccountIds.forEach((value_39: string): void => {
                output.writeString(value_39);
            });
            output.writeSetEnd();
            output.writeFieldEnd();
        }
        if (this.deleteAccountIds != null) {
            output.writeFieldBegin("deleteAccountIds", thrift.Thrift.Type.SET, 6);
            output.writeSetBegin(thrift.Thrift.Type.STRING, this.deleteAccountIds.size);
            this.deleteAccountIds.forEach((value_40: string): void => {
                output.writeString(value_40);
            });
            output.writeSetEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateExternalModuleArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_41: string = input.readString();
                        _args.token = value_41;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_42: ExternalModule.ExternalModule = ExternalModule.ExternalModule.read(input);
                        _args.externalModule = value_42;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_43: string = input.readString();
                        _args.userLoginForNewRegistration = value_43;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_44: string = input.readString();
                        _args.secretKey = value_44;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.SET) {
                        const value_45: Set<string> = new Set<string>();
                        const metadata_6: thrift.TSet = input.readSetBegin();
                        const size_6: number = metadata_6.size;
                        for (let i_6: number = 0; i_6 < size_6; i_6++) {
                            const value_46: string = input.readString();
                            value_45.add(value_46);
                        }
                        input.readSetEnd();
                        _args.addAccountIds = value_45;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.SET) {
                        const value_47: Set<string> = new Set<string>();
                        const metadata_7: thrift.TSet = input.readSetBegin();
                        const size_7: number = metadata_7.size;
                        for (let i_7: number = 0; i_7 < size_7; i_7++) {
                            const value_48: string = input.readString();
                            value_47.add(value_48);
                        }
                        input.readSetEnd();
                        _args.deleteAccountIds = value_47;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.externalModule !== undefined && _args.userLoginForNewRegistration !== undefined && _args.secretKey !== undefined && _args.addAccountIds !== undefined && _args.deleteAccountIds !== undefined) {
            return new CreateOrUpdateExternalModuleArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateOrUpdateExternalModuleArgs from input");
        }
    }
}
export interface IRefreshExternalModuleArgsArgs {
    token: string;
    extModuleId: string;
    removeDeletedStages: boolean;
}
export class RefreshExternalModuleArgs {
    public token: string;
    public extModuleId: string;
    public removeDeletedStages: boolean;
    constructor(args: IRefreshExternalModuleArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.extModuleId != null) {
            this.extModuleId = args.extModuleId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[extModuleId] is unset!");
        }
        if (args != null && args.removeDeletedStages != null) {
            this.removeDeletedStages = args.removeDeletedStages;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[removeDeletedStages] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RefreshExternalModuleArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.extModuleId != null) {
            output.writeFieldBegin("extModuleId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.extModuleId);
            output.writeFieldEnd();
        }
        if (this.removeDeletedStages != null) {
            output.writeFieldBegin("removeDeletedStages", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.removeDeletedStages);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RefreshExternalModuleArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_49: string = input.readString();
                        _args.token = value_49;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_50: string = input.readString();
                        _args.extModuleId = value_50;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_51: boolean = input.readBool();
                        _args.removeDeletedStages = value_51;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.extModuleId !== undefined && _args.removeDeletedStages !== undefined) {
            return new RefreshExternalModuleArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RefreshExternalModuleArgs from input");
        }
    }
}
export interface IRemoveExternalModuleArgsArgs {
    token: string;
    extModuleId: string;
    password: string;
}
export class RemoveExternalModuleArgs {
    public token: string;
    public extModuleId: string;
    public password: string;
    constructor(args: IRemoveExternalModuleArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.extModuleId != null) {
            this.extModuleId = args.extModuleId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[extModuleId] is unset!");
        }
        if (args != null && args.password != null) {
            this.password = args.password;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[password] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveExternalModuleArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.extModuleId != null) {
            output.writeFieldBegin("extModuleId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.extModuleId);
            output.writeFieldEnd();
        }
        if (this.password != null) {
            output.writeFieldBegin("password", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.password);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveExternalModuleArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_52: string = input.readString();
                        _args.token = value_52;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_53: string = input.readString();
                        _args.extModuleId = value_53;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_54: string = input.readString();
                        _args.password = value_54;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.extModuleId !== undefined && _args.password !== undefined) {
            return new RemoveExternalModuleArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveExternalModuleArgs from input");
        }
    }
}
export interface IPingExternalModuleArgsArgs {
    token: string;
    extModuleId: string;
}
export class PingExternalModuleArgs {
    public token: string;
    public extModuleId: string;
    constructor(args: IPingExternalModuleArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.extModuleId != null) {
            this.extModuleId = args.extModuleId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[extModuleId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PingExternalModuleArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.extModuleId != null) {
            output.writeFieldBegin("extModuleId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.extModuleId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PingExternalModuleArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_55: string = input.readString();
                        _args.token = value_55;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_56: string = input.readString();
                        _args.extModuleId = value_56;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.extModuleId !== undefined) {
            return new PingExternalModuleArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PingExternalModuleArgs from input");
        }
    }
}
export interface IPongExternalModuleArgsArgs {
    token: string;
    extModuleCheckValue: string;
}
export class PongExternalModuleArgs {
    public token: string;
    public extModuleCheckValue: string;
    constructor(args: IPongExternalModuleArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.extModuleCheckValue != null) {
            this.extModuleCheckValue = args.extModuleCheckValue;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[extModuleCheckValue] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PongExternalModuleArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.extModuleCheckValue != null) {
            output.writeFieldBegin("extModuleCheckValue", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.extModuleCheckValue);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PongExternalModuleArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_57: string = input.readString();
                        _args.token = value_57;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_58: string = input.readString();
                        _args.extModuleCheckValue = value_58;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.extModuleCheckValue !== undefined) {
            return new PongExternalModuleArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read PongExternalModuleArgs from input");
        }
    }
}
export interface IGetAllDocumentAttachmentsArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetAllDocumentAttachmentsArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetAllDocumentAttachmentsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentAttachmentsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentAttachmentsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_59: string = input.readString();
                        _args.token = value_59;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_60: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_60;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllDocumentAttachmentsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllDocumentAttachmentsArgs from input");
        }
    }
}
export interface IGetAllFilledDocumentPatternStagesArgsArgs {
    token: string;
    fillDocPatternId: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetAllFilledDocumentPatternStagesArgs {
    public token: string;
    public fillDocPatternId: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetAllFilledDocumentPatternStagesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.fillDocPatternId != null) {
            this.fillDocPatternId = args.fillDocPatternId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[fillDocPatternId] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllFilledDocumentPatternStagesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.fillDocPatternId != null) {
            output.writeFieldBegin("fillDocPatternId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.fillDocPatternId);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 3);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllFilledDocumentPatternStagesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_61: string = input.readString();
                        _args.token = value_61;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_62: string = input.readString();
                        _args.fillDocPatternId = value_62;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_63: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_63;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.fillDocPatternId !== undefined && _args.filter !== undefined) {
            return new GetAllFilledDocumentPatternStagesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllFilledDocumentPatternStagesArgs from input");
        }
    }
}
export interface IResetDocumentForceMoveErrorArgsArgs {
    token: string;
    documentId: string;
}
export class ResetDocumentForceMoveErrorArgs {
    public token: string;
    public documentId: string;
    constructor(args: IResetDocumentForceMoveErrorArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ResetDocumentForceMoveErrorArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ResetDocumentForceMoveErrorArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_64: string = input.readString();
                        _args.token = value_64;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_65: string = input.readString();
                        _args.documentId = value_65;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined) {
            return new ResetDocumentForceMoveErrorArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ResetDocumentForceMoveErrorArgs from input");
        }
    }
}
export interface IChangeExecutorForPatternStagesArgsArgs {
    token: string;
    patternIds: Array<string>;
    userOrGroup: __ROOT_NAMESPACE__.UserOrGroup;
    usersOrGroups: Array<__ROOT_NAMESPACE__.UserOrGroup>;
}
export class ChangeExecutorForPatternStagesArgs {
    public token: string;
    public patternIds: Array<string>;
    public userOrGroup: __ROOT_NAMESPACE__.UserOrGroup;
    public usersOrGroups: Array<__ROOT_NAMESPACE__.UserOrGroup>;
    constructor(args: IChangeExecutorForPatternStagesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.patternIds != null) {
            this.patternIds = args.patternIds;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[patternIds] is unset!");
        }
        if (args != null && args.userOrGroup != null) {
            this.userOrGroup = args.userOrGroup;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userOrGroup] is unset!");
        }
        if (args != null && args.usersOrGroups != null) {
            this.usersOrGroups = args.usersOrGroups;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[usersOrGroups] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeExecutorForPatternStagesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.patternIds != null) {
            output.writeFieldBegin("patternIds", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.patternIds.length);
            this.patternIds.forEach((value_66: string): void => {
                output.writeString(value_66);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.userOrGroup != null) {
            output.writeFieldBegin("userOrGroup", thrift.Thrift.Type.STRUCT, 3);
            this.userOrGroup.write(output);
            output.writeFieldEnd();
        }
        if (this.usersOrGroups != null) {
            output.writeFieldBegin("usersOrGroups", thrift.Thrift.Type.LIST, 4);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.usersOrGroups.length);
            this.usersOrGroups.forEach((value_67: __ROOT_NAMESPACE__.UserOrGroup): void => {
                value_67.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeExecutorForPatternStagesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_68: string = input.readString();
                        _args.token = value_68;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_69: Array<string> = new Array<string>();
                        const metadata_8: thrift.TList = input.readListBegin();
                        const size_8: number = metadata_8.size;
                        for (let i_8: number = 0; i_8 < size_8; i_8++) {
                            const value_70: string = input.readString();
                            value_69.push(value_70);
                        }
                        input.readListEnd();
                        _args.patternIds = value_69;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_71: __ROOT_NAMESPACE__.UserOrGroup = __ROOT_NAMESPACE__.UserOrGroup.read(input);
                        _args.userOrGroup = value_71;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_72: Array<__ROOT_NAMESPACE__.UserOrGroup> = new Array<__ROOT_NAMESPACE__.UserOrGroup>();
                        const metadata_9: thrift.TList = input.readListBegin();
                        const size_9: number = metadata_9.size;
                        for (let i_9: number = 0; i_9 < size_9; i_9++) {
                            const value_73: __ROOT_NAMESPACE__.UserOrGroup = __ROOT_NAMESPACE__.UserOrGroup.read(input);
                            value_72.push(value_73);
                        }
                        input.readListEnd();
                        _args.usersOrGroups = value_72;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.patternIds !== undefined && _args.userOrGroup !== undefined && _args.usersOrGroups !== undefined) {
            return new ChangeExecutorForPatternStagesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeExecutorForPatternStagesArgs from input");
        }
    }
}
export interface ISetUserPublicKeyArgsArgs {
    token: string;
    userId: string;
    publicKey: string;
    password: string;
}
export class SetUserPublicKeyArgs {
    public token: string;
    public userId: string;
    public publicKey: string;
    public password: string;
    constructor(args: ISetUserPublicKeyArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.userId != null) {
            this.userId = args.userId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userId] is unset!");
        }
        if (args != null && args.publicKey != null) {
            this.publicKey = args.publicKey;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[publicKey] is unset!");
        }
        if (args != null && args.password != null) {
            this.password = args.password;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[password] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetUserPublicKeyArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.userId != null) {
            output.writeFieldBegin("userId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.userId);
            output.writeFieldEnd();
        }
        if (this.publicKey != null) {
            output.writeFieldBegin("publicKey", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.publicKey);
            output.writeFieldEnd();
        }
        if (this.password != null) {
            output.writeFieldBegin("password", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.password);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetUserPublicKeyArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_74: string = input.readString();
                        _args.token = value_74;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_75: string = input.readString();
                        _args.userId = value_75;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_76: string = input.readString();
                        _args.publicKey = value_76;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_77: string = input.readString();
                        _args.password = value_77;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.userId !== undefined && _args.publicKey !== undefined && _args.password !== undefined) {
            return new SetUserPublicKeyArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetUserPublicKeyArgs from input");
        }
    }
}
export interface IRemoveUserPublicKeyArgsArgs {
    token: string;
    keyId: string;
    password: string;
}
export class RemoveUserPublicKeyArgs {
    public token: string;
    public keyId: string;
    public password: string;
    constructor(args: IRemoveUserPublicKeyArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.keyId != null) {
            this.keyId = args.keyId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[keyId] is unset!");
        }
        if (args != null && args.password != null) {
            this.password = args.password;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[password] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveUserPublicKeyArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.keyId != null) {
            output.writeFieldBegin("keyId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.keyId);
            output.writeFieldEnd();
        }
        if (this.password != null) {
            output.writeFieldBegin("password", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.password);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveUserPublicKeyArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_78: string = input.readString();
                        _args.token = value_78;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_79: string = input.readString();
                        _args.keyId = value_79;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_80: string = input.readString();
                        _args.password = value_80;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.keyId !== undefined && _args.password !== undefined) {
            return new RemoveUserPublicKeyArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveUserPublicKeyArgs from input");
        }
    }
}
export interface IGetAllUsersRelativeToAccountArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetAllUsersRelativeToAccountArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetAllUsersRelativeToAccountArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllUsersRelativeToAccountArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllUsersRelativeToAccountArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_81: string = input.readString();
                        _args.token = value_81;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_82: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_82;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllUsersRelativeToAccountArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllUsersRelativeToAccountArgs from input");
        }
    }
}
export interface IGetCountAllUsersRelativeToAccountArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetCountAllUsersRelativeToAccountArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetCountAllUsersRelativeToAccountArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllUsersRelativeToAccountArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllUsersRelativeToAccountArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_83: string = input.readString();
                        _args.token = value_83;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_84: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_84;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetCountAllUsersRelativeToAccountArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetCountAllUsersRelativeToAccountArgs from input");
        }
    }
}
export interface IChangeUserAccountsArgsArgs {
    token: string;
    userId: string;
    accountIdsToAdd: Set<string>;
    accountIdsToRemove: Set<string>;
    accountMainId: string;
}
export class ChangeUserAccountsArgs {
    public token: string;
    public userId: string;
    public accountIdsToAdd: Set<string>;
    public accountIdsToRemove: Set<string>;
    public accountMainId: string;
    constructor(args: IChangeUserAccountsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.userId != null) {
            this.userId = args.userId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userId] is unset!");
        }
        if (args != null && args.accountIdsToAdd != null) {
            this.accountIdsToAdd = args.accountIdsToAdd;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accountIdsToAdd] is unset!");
        }
        if (args != null && args.accountIdsToRemove != null) {
            this.accountIdsToRemove = args.accountIdsToRemove;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accountIdsToRemove] is unset!");
        }
        if (args != null && args.accountMainId != null) {
            this.accountMainId = args.accountMainId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accountMainId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeUserAccountsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.userId != null) {
            output.writeFieldBegin("userId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.userId);
            output.writeFieldEnd();
        }
        if (this.accountIdsToAdd != null) {
            output.writeFieldBegin("accountIdsToAdd", thrift.Thrift.Type.SET, 3);
            output.writeSetBegin(thrift.Thrift.Type.STRING, this.accountIdsToAdd.size);
            this.accountIdsToAdd.forEach((value_85: string): void => {
                output.writeString(value_85);
            });
            output.writeSetEnd();
            output.writeFieldEnd();
        }
        if (this.accountIdsToRemove != null) {
            output.writeFieldBegin("accountIdsToRemove", thrift.Thrift.Type.SET, 4);
            output.writeSetBegin(thrift.Thrift.Type.STRING, this.accountIdsToRemove.size);
            this.accountIdsToRemove.forEach((value_86: string): void => {
                output.writeString(value_86);
            });
            output.writeSetEnd();
            output.writeFieldEnd();
        }
        if (this.accountMainId != null) {
            output.writeFieldBegin("accountMainId", thrift.Thrift.Type.STRING, 5);
            output.writeString(this.accountMainId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeUserAccountsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_87: string = input.readString();
                        _args.token = value_87;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_88: string = input.readString();
                        _args.userId = value_88;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.SET) {
                        const value_89: Set<string> = new Set<string>();
                        const metadata_10: thrift.TSet = input.readSetBegin();
                        const size_10: number = metadata_10.size;
                        for (let i_10: number = 0; i_10 < size_10; i_10++) {
                            const value_90: string = input.readString();
                            value_89.add(value_90);
                        }
                        input.readSetEnd();
                        _args.accountIdsToAdd = value_89;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.SET) {
                        const value_91: Set<string> = new Set<string>();
                        const metadata_11: thrift.TSet = input.readSetBegin();
                        const size_11: number = metadata_11.size;
                        for (let i_11: number = 0; i_11 < size_11; i_11++) {
                            const value_92: string = input.readString();
                            value_91.add(value_92);
                        }
                        input.readSetEnd();
                        _args.accountIdsToRemove = value_91;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_93: string = input.readString();
                        _args.accountMainId = value_93;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.userId !== undefined && _args.accountIdsToAdd !== undefined && _args.accountIdsToRemove !== undefined && _args.accountMainId !== undefined) {
            return new ChangeUserAccountsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeUserAccountsArgs from input");
        }
    }
}
export interface IRunSchedulerArgsArgs {
    token: string;
    oName: string;
    wait: boolean;
}
export class RunSchedulerArgs {
    public token: string;
    public oName: string;
    public wait: boolean;
    constructor(args: IRunSchedulerArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.oName != null) {
            this.oName = args.oName;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[oName] is unset!");
        }
        if (args != null && args.wait != null) {
            this.wait = args.wait;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[wait] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RunSchedulerArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.oName != null) {
            output.writeFieldBegin("oName", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.oName);
            output.writeFieldEnd();
        }
        if (this.wait != null) {
            output.writeFieldBegin("wait", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.wait);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RunSchedulerArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_94: string = input.readString();
                        _args.token = value_94;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_95: string = input.readString();
                        _args.oName = value_95;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_96: boolean = input.readBool();
                        _args.wait = value_96;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.oName !== undefined && _args.wait !== undefined) {
            return new RunSchedulerArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RunSchedulerArgs from input");
        }
    }
}
export interface IChangeEncryptKeyArgsArgs {
    token: string;
    key: string;
    accountId: string;
    password: string;
}
export class ChangeEncryptKeyArgs {
    public token: string;
    public key: string;
    public accountId: string;
    public password: string;
    constructor(args: IChangeEncryptKeyArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.key != null) {
            this.key = args.key;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[key] is unset!");
        }
        if (args != null && args.accountId != null) {
            this.accountId = args.accountId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accountId] is unset!");
        }
        if (args != null && args.password != null) {
            this.password = args.password;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[password] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeEncryptKeyArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.key != null) {
            output.writeFieldBegin("key", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.key);
            output.writeFieldEnd();
        }
        if (this.accountId != null) {
            output.writeFieldBegin("accountId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.accountId);
            output.writeFieldEnd();
        }
        if (this.password != null) {
            output.writeFieldBegin("password", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.password);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeEncryptKeyArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_97: string = input.readString();
                        _args.token = value_97;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_98: string = input.readString();
                        _args.key = value_98;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_99: string = input.readString();
                        _args.accountId = value_99;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_100: string = input.readString();
                        _args.password = value_100;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.key !== undefined && _args.accountId !== undefined && _args.password !== undefined) {
            return new ChangeEncryptKeyArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeEncryptKeyArgs from input");
        }
    }
}
export interface IGetAllUsersExtArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetAllUsersExtArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetAllUsersExtArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllUsersExtArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllUsersExtArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_101: string = input.readString();
                        _args.token = value_101;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_102: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_102;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllUsersExtArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllUsersExtArgs from input");
        }
    }
}
export interface IGetCountAllUsersExtArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetCountAllUsersExtArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetCountAllUsersExtArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllUsersExtArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllUsersExtArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_103: string = input.readString();
                        _args.token = value_103;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_104: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_104;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetCountAllUsersExtArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetCountAllUsersExtArgs from input");
        }
    }
}
export interface IGetAllUserNotificationsArgsArgs {
    token: string;
    userId: string;
    unreadOnly: boolean;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetAllUserNotificationsArgs {
    public token: string;
    public userId: string;
    public unreadOnly: boolean;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetAllUserNotificationsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.userId != null) {
            this.userId = args.userId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userId] is unset!");
        }
        if (args != null && args.unreadOnly != null) {
            this.unreadOnly = args.unreadOnly;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[unreadOnly] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllUserNotificationsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.userId != null) {
            output.writeFieldBegin("userId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.userId);
            output.writeFieldEnd();
        }
        if (this.unreadOnly != null) {
            output.writeFieldBegin("unreadOnly", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.unreadOnly);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 4);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllUserNotificationsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_105: string = input.readString();
                        _args.token = value_105;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_106: string = input.readString();
                        _args.userId = value_106;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_107: boolean = input.readBool();
                        _args.unreadOnly = value_107;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_108: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_108;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.userId !== undefined && _args.unreadOnly !== undefined && _args.filter !== undefined) {
            return new GetAllUserNotificationsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllUserNotificationsArgs from input");
        }
    }
}
export interface IGetAllNotificationsArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetAllNotificationsArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetAllNotificationsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllNotificationsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllNotificationsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_109: string = input.readString();
                        _args.token = value_109;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_110: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_110;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllNotificationsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllNotificationsArgs from input");
        }
    }
}
export interface IMoveDocumentOnOtherPatternStageArgsArgs {
    token: string;
    documentId: string;
    stageId: string;
    resetMoveError: boolean;
}
export class MoveDocumentOnOtherPatternStageArgs {
    public token: string;
    public documentId: string;
    public stageId: string;
    public resetMoveError: boolean;
    constructor(args: IMoveDocumentOnOtherPatternStageArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.stageId != null) {
            this.stageId = args.stageId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[stageId] is unset!");
        }
        if (args != null && args.resetMoveError != null) {
            this.resetMoveError = args.resetMoveError;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[resetMoveError] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MoveDocumentOnOtherPatternStageArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.stageId != null) {
            output.writeFieldBegin("stageId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.stageId);
            output.writeFieldEnd();
        }
        if (this.resetMoveError != null) {
            output.writeFieldBegin("resetMoveError", thrift.Thrift.Type.BOOL, 4);
            output.writeBool(this.resetMoveError);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MoveDocumentOnOtherPatternStageArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_111: string = input.readString();
                        _args.token = value_111;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_112: string = input.readString();
                        _args.documentId = value_112;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_113: string = input.readString();
                        _args.stageId = value_113;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_114: boolean = input.readBool();
                        _args.resetMoveError = value_114;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.stageId !== undefined && _args.resetMoveError !== undefined) {
            return new MoveDocumentOnOtherPatternStageArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read MoveDocumentOnOtherPatternStageArgs from input");
        }
    }
}
export interface IResendDocumentToExternalModuleArgsArgs {
    token: string;
    documentId: string;
    accessPolicy: __ROOT_NAMESPACE__.DocumentAccessPolicy;
}
export class ResendDocumentToExternalModuleArgs {
    public token: string;
    public documentId: string;
    public accessPolicy: __ROOT_NAMESPACE__.DocumentAccessPolicy;
    constructor(args: IResendDocumentToExternalModuleArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.accessPolicy != null) {
            this.accessPolicy = args.accessPolicy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accessPolicy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ResendDocumentToExternalModuleArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.accessPolicy != null) {
            output.writeFieldBegin("accessPolicy", thrift.Thrift.Type.STRUCT, 3);
            this.accessPolicy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ResendDocumentToExternalModuleArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_115: string = input.readString();
                        _args.token = value_115;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_116: string = input.readString();
                        _args.documentId = value_116;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_117: __ROOT_NAMESPACE__.DocumentAccessPolicy = __ROOT_NAMESPACE__.DocumentAccessPolicy.read(input);
                        _args.accessPolicy = value_117;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.accessPolicy !== undefined) {
            return new ResendDocumentToExternalModuleArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ResendDocumentToExternalModuleArgs from input");
        }
    }
}
export interface IGetAllSessionsArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetAllSessionsArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetAllSessionsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllSessionsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllSessionsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_118: string = input.readString();
                        _args.token = value_118;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_119: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_119;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllSessionsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllSessionsArgs from input");
        }
    }
}
export interface IGetCountAllSessionsArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetCountAllSessionsArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetCountAllSessionsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllSessionsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllSessionsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_120: string = input.readString();
                        _args.token = value_120;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_121: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_121;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetCountAllSessionsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetCountAllSessionsArgs from input");
        }
    }
}
export interface IConfirmUserPublicKeyArgsArgs {
    token: string;
    id: string;
    confirm: boolean;
}
export class ConfirmUserPublicKeyArgs {
    public token: string;
    public id: string;
    public confirm: boolean;
    constructor(args: IConfirmUserPublicKeyArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.id != null) {
            this.id = args.id;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[id] is unset!");
        }
        if (args != null && args.confirm != null) {
            this.confirm = args.confirm;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[confirm] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ConfirmUserPublicKeyArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.id != null) {
            output.writeFieldBegin("id", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.id);
            output.writeFieldEnd();
        }
        if (this.confirm != null) {
            output.writeFieldBegin("confirm", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.confirm);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ConfirmUserPublicKeyArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_122: string = input.readString();
                        _args.token = value_122;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_123: string = input.readString();
                        _args.id = value_123;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_124: boolean = input.readBool();
                        _args.confirm = value_124;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.id !== undefined && _args.confirm !== undefined) {
            return new ConfirmUserPublicKeyArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ConfirmUserPublicKeyArgs from input");
        }
    }
}
export interface ICloseSessionArgsArgs {
    token: string;
    sessionId: string;
}
export class CloseSessionArgs {
    public token: string;
    public sessionId: string;
    constructor(args: ICloseSessionArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.sessionId != null) {
            this.sessionId = args.sessionId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[sessionId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CloseSessionArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.sessionId != null) {
            output.writeFieldBegin("sessionId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.sessionId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CloseSessionArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_125: string = input.readString();
                        _args.token = value_125;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_126: string = input.readString();
                        _args.sessionId = value_126;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.sessionId !== undefined) {
            return new CloseSessionArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CloseSessionArgs from input");
        }
    }
}
export interface ICopyPersonalAccessArgsArgs {
    token: string;
    copyPersonalAccessSettings: CopyPersonalAccessSettings.CopyPersonalAccessSettings;
}
export class CopyPersonalAccessArgs {
    public token: string;
    public copyPersonalAccessSettings: CopyPersonalAccessSettings.CopyPersonalAccessSettings;
    constructor(args: ICopyPersonalAccessArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.copyPersonalAccessSettings != null) {
            this.copyPersonalAccessSettings = args.copyPersonalAccessSettings;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[copyPersonalAccessSettings] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CopyPersonalAccessArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.copyPersonalAccessSettings != null) {
            output.writeFieldBegin("copyPersonalAccessSettings", thrift.Thrift.Type.STRUCT, 2);
            this.copyPersonalAccessSettings.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CopyPersonalAccessArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_127: string = input.readString();
                        _args.token = value_127;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_128: CopyPersonalAccessSettings.CopyPersonalAccessSettings = CopyPersonalAccessSettings.CopyPersonalAccessSettings.read(input);
                        _args.copyPersonalAccessSettings = value_128;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.copyPersonalAccessSettings !== undefined) {
            return new CopyPersonalAccessArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CopyPersonalAccessArgs from input");
        }
    }
}
export interface IGetAllLicensesArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetAllLicensesArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetAllLicensesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllLicensesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllLicensesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_129: string = input.readString();
                        _args.token = value_129;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_130: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_130;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllLicensesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllLicensesArgs from input");
        }
    }
}
export interface IGetCountAllLicensesArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetCountAllLicensesArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetCountAllLicensesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllLicensesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllLicensesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_131: string = input.readString();
                        _args.token = value_131;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_132: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_132;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetCountAllLicensesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetCountAllLicensesArgs from input");
        }
    }
}
export interface IUploadLicensesArgsArgs {
    token: string;
    fileContentBytes: Buffer;
    accountGroup: __ROOT_NAMESPACE__.AccountGroup;
    account: __ROOT_NAMESPACE__.Account;
    autoAssignment: boolean;
    autoAssignmentOrder: number;
}
export class UploadLicensesArgs {
    public token: string;
    public fileContentBytes: Buffer;
    public accountGroup: __ROOT_NAMESPACE__.AccountGroup;
    public account: __ROOT_NAMESPACE__.Account;
    public autoAssignment: boolean;
    public autoAssignmentOrder: number;
    constructor(args: IUploadLicensesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.fileContentBytes != null) {
            this.fileContentBytes = args.fileContentBytes;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[fileContentBytes] is unset!");
        }
        if (args != null && args.accountGroup != null) {
            this.accountGroup = args.accountGroup;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accountGroup] is unset!");
        }
        if (args != null && args.account != null) {
            this.account = args.account;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[account] is unset!");
        }
        if (args != null && args.autoAssignment != null) {
            this.autoAssignment = args.autoAssignment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[autoAssignment] is unset!");
        }
        if (args != null && args.autoAssignmentOrder != null) {
            this.autoAssignmentOrder = args.autoAssignmentOrder;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[autoAssignmentOrder] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UploadLicensesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.fileContentBytes != null) {
            output.writeFieldBegin("fileContentBytes", thrift.Thrift.Type.STRING, 2);
            output.writeBinary(this.fileContentBytes);
            output.writeFieldEnd();
        }
        if (this.accountGroup != null) {
            output.writeFieldBegin("accountGroup", thrift.Thrift.Type.STRUCT, 3);
            this.accountGroup.write(output);
            output.writeFieldEnd();
        }
        if (this.account != null) {
            output.writeFieldBegin("account", thrift.Thrift.Type.STRUCT, 4);
            this.account.write(output);
            output.writeFieldEnd();
        }
        if (this.autoAssignment != null) {
            output.writeFieldBegin("autoAssignment", thrift.Thrift.Type.BOOL, 5);
            output.writeBool(this.autoAssignment);
            output.writeFieldEnd();
        }
        if (this.autoAssignmentOrder != null) {
            output.writeFieldBegin("autoAssignmentOrder", thrift.Thrift.Type.I32, 6);
            output.writeI32(this.autoAssignmentOrder);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UploadLicensesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_133: string = input.readString();
                        _args.token = value_133;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_134: Buffer = input.readBinary();
                        _args.fileContentBytes = value_134;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_135: __ROOT_NAMESPACE__.AccountGroup = __ROOT_NAMESPACE__.AccountGroup.read(input);
                        _args.accountGroup = value_135;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_136: __ROOT_NAMESPACE__.Account = __ROOT_NAMESPACE__.Account.read(input);
                        _args.account = value_136;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_137: boolean = input.readBool();
                        _args.autoAssignment = value_137;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_138: number = input.readI32();
                        _args.autoAssignmentOrder = value_138;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.fileContentBytes !== undefined && _args.accountGroup !== undefined && _args.account !== undefined && _args.autoAssignment !== undefined && _args.autoAssignmentOrder !== undefined) {
            return new UploadLicensesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UploadLicensesArgs from input");
        }
    }
}
export interface IRemoveLicensesArgsArgs {
    token: string;
    lkeys: Array<string>;
}
export class RemoveLicensesArgs {
    public token: string;
    public lkeys: Array<string>;
    constructor(args: IRemoveLicensesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.lkeys != null) {
            this.lkeys = args.lkeys;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[lkeys] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveLicensesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.lkeys != null) {
            output.writeFieldBegin("lkeys", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.lkeys.length);
            this.lkeys.forEach((value_139: string): void => {
                output.writeString(value_139);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveLicensesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_140: string = input.readString();
                        _args.token = value_140;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_141: Array<string> = new Array<string>();
                        const metadata_12: thrift.TList = input.readListBegin();
                        const size_12: number = metadata_12.size;
                        for (let i_12: number = 0; i_12 < size_12; i_12++) {
                            const value_142: string = input.readString();
                            value_141.push(value_142);
                        }
                        input.readListEnd();
                        _args.lkeys = value_141;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.lkeys !== undefined) {
            return new RemoveLicensesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveLicensesArgs from input");
        }
    }
}
export interface IUpdateLicenseArgsArgs {
    token: string;
    license: License.License;
}
export class UpdateLicenseArgs {
    public token: string;
    public license: License.License;
    constructor(args: IUpdateLicenseArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.license != null) {
            this.license = args.license;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[license] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateLicenseArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.license != null) {
            output.writeFieldBegin("license", thrift.Thrift.Type.STRUCT, 2);
            this.license.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateLicenseArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_143: string = input.readString();
                        _args.token = value_143;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_144: License.License = License.License.read(input);
                        _args.license = value_144;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.license !== undefined) {
            return new UpdateLicenseArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UpdateLicenseArgs from input");
        }
    }
}
export interface IReleaseLicenceArgsArgs {
    token: string;
    userId: string;
    cancelAutoAssignment: boolean;
}
export class ReleaseLicenceArgs {
    public token: string;
    public userId: string;
    public cancelAutoAssignment: boolean;
    constructor(args: IReleaseLicenceArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.userId != null) {
            this.userId = args.userId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userId] is unset!");
        }
        if (args != null && args.cancelAutoAssignment != null) {
            this.cancelAutoAssignment = args.cancelAutoAssignment;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[cancelAutoAssignment] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ReleaseLicenceArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.userId != null) {
            output.writeFieldBegin("userId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.userId);
            output.writeFieldEnd();
        }
        if (this.cancelAutoAssignment != null) {
            output.writeFieldBegin("cancelAutoAssignment", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.cancelAutoAssignment);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ReleaseLicenceArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_145: string = input.readString();
                        _args.token = value_145;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_146: string = input.readString();
                        _args.userId = value_146;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_147: boolean = input.readBool();
                        _args.cancelAutoAssignment = value_147;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.userId !== undefined && _args.cancelAutoAssignment !== undefined) {
            return new ReleaseLicenceArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ReleaseLicenceArgs from input");
        }
    }
}
export interface IGetLicenseModulePageArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetLicenseModulePageArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetLicenseModulePageArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetLicenseModulePageArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetLicenseModulePageArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_148: string = input.readString();
                        _args.token = value_148;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_149: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_149;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetLicenseModulePageArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetLicenseModulePageArgs from input");
        }
    }
}
export interface IUploadLicenseModuleArgsArgs {
    token: string;
    fileContentBytes: Buffer;
}
export class UploadLicenseModuleArgs {
    public token: string;
    public fileContentBytes: Buffer;
    constructor(args: IUploadLicenseModuleArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.fileContentBytes != null) {
            this.fileContentBytes = args.fileContentBytes;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[fileContentBytes] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UploadLicenseModuleArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.fileContentBytes != null) {
            output.writeFieldBegin("fileContentBytes", thrift.Thrift.Type.STRING, 2);
            output.writeBinary(this.fileContentBytes);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UploadLicenseModuleArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_150: string = input.readString();
                        _args.token = value_150;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_151: Buffer = input.readBinary();
                        _args.fileContentBytes = value_151;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.fileContentBytes !== undefined) {
            return new UploadLicenseModuleArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read UploadLicenseModuleArgs from input");
        }
    }
}
export interface IRemoveLicenseModuleArgsArgs {
    token: string;
    id: string;
}
export class RemoveLicenseModuleArgs {
    public token: string;
    public id: string;
    constructor(args: IRemoveLicenseModuleArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.id != null) {
            this.id = args.id;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[id] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveLicenseModuleArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.id != null) {
            output.writeFieldBegin("id", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.id);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveLicenseModuleArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_152: string = input.readString();
                        _args.token = value_152;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_153: string = input.readString();
                        _args.id = value_153;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.id !== undefined) {
            return new RemoveLicenseModuleArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveLicenseModuleArgs from input");
        }
    }
}
export interface ICreateOrUpdateArgsArgs {
    token: string;
    dictionary: CharMatchingDictionary.CharMatchingDictionary;
}
export class CreateOrUpdateArgs {
    public token: string;
    public dictionary: CharMatchingDictionary.CharMatchingDictionary;
    constructor(args: ICreateOrUpdateArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.dictionary != null) {
            this.dictionary = args.dictionary;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[dictionary] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.dictionary != null) {
            output.writeFieldBegin("dictionary", thrift.Thrift.Type.STRUCT, 2);
            this.dictionary.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_154: string = input.readString();
                        _args.token = value_154;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_155: CharMatchingDictionary.CharMatchingDictionary = CharMatchingDictionary.CharMatchingDictionary.read(input);
                        _args.dictionary = value_155;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.dictionary !== undefined) {
            return new CreateOrUpdateArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateOrUpdateArgs from input");
        }
    }
}
export interface IGetAllCharMatchingDictionariesArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetAllCharMatchingDictionariesArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetAllCharMatchingDictionariesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllCharMatchingDictionariesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllCharMatchingDictionariesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_156: string = input.readString();
                        _args.token = value_156;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_157: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_157;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllCharMatchingDictionariesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllCharMatchingDictionariesArgs from input");
        }
    }
}
export interface IDeleteCharMatchingDictionaryArgsArgs {
    token: string;
    dictionary: string;
}
export class DeleteCharMatchingDictionaryArgs {
    public token: string;
    public dictionary: string;
    constructor(args: IDeleteCharMatchingDictionaryArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.dictionary != null) {
            this.dictionary = args.dictionary;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[dictionary] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteCharMatchingDictionaryArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.dictionary != null) {
            output.writeFieldBegin("dictionary", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.dictionary);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteCharMatchingDictionaryArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_158: string = input.readString();
                        _args.token = value_158;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_159: string = input.readString();
                        _args.dictionary = value_159;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.dictionary !== undefined) {
            return new DeleteCharMatchingDictionaryArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteCharMatchingDictionaryArgs from input");
        }
    }
}
export interface IGetTranslationsArgsArgs {
    token: string;
    langCode: string;
}
export class GetTranslationsArgs {
    public token: string;
    public langCode: string;
    constructor(args: IGetTranslationsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.langCode != null) {
            this.langCode = args.langCode;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[langCode] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetTranslationsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.langCode != null) {
            output.writeFieldBegin("langCode", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.langCode);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetTranslationsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_160: string = input.readString();
                        _args.token = value_160;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_161: string = input.readString();
                        _args.langCode = value_161;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.langCode !== undefined) {
            return new GetTranslationsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetTranslationsArgs from input");
        }
    }
}
export interface ISetTranslationsArgsArgs {
    token: string;
    langCode: string;
    langFile: Buffer;
}
export class SetTranslationsArgs {
    public token: string;
    public langCode: string;
    public langFile: Buffer;
    constructor(args: ISetTranslationsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.langCode != null) {
            this.langCode = args.langCode;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[langCode] is unset!");
        }
        if (args != null && args.langFile != null) {
            this.langFile = args.langFile;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[langFile] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetTranslationsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.langCode != null) {
            output.writeFieldBegin("langCode", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.langCode);
            output.writeFieldEnd();
        }
        if (this.langFile != null) {
            output.writeFieldBegin("langFile", thrift.Thrift.Type.STRING, 3);
            output.writeBinary(this.langFile);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetTranslationsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_162: string = input.readString();
                        _args.token = value_162;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_163: string = input.readString();
                        _args.langCode = value_163;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_164: Buffer = input.readBinary();
                        _args.langFile = value_164;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.langCode !== undefined && _args.langFile !== undefined) {
            return new SetTranslationsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read SetTranslationsArgs from input");
        }
    }
}
export interface IGetDroolLogFileArgsArgs {
    token: string;
    docId: string;
    policy: __ROOT_NAMESPACE__.DocumentAccessPolicy;
}
export class GetDroolLogFileArgs {
    public token: string;
    public docId: string;
    public policy: __ROOT_NAMESPACE__.DocumentAccessPolicy;
    constructor(args: IGetDroolLogFileArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.docId != null) {
            this.docId = args.docId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[docId] is unset!");
        }
        if (args != null && args.policy != null) {
            this.policy = args.policy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[policy] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDroolLogFileArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.docId != null) {
            output.writeFieldBegin("docId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.docId);
            output.writeFieldEnd();
        }
        if (this.policy != null) {
            output.writeFieldBegin("policy", thrift.Thrift.Type.STRUCT, 3);
            this.policy.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDroolLogFileArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_165: string = input.readString();
                        _args.token = value_165;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_166: string = input.readString();
                        _args.docId = value_166;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_167: __ROOT_NAMESPACE__.DocumentAccessPolicy = __ROOT_NAMESPACE__.DocumentAccessPolicy.read(input);
                        _args.policy = value_167;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.docId !== undefined && _args.policy !== undefined) {
            return new GetDroolLogFileArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetDroolLogFileArgs from input");
        }
    }
}
export interface ICryptValueArgsArgs {
    token: string;
    value: string;
}
export class CryptValueArgs {
    public token: string;
    public value: string;
    constructor(args: ICryptValueArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.value != null) {
            this.value = args.value;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[value] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CryptValueArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.value != null) {
            output.writeFieldBegin("value", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.value);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CryptValueArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_168: string = input.readString();
                        _args.token = value_168;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_169: string = input.readString();
                        _args.value = value_169;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.value !== undefined) {
            return new CryptValueArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CryptValueArgs from input");
        }
    }
}
export interface IGetAllJobTasksArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetAllJobTasksArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetAllJobTasksArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllJobTasksArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllJobTasksArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_170: string = input.readString();
                        _args.token = value_170;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_171: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_171;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllJobTasksArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllJobTasksArgs from input");
        }
    }
}
export interface IGetCountAllJobTasksArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetCountAllJobTasksArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetCountAllJobTasksArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllJobTasksArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllJobTasksArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_172: string = input.readString();
                        _args.token = value_172;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_173: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_173;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetCountAllJobTasksArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetCountAllJobTasksArgs from input");
        }
    }
}
export interface IDeleteJobTaskArgsArgs {
    token: string;
    jobTaskId: string;
}
export class DeleteJobTaskArgs {
    public token: string;
    public jobTaskId: string;
    constructor(args: IDeleteJobTaskArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.jobTaskId != null) {
            this.jobTaskId = args.jobTaskId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[jobTaskId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteJobTaskArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.jobTaskId != null) {
            output.writeFieldBegin("jobTaskId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.jobTaskId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteJobTaskArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_174: string = input.readString();
                        _args.token = value_174;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_175: string = input.readString();
                        _args.jobTaskId = value_175;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.jobTaskId !== undefined) {
            return new DeleteJobTaskArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read DeleteJobTaskArgs from input");
        }
    }
}
export interface IRebuildAttachmentArgsArgs {
    token: string;
    attachmentId: string;
}
export class RebuildAttachmentArgs {
    public token: string;
    public attachmentId: string;
    constructor(args: IRebuildAttachmentArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.attachmentId != null) {
            this.attachmentId = args.attachmentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[attachmentId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RebuildAttachmentArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.attachmentId != null) {
            output.writeFieldBegin("attachmentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.attachmentId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RebuildAttachmentArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_176: string = input.readString();
                        _args.token = value_176;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_177: string = input.readString();
                        _args.attachmentId = value_177;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.attachmentId !== undefined) {
            return new RebuildAttachmentArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RebuildAttachmentArgs from input");
        }
    }
}
export interface IGetAllUserContentItemsArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetAllUserContentItemsArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetAllUserContentItemsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllUserContentItemsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllUserContentItemsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_178: string = input.readString();
                        _args.token = value_178;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_179: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_179;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllUserContentItemsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllUserContentItemsArgs from input");
        }
    }
}
export interface IChangeUserContentItemsArgsArgs {
    token: string;
    contentItems: Array<__ROOT_NAMESPACE__.ContentItem>;
}
export class ChangeUserContentItemsArgs {
    public token: string;
    public contentItems: Array<__ROOT_NAMESPACE__.ContentItem>;
    constructor(args: IChangeUserContentItemsArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.contentItems != null) {
            this.contentItems = args.contentItems;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[contentItems] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeUserContentItemsArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.contentItems != null) {
            output.writeFieldBegin("contentItems", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.contentItems.length);
            this.contentItems.forEach((value_180: __ROOT_NAMESPACE__.ContentItem): void => {
                value_180.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeUserContentItemsArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_181: string = input.readString();
                        _args.token = value_181;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_182: Array<__ROOT_NAMESPACE__.ContentItem> = new Array<__ROOT_NAMESPACE__.ContentItem>();
                        const metadata_13: thrift.TList = input.readListBegin();
                        const size_13: number = metadata_13.size;
                        for (let i_13: number = 0; i_13 < size_13; i_13++) {
                            const value_183: __ROOT_NAMESPACE__.ContentItem = __ROOT_NAMESPACE__.ContentItem.read(input);
                            value_182.push(value_183);
                        }
                        input.readListEnd();
                        _args.contentItems = value_182;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.contentItems !== undefined) {
            return new ChangeUserContentItemsArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeUserContentItemsArgs from input");
        }
    }
}
export interface IGetAllUserContentHoldersArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
}
export class GetAllUserContentHoldersArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    constructor(args: IGetAllUserContentHoldersArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllUserContentHoldersArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllUserContentHoldersArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_184: string = input.readString();
                        _args.token = value_184;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_185: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_185;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined) {
            return new GetAllUserContentHoldersArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllUserContentHoldersArgs from input");
        }
    }
}
export interface IChangeUserContentHoldersArgsArgs {
    token: string;
    toUpdate: Array<__ROOT_NAMESPACE__.ContentHolder>;
    toRemoveIds: Array<string>;
}
export class ChangeUserContentHoldersArgs {
    public token: string;
    public toUpdate: Array<__ROOT_NAMESPACE__.ContentHolder>;
    public toRemoveIds: Array<string>;
    constructor(args: IChangeUserContentHoldersArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.toUpdate != null) {
            this.toUpdate = args.toUpdate;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toUpdate] is unset!");
        }
        if (args != null && args.toRemoveIds != null) {
            this.toRemoveIds = args.toRemoveIds;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[toRemoveIds] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeUserContentHoldersArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.toUpdate != null) {
            output.writeFieldBegin("toUpdate", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.toUpdate.length);
            this.toUpdate.forEach((value_186: __ROOT_NAMESPACE__.ContentHolder): void => {
                value_186.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.toRemoveIds != null) {
            output.writeFieldBegin("toRemoveIds", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.toRemoveIds.length);
            this.toRemoveIds.forEach((value_187: string): void => {
                output.writeString(value_187);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeUserContentHoldersArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_188: string = input.readString();
                        _args.token = value_188;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_189: Array<__ROOT_NAMESPACE__.ContentHolder> = new Array<__ROOT_NAMESPACE__.ContentHolder>();
                        const metadata_14: thrift.TList = input.readListBegin();
                        const size_14: number = metadata_14.size;
                        for (let i_14: number = 0; i_14 < size_14; i_14++) {
                            const value_190: __ROOT_NAMESPACE__.ContentHolder = __ROOT_NAMESPACE__.ContentHolder.read(input);
                            value_189.push(value_190);
                        }
                        input.readListEnd();
                        _args.toUpdate = value_189;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_191: Array<string> = new Array<string>();
                        const metadata_15: thrift.TList = input.readListBegin();
                        const size_15: number = metadata_15.size;
                        for (let i_15: number = 0; i_15 < size_15; i_15++) {
                            const value_192: string = input.readString();
                            value_191.push(value_192);
                        }
                        input.readListEnd();
                        _args.toRemoveIds = value_191;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.toUpdate !== undefined && _args.toRemoveIds !== undefined) {
            return new ChangeUserContentHoldersArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ChangeUserContentHoldersArgs from input");
        }
    }
}
export interface IRemoveLicensesExArgsArgs {
    token: string;
    accountGroupId: string;
    accountId: string;
    dateFrom: number | Int64;
    dateTo: number | Int64;
}
export class RemoveLicensesExArgs {
    public token: string;
    public accountGroupId: string;
    public accountId: string;
    public dateFrom: Int64;
    public dateTo: Int64;
    constructor(args: IRemoveLicensesExArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.accountGroupId != null) {
            this.accountGroupId = args.accountGroupId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accountGroupId] is unset!");
        }
        if (args != null && args.accountId != null) {
            this.accountId = args.accountId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accountId] is unset!");
        }
        if (args != null && args.dateFrom != null) {
            if (typeof args.dateFrom === "number") {
                this.dateFrom = new Int64(args.dateFrom);
            }
            else {
                this.dateFrom = args.dateFrom;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[dateFrom] is unset!");
        }
        if (args != null && args.dateTo != null) {
            if (typeof args.dateTo === "number") {
                this.dateTo = new Int64(args.dateTo);
            }
            else {
                this.dateTo = args.dateTo;
            }
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[dateTo] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveLicensesExArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.accountGroupId != null) {
            output.writeFieldBegin("accountGroupId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.accountGroupId);
            output.writeFieldEnd();
        }
        if (this.accountId != null) {
            output.writeFieldBegin("accountId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.accountId);
            output.writeFieldEnd();
        }
        if (this.dateFrom != null) {
            output.writeFieldBegin("dateFrom", thrift.Thrift.Type.I64, 4);
            output.writeI64(this.dateFrom);
            output.writeFieldEnd();
        }
        if (this.dateTo != null) {
            output.writeFieldBegin("dateTo", thrift.Thrift.Type.I64, 5);
            output.writeI64(this.dateTo);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveLicensesExArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_193: string = input.readString();
                        _args.token = value_193;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_194: string = input.readString();
                        _args.accountGroupId = value_194;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_195: string = input.readString();
                        _args.accountId = value_195;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_196: Int64 = input.readI64();
                        _args.dateFrom = value_196;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.I64) {
                        const value_197: Int64 = input.readI64();
                        _args.dateTo = value_197;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.accountGroupId !== undefined && _args.accountId !== undefined && _args.dateFrom !== undefined && _args.dateTo !== undefined) {
            return new RemoveLicensesExArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveLicensesExArgs from input");
        }
    }
}
export interface IGetLicenseForUserArgsArgs {
    token: string;
    userId: string;
}
export class GetLicenseForUserArgs {
    public token: string;
    public userId: string;
    constructor(args: IGetLicenseForUserArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.userId != null) {
            this.userId = args.userId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetLicenseForUserArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.userId != null) {
            output.writeFieldBegin("userId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.userId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetLicenseForUserArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_198: string = input.readString();
                        _args.token = value_198;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_199: string = input.readString();
                        _args.userId = value_199;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.userId !== undefined) {
            return new GetLicenseForUserArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetLicenseForUserArgs from input");
        }
    }
}
export interface IGetAllowedRolesForLicenseArgsArgs {
    token: string;
    licenseKey: string;
}
export class GetAllowedRolesForLicenseArgs {
    public token: string;
    public licenseKey: string;
    constructor(args: IGetAllowedRolesForLicenseArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.licenseKey != null) {
            this.licenseKey = args.licenseKey;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[licenseKey] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllowedRolesForLicenseArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.licenseKey != null) {
            output.writeFieldBegin("licenseKey", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.licenseKey);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllowedRolesForLicenseArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_200: string = input.readString();
                        _args.token = value_200;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_201: string = input.readString();
                        _args.licenseKey = value_201;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.licenseKey !== undefined) {
            return new GetAllowedRolesForLicenseArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllowedRolesForLicenseArgs from input");
        }
    }
}
export interface IAssignLicenseToUserArgsArgs {
    token: string;
    licenseKey: string;
    userId: string;
}
export class AssignLicenseToUserArgs {
    public token: string;
    public licenseKey: string;
    public userId: string;
    constructor(args: IAssignLicenseToUserArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.licenseKey != null) {
            this.licenseKey = args.licenseKey;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[licenseKey] is unset!");
        }
        if (args != null && args.userId != null) {
            this.userId = args.userId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AssignLicenseToUserArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.licenseKey != null) {
            output.writeFieldBegin("licenseKey", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.licenseKey);
            output.writeFieldEnd();
        }
        if (this.userId != null) {
            output.writeFieldBegin("userId", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.userId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AssignLicenseToUserArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_202: string = input.readString();
                        _args.token = value_202;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_203: string = input.readString();
                        _args.licenseKey = value_203;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_204: string = input.readString();
                        _args.userId = value_204;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.licenseKey !== undefined && _args.userId !== undefined) {
            return new AssignLicenseToUserArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AssignLicenseToUserArgs from input");
        }
    }
}
export interface IExecuteCustomQueryArgsArgs {
    token: string;
    query: string;
}
export class ExecuteCustomQueryArgs {
    public token: string;
    public query: string;
    constructor(args: IExecuteCustomQueryArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.query != null) {
            this.query = args.query;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[query] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteCustomQueryArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.query != null) {
            output.writeFieldBegin("query", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.query);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteCustomQueryArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_205: string = input.readString();
                        _args.token = value_205;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_206: string = input.readString();
                        _args.query = value_206;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.query !== undefined) {
            return new ExecuteCustomQueryArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ExecuteCustomQueryArgs from input");
        }
    }
}
export interface ICreateOrUpdateUsersArgsArgs {
    token: string;
    users: Array<__ROOT_NAMESPACE__.UserOrGroup>;
    options: UserOptions.UserOptions;
}
export class CreateOrUpdateUsersArgs {
    public token: string;
    public users: Array<__ROOT_NAMESPACE__.UserOrGroup>;
    public options: UserOptions.UserOptions;
    constructor(args: ICreateOrUpdateUsersArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.users != null) {
            this.users = args.users;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[users] is unset!");
        }
        if (args != null && args.options != null) {
            this.options = args.options;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[options] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateUsersArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.users != null) {
            output.writeFieldBegin("users", thrift.Thrift.Type.LIST, 2);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.users.length);
            this.users.forEach((value_207: __ROOT_NAMESPACE__.UserOrGroup): void => {
                value_207.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.options != null) {
            output.writeFieldBegin("options", thrift.Thrift.Type.STRUCT, 3);
            this.options.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateUsersArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_208: string = input.readString();
                        _args.token = value_208;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_209: Array<__ROOT_NAMESPACE__.UserOrGroup> = new Array<__ROOT_NAMESPACE__.UserOrGroup>();
                        const metadata_16: thrift.TList = input.readListBegin();
                        const size_16: number = metadata_16.size;
                        for (let i_16: number = 0; i_16 < size_16; i_16++) {
                            const value_210: __ROOT_NAMESPACE__.UserOrGroup = __ROOT_NAMESPACE__.UserOrGroup.read(input);
                            value_209.push(value_210);
                        }
                        input.readListEnd();
                        _args.users = value_209;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_211: UserOptions.UserOptions = UserOptions.UserOptions.read(input);
                        _args.options = value_211;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.users !== undefined && _args.options !== undefined) {
            return new CreateOrUpdateUsersArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateOrUpdateUsersArgs from input");
        }
    }
}
export interface IGetAvailableFileStorageListResultArgs {
    success?: Array<__ROOT_NAMESPACE__.AvailableFileStorage>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAvailableFileStorageListResult {
    public success?: Array<__ROOT_NAMESPACE__.AvailableFileStorage>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAvailableFileStorageListResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAvailableFileStorageListResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_212: __ROOT_NAMESPACE__.AvailableFileStorage): void => {
                value_212.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAvailableFileStorageListResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_213: Array<__ROOT_NAMESPACE__.AvailableFileStorage> = new Array<__ROOT_NAMESPACE__.AvailableFileStorage>();
                        const metadata_17: thrift.TList = input.readListBegin();
                        const size_17: number = metadata_17.size;
                        for (let i_17: number = 0; i_17 < size_17; i_17++) {
                            const value_214: __ROOT_NAMESPACE__.AvailableFileStorage = __ROOT_NAMESPACE__.AvailableFileStorage.read(input);
                            value_213.push(value_214);
                        }
                        input.readListEnd();
                        _args.success = value_213;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_215: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_215;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_216: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_216;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAvailableFileStorageListResult(_args);
    }
}
export interface ICreateOrUpdateFileStorageResultArgs {
    success?: __ROOT_NAMESPACE__.FileStorage;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class CreateOrUpdateFileStorageResult {
    public success?: __ROOT_NAMESPACE__.FileStorage;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: ICreateOrUpdateFileStorageResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateFileStorageResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateFileStorageResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_217: __ROOT_NAMESPACE__.FileStorage = __ROOT_NAMESPACE__.FileStorage.read(input);
                        _args.success = value_217;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_218: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_218;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_219: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_219;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateOrUpdateFileStorageResult(_args);
    }
}
export interface IGetAllFileStoragesResultArgs {
    success?: Array<__ROOT_NAMESPACE__.FileStorage>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllFileStoragesResult {
    public success?: Array<__ROOT_NAMESPACE__.FileStorage>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllFileStoragesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllFileStoragesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_220: __ROOT_NAMESPACE__.FileStorage): void => {
                value_220.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllFileStoragesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_221: Array<__ROOT_NAMESPACE__.FileStorage> = new Array<__ROOT_NAMESPACE__.FileStorage>();
                        const metadata_18: thrift.TList = input.readListBegin();
                        const size_18: number = metadata_18.size;
                        for (let i_18: number = 0; i_18 < size_18; i_18++) {
                            const value_222: __ROOT_NAMESPACE__.FileStorage = __ROOT_NAMESPACE__.FileStorage.read(input);
                            value_221.push(value_222);
                        }
                        input.readListEnd();
                        _args.success = value_221;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_223: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_223;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_224: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_224;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllFileStoragesResult(_args);
    }
}
export interface IGetCountAllFileStoragesResultArgs {
    success?: number;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetCountAllFileStoragesResult {
    public success?: number;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetCountAllFileStoragesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllFileStoragesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
            output.writeI32(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllFileStoragesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_225: number = input.readI32();
                        _args.success = value_225;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_226: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_226;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_227: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_227;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetCountAllFileStoragesResult(_args);
    }
}
export interface IRemoveFileStoragesResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class RemoveFileStoragesResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IRemoveFileStoragesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveFileStoragesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveFileStoragesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_228: boolean = input.readBool();
                        _args.success = value_228;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_229: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_229;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_230: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_230;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveFileStoragesResult(_args);
    }
}
export interface IMoveAttachmentResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class MoveAttachmentResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IMoveAttachmentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MoveAttachmentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MoveAttachmentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_231: boolean = input.readBool();
                        _args.success = value_231;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_232: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_232;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_233: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_233;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new MoveAttachmentResult(_args);
    }
}
export interface ICreateOrUpdateNewsResultArgs {
    success?: __ROOT_NAMESPACE__.News;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class CreateOrUpdateNewsResult {
    public success?: __ROOT_NAMESPACE__.News;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: ICreateOrUpdateNewsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateNewsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateNewsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_234: __ROOT_NAMESPACE__.News = __ROOT_NAMESPACE__.News.read(input);
                        _args.success = value_234;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_235: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_235;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_236: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_236;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateOrUpdateNewsResult(_args);
    }
}
export interface IRemoveNewsResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class RemoveNewsResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IRemoveNewsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveNewsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveNewsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_237: boolean = input.readBool();
                        _args.success = value_237;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_238: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_238;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_239: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_239;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveNewsResult(_args);
    }
}
export interface IGetAllExternalModulesResultArgs {
    success?: Array<ExternalModule.ExternalModule>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllExternalModulesResult {
    public success?: Array<ExternalModule.ExternalModule>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllExternalModulesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllExternalModulesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_240: ExternalModule.ExternalModule): void => {
                value_240.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllExternalModulesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_241: Array<ExternalModule.ExternalModule> = new Array<ExternalModule.ExternalModule>();
                        const metadata_19: thrift.TList = input.readListBegin();
                        const size_19: number = metadata_19.size;
                        for (let i_19: number = 0; i_19 < size_19; i_19++) {
                            const value_242: ExternalModule.ExternalModule = ExternalModule.ExternalModule.read(input);
                            value_241.push(value_242);
                        }
                        input.readListEnd();
                        _args.success = value_241;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_243: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_243;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_244: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_244;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllExternalModulesResult(_args);
    }
}
export interface IGetCountAllExternalModulesResultArgs {
    success?: number;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetCountAllExternalModulesResult {
    public success?: number;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetCountAllExternalModulesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllExternalModulesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
            output.writeI32(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllExternalModulesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_245: number = input.readI32();
                        _args.success = value_245;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_246: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_246;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_247: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_247;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetCountAllExternalModulesResult(_args);
    }
}
export interface ICreateOrUpdateExternalModuleResultArgs {
    success?: ExternalModule.ExternalModule;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class CreateOrUpdateExternalModuleResult {
    public success?: ExternalModule.ExternalModule;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: ICreateOrUpdateExternalModuleResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateExternalModuleResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateExternalModuleResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_248: ExternalModule.ExternalModule = ExternalModule.ExternalModule.read(input);
                        _args.success = value_248;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_249: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_249;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_250: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_250;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateOrUpdateExternalModuleResult(_args);
    }
}
export interface IRefreshExternalModuleResultArgs {
    success?: ExternalModule.ExternalModule;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class RefreshExternalModuleResult {
    public success?: ExternalModule.ExternalModule;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IRefreshExternalModuleResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RefreshExternalModuleResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RefreshExternalModuleResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_251: ExternalModule.ExternalModule = ExternalModule.ExternalModule.read(input);
                        _args.success = value_251;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_252: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_252;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_253: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_253;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RefreshExternalModuleResult(_args);
    }
}
export interface IRemoveExternalModuleResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class RemoveExternalModuleResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IRemoveExternalModuleResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveExternalModuleResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveExternalModuleResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_254: boolean = input.readBool();
                        _args.success = value_254;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_255: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_255;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_256: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_256;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveExternalModuleResult(_args);
    }
}
export interface IPingExternalModuleResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class PingExternalModuleResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IPingExternalModuleResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PingExternalModuleResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PingExternalModuleResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_257: boolean = input.readBool();
                        _args.success = value_257;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_258: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_258;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_259: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_259;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new PingExternalModuleResult(_args);
    }
}
export interface IPongExternalModuleResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class PongExternalModuleResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IPongExternalModuleResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("PongExternalModuleResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): PongExternalModuleResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_260: boolean = input.readBool();
                        _args.success = value_260;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_261: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_261;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_262: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_262;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new PongExternalModuleResult(_args);
    }
}
export interface IGetAllDocumentAttachmentsResultArgs {
    success?: Array<__ROOT_NAMESPACE__.Attachment>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllDocumentAttachmentsResult {
    public success?: Array<__ROOT_NAMESPACE__.Attachment>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllDocumentAttachmentsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllDocumentAttachmentsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_263: __ROOT_NAMESPACE__.Attachment): void => {
                value_263.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllDocumentAttachmentsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_264: Array<__ROOT_NAMESPACE__.Attachment> = new Array<__ROOT_NAMESPACE__.Attachment>();
                        const metadata_20: thrift.TList = input.readListBegin();
                        const size_20: number = metadata_20.size;
                        for (let i_20: number = 0; i_20 < size_20; i_20++) {
                            const value_265: __ROOT_NAMESPACE__.Attachment = __ROOT_NAMESPACE__.Attachment.read(input);
                            value_264.push(value_265);
                        }
                        input.readListEnd();
                        _args.success = value_264;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_266: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_266;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_267: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_267;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllDocumentAttachmentsResult(_args);
    }
}
export interface IGetAllFilledDocumentPatternStagesResultArgs {
    success?: Array<__ROOT_NAMESPACE__.DocumentPatternStage>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllFilledDocumentPatternStagesResult {
    public success?: Array<__ROOT_NAMESPACE__.DocumentPatternStage>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllFilledDocumentPatternStagesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllFilledDocumentPatternStagesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_268: __ROOT_NAMESPACE__.DocumentPatternStage): void => {
                value_268.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllFilledDocumentPatternStagesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_269: Array<__ROOT_NAMESPACE__.DocumentPatternStage> = new Array<__ROOT_NAMESPACE__.DocumentPatternStage>();
                        const metadata_21: thrift.TList = input.readListBegin();
                        const size_21: number = metadata_21.size;
                        for (let i_21: number = 0; i_21 < size_21; i_21++) {
                            const value_270: __ROOT_NAMESPACE__.DocumentPatternStage = __ROOT_NAMESPACE__.DocumentPatternStage.read(input);
                            value_269.push(value_270);
                        }
                        input.readListEnd();
                        _args.success = value_269;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_271: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_271;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_272: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_272;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllFilledDocumentPatternStagesResult(_args);
    }
}
export interface IResetDocumentForceMoveErrorResultArgs {
    success?: number;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class ResetDocumentForceMoveErrorResult {
    public success?: number;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IResetDocumentForceMoveErrorResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ResetDocumentForceMoveErrorResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
            output.writeI32(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ResetDocumentForceMoveErrorResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_273: number = input.readI32();
                        _args.success = value_273;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_274: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_274;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_275: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_275;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ResetDocumentForceMoveErrorResult(_args);
    }
}
export interface IChangeExecutorForPatternStagesResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class ChangeExecutorForPatternStagesResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IChangeExecutorForPatternStagesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeExecutorForPatternStagesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeExecutorForPatternStagesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_276: boolean = input.readBool();
                        _args.success = value_276;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_277: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_277;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_278: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_278;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeExecutorForPatternStagesResult(_args);
    }
}
export interface ISetUserPublicKeyResultArgs {
    success?: string;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class SetUserPublicKeyResult {
    public success?: string;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: ISetUserPublicKeyResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetUserPublicKeyResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetUserPublicKeyResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_279: string = input.readString();
                        _args.success = value_279;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_280: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_280;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_281: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_281;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetUserPublicKeyResult(_args);
    }
}
export interface IRemoveUserPublicKeyResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class RemoveUserPublicKeyResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IRemoveUserPublicKeyResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveUserPublicKeyResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveUserPublicKeyResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_282: boolean = input.readBool();
                        _args.success = value_282;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_283: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_283;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_284: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_284;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveUserPublicKeyResult(_args);
    }
}
export interface IGetAllUsersRelativeToAccountResultArgs {
    success?: Array<UserAcc.UserAcc>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllUsersRelativeToAccountResult {
    public success?: Array<UserAcc.UserAcc>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllUsersRelativeToAccountResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllUsersRelativeToAccountResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_285: UserAcc.UserAcc): void => {
                value_285.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllUsersRelativeToAccountResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_286: Array<UserAcc.UserAcc> = new Array<UserAcc.UserAcc>();
                        const metadata_22: thrift.TList = input.readListBegin();
                        const size_22: number = metadata_22.size;
                        for (let i_22: number = 0; i_22 < size_22; i_22++) {
                            const value_287: UserAcc.UserAcc = UserAcc.UserAcc.read(input);
                            value_286.push(value_287);
                        }
                        input.readListEnd();
                        _args.success = value_286;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_288: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_288;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_289: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_289;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllUsersRelativeToAccountResult(_args);
    }
}
export interface IGetCountAllUsersRelativeToAccountResultArgs {
    success?: number;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetCountAllUsersRelativeToAccountResult {
    public success?: number;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetCountAllUsersRelativeToAccountResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllUsersRelativeToAccountResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
            output.writeI32(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllUsersRelativeToAccountResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_290: number = input.readI32();
                        _args.success = value_290;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_291: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_291;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_292: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_292;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetCountAllUsersRelativeToAccountResult(_args);
    }
}
export interface IChangeUserAccountsResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class ChangeUserAccountsResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IChangeUserAccountsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeUserAccountsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeUserAccountsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_293: boolean = input.readBool();
                        _args.success = value_293;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_294: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_294;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_295: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_295;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeUserAccountsResult(_args);
    }
}
export interface IRunSchedulerResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class RunSchedulerResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IRunSchedulerResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RunSchedulerResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RunSchedulerResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_296: boolean = input.readBool();
                        _args.success = value_296;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_297: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_297;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_298: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_298;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RunSchedulerResult(_args);
    }
}
export interface IChangeEncryptKeyResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class ChangeEncryptKeyResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IChangeEncryptKeyResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeEncryptKeyResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeEncryptKeyResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_299: boolean = input.readBool();
                        _args.success = value_299;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_300: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_300;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_301: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_301;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeEncryptKeyResult(_args);
    }
}
export interface IGetAllUsersExtResultArgs {
    success?: Array<UserExt.UserExt>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllUsersExtResult {
    public success?: Array<UserExt.UserExt>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllUsersExtResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllUsersExtResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_302: UserExt.UserExt): void => {
                value_302.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllUsersExtResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_303: Array<UserExt.UserExt> = new Array<UserExt.UserExt>();
                        const metadata_23: thrift.TList = input.readListBegin();
                        const size_23: number = metadata_23.size;
                        for (let i_23: number = 0; i_23 < size_23; i_23++) {
                            const value_304: UserExt.UserExt = UserExt.UserExt.read(input);
                            value_303.push(value_304);
                        }
                        input.readListEnd();
                        _args.success = value_303;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_305: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_305;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_306: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_306;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllUsersExtResult(_args);
    }
}
export interface IGetCountAllUsersExtResultArgs {
    success?: number;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetCountAllUsersExtResult {
    public success?: number;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetCountAllUsersExtResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllUsersExtResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
            output.writeI32(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllUsersExtResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_307: number = input.readI32();
                        _args.success = value_307;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_308: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_308;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_309: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_309;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetCountAllUsersExtResult(_args);
    }
}
export interface IGetAllUserNotificationsResultArgs {
    success?: Array<__ROOT_NAMESPACE__.NotificationQueue>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllUserNotificationsResult {
    public success?: Array<__ROOT_NAMESPACE__.NotificationQueue>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllUserNotificationsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllUserNotificationsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_310: __ROOT_NAMESPACE__.NotificationQueue): void => {
                value_310.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllUserNotificationsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_311: Array<__ROOT_NAMESPACE__.NotificationQueue> = new Array<__ROOT_NAMESPACE__.NotificationQueue>();
                        const metadata_24: thrift.TList = input.readListBegin();
                        const size_24: number = metadata_24.size;
                        for (let i_24: number = 0; i_24 < size_24; i_24++) {
                            const value_312: __ROOT_NAMESPACE__.NotificationQueue = __ROOT_NAMESPACE__.NotificationQueue.read(input);
                            value_311.push(value_312);
                        }
                        input.readListEnd();
                        _args.success = value_311;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_313: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_313;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_314: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_314;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllUserNotificationsResult(_args);
    }
}
export interface IGetAllNotificationsResultArgs {
    success?: Array<__ROOT_NAMESPACE__.NotificationQueue>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllNotificationsResult {
    public success?: Array<__ROOT_NAMESPACE__.NotificationQueue>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllNotificationsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllNotificationsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_315: __ROOT_NAMESPACE__.NotificationQueue): void => {
                value_315.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllNotificationsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_316: Array<__ROOT_NAMESPACE__.NotificationQueue> = new Array<__ROOT_NAMESPACE__.NotificationQueue>();
                        const metadata_25: thrift.TList = input.readListBegin();
                        const size_25: number = metadata_25.size;
                        for (let i_25: number = 0; i_25 < size_25; i_25++) {
                            const value_317: __ROOT_NAMESPACE__.NotificationQueue = __ROOT_NAMESPACE__.NotificationQueue.read(input);
                            value_316.push(value_317);
                        }
                        input.readListEnd();
                        _args.success = value_316;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_318: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_318;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_319: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_319;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllNotificationsResult(_args);
    }
}
export interface IMoveDocumentOnOtherPatternStageResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class MoveDocumentOnOtherPatternStageResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IMoveDocumentOnOtherPatternStageResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("MoveDocumentOnOtherPatternStageResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): MoveDocumentOnOtherPatternStageResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_320: boolean = input.readBool();
                        _args.success = value_320;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_321: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_321;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_322: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_322;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new MoveDocumentOnOtherPatternStageResult(_args);
    }
}
export interface IResendDocumentToExternalModuleResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class ResendDocumentToExternalModuleResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IResendDocumentToExternalModuleResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ResendDocumentToExternalModuleResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ResendDocumentToExternalModuleResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_323: boolean = input.readBool();
                        _args.success = value_323;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_324: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_324;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_325: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_325;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ResendDocumentToExternalModuleResult(_args);
    }
}
export interface IGetAllSessionsResultArgs {
    success?: Array<__ROOT_NAMESPACE__.AuthSession>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllSessionsResult {
    public success?: Array<__ROOT_NAMESPACE__.AuthSession>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllSessionsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllSessionsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_326: __ROOT_NAMESPACE__.AuthSession): void => {
                value_326.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllSessionsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_327: Array<__ROOT_NAMESPACE__.AuthSession> = new Array<__ROOT_NAMESPACE__.AuthSession>();
                        const metadata_26: thrift.TList = input.readListBegin();
                        const size_26: number = metadata_26.size;
                        for (let i_26: number = 0; i_26 < size_26; i_26++) {
                            const value_328: __ROOT_NAMESPACE__.AuthSession = __ROOT_NAMESPACE__.AuthSession.read(input);
                            value_327.push(value_328);
                        }
                        input.readListEnd();
                        _args.success = value_327;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_329: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_329;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_330: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_330;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllSessionsResult(_args);
    }
}
export interface IGetCountAllSessionsResultArgs {
    success?: number;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetCountAllSessionsResult {
    public success?: number;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetCountAllSessionsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllSessionsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
            output.writeI32(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllSessionsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_331: number = input.readI32();
                        _args.success = value_331;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_332: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_332;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_333: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_333;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetCountAllSessionsResult(_args);
    }
}
export interface IConfirmUserPublicKeyResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class ConfirmUserPublicKeyResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IConfirmUserPublicKeyResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ConfirmUserPublicKeyResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ConfirmUserPublicKeyResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_334: boolean = input.readBool();
                        _args.success = value_334;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_335: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_335;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_336: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_336;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ConfirmUserPublicKeyResult(_args);
    }
}
export interface ICloseSessionResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class CloseSessionResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: ICloseSessionResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CloseSessionResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CloseSessionResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_337: boolean = input.readBool();
                        _args.success = value_337;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_338: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_338;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_339: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_339;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CloseSessionResult(_args);
    }
}
export interface ICopyPersonalAccessResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class CopyPersonalAccessResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: ICopyPersonalAccessResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CopyPersonalAccessResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CopyPersonalAccessResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_340: boolean = input.readBool();
                        _args.success = value_340;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_341: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_341;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_342: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_342;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CopyPersonalAccessResult(_args);
    }
}
export interface IGetAllLicensesResultArgs {
    success?: Array<License.License>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllLicensesResult {
    public success?: Array<License.License>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllLicensesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllLicensesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_343: License.License): void => {
                value_343.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllLicensesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_344: Array<License.License> = new Array<License.License>();
                        const metadata_27: thrift.TList = input.readListBegin();
                        const size_27: number = metadata_27.size;
                        for (let i_27: number = 0; i_27 < size_27; i_27++) {
                            const value_345: License.License = License.License.read(input);
                            value_344.push(value_345);
                        }
                        input.readListEnd();
                        _args.success = value_344;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_346: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_346;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_347: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_347;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllLicensesResult(_args);
    }
}
export interface IGetCountAllLicensesResultArgs {
    success?: number;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetCountAllLicensesResult {
    public success?: number;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetCountAllLicensesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllLicensesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
            output.writeI32(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllLicensesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_348: number = input.readI32();
                        _args.success = value_348;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_349: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_349;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_350: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_350;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetCountAllLicensesResult(_args);
    }
}
export interface IUploadLicensesResultArgs {
    success?: Array<License.License>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class UploadLicensesResult {
    public success?: Array<License.License>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IUploadLicensesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UploadLicensesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_351: License.License): void => {
                value_351.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UploadLicensesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_352: Array<License.License> = new Array<License.License>();
                        const metadata_28: thrift.TList = input.readListBegin();
                        const size_28: number = metadata_28.size;
                        for (let i_28: number = 0; i_28 < size_28; i_28++) {
                            const value_353: License.License = License.License.read(input);
                            value_352.push(value_353);
                        }
                        input.readListEnd();
                        _args.success = value_352;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_354: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_354;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_355: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_355;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new UploadLicensesResult(_args);
    }
}
export interface IRemoveLicensesResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class RemoveLicensesResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IRemoveLicensesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveLicensesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveLicensesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_356: boolean = input.readBool();
                        _args.success = value_356;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_357: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_357;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_358: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_358;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveLicensesResult(_args);
    }
}
export interface IUpdateLicenseResultArgs {
    success?: License.License;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class UpdateLicenseResult {
    public success?: License.License;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IUpdateLicenseResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UpdateLicenseResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UpdateLicenseResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_359: License.License = License.License.read(input);
                        _args.success = value_359;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_360: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_360;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_361: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_361;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new UpdateLicenseResult(_args);
    }
}
export interface IReleaseLicenceResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class ReleaseLicenceResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IReleaseLicenceResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ReleaseLicenceResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ReleaseLicenceResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_362: boolean = input.readBool();
                        _args.success = value_362;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_363: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_363;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_364: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_364;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ReleaseLicenceResult(_args);
    }
}
export interface IGetLicenseModulePageResultArgs {
    success?: LicenseModulePage.LicenseModulePage;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetLicenseModulePageResult {
    public success?: LicenseModulePage.LicenseModulePage;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetLicenseModulePageResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetLicenseModulePageResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetLicenseModulePageResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_365: LicenseModulePage.LicenseModulePage = LicenseModulePage.LicenseModulePage.read(input);
                        _args.success = value_365;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_366: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_366;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_367: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_367;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetLicenseModulePageResult(_args);
    }
}
export interface IUploadLicenseModuleResultArgs {
    success?: LicenseModule.LicenseModule;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class UploadLicenseModuleResult {
    public success?: LicenseModule.LicenseModule;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IUploadLicenseModuleResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("UploadLicenseModuleResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): UploadLicenseModuleResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_368: LicenseModule.LicenseModule = LicenseModule.LicenseModule.read(input);
                        _args.success = value_368;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_369: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_369;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_370: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_370;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new UploadLicenseModuleResult(_args);
    }
}
export interface IRemoveLicenseModuleResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class RemoveLicenseModuleResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IRemoveLicenseModuleResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveLicenseModuleResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveLicenseModuleResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_371: boolean = input.readBool();
                        _args.success = value_371;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_372: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_372;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_373: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_373;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveLicenseModuleResult(_args);
    }
}
export interface ICreateOrUpdateResultArgs {
    success?: CharMatchingDictionary.CharMatchingDictionary;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class CreateOrUpdateResult {
    public success?: CharMatchingDictionary.CharMatchingDictionary;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: ICreateOrUpdateResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_374: CharMatchingDictionary.CharMatchingDictionary = CharMatchingDictionary.CharMatchingDictionary.read(input);
                        _args.success = value_374;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_375: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_375;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_376: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_376;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateOrUpdateResult(_args);
    }
}
export interface IGetAllCharMatchingDictionariesResultArgs {
    success?: Array<CharMatchingDictionary.CharMatchingDictionary>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllCharMatchingDictionariesResult {
    public success?: Array<CharMatchingDictionary.CharMatchingDictionary>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllCharMatchingDictionariesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllCharMatchingDictionariesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_377: CharMatchingDictionary.CharMatchingDictionary): void => {
                value_377.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllCharMatchingDictionariesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_378: Array<CharMatchingDictionary.CharMatchingDictionary> = new Array<CharMatchingDictionary.CharMatchingDictionary>();
                        const metadata_29: thrift.TList = input.readListBegin();
                        const size_29: number = metadata_29.size;
                        for (let i_29: number = 0; i_29 < size_29; i_29++) {
                            const value_379: CharMatchingDictionary.CharMatchingDictionary = CharMatchingDictionary.CharMatchingDictionary.read(input);
                            value_378.push(value_379);
                        }
                        input.readListEnd();
                        _args.success = value_378;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_380: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_380;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_381: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_381;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllCharMatchingDictionariesResult(_args);
    }
}
export interface IDeleteCharMatchingDictionaryResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class DeleteCharMatchingDictionaryResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IDeleteCharMatchingDictionaryResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteCharMatchingDictionaryResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteCharMatchingDictionaryResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_382: boolean = input.readBool();
                        _args.success = value_382;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_383: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_383;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_384: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_384;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteCharMatchingDictionaryResult(_args);
    }
}
export interface IGetTranslationsResultArgs {
    success?: Buffer;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetTranslationsResult {
    public success?: Buffer;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetTranslationsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetTranslationsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeBinary(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetTranslationsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_385: Buffer = input.readBinary();
                        _args.success = value_385;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_386: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_386;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_387: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_387;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetTranslationsResult(_args);
    }
}
export interface ISetTranslationsResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class SetTranslationsResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: ISetTranslationsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("SetTranslationsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): SetTranslationsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_388: boolean = input.readBool();
                        _args.success = value_388;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_389: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_389;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_390: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_390;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new SetTranslationsResult(_args);
    }
}
export interface IGetDroolLogFileResultArgs {
    success?: Buffer;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetDroolLogFileResult {
    public success?: Buffer;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetDroolLogFileResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDroolLogFileResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeBinary(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDroolLogFileResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_391: Buffer = input.readBinary();
                        _args.success = value_391;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_392: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_392;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_393: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_393;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetDroolLogFileResult(_args);
    }
}
export interface ICryptValueResultArgs {
    success?: string;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class CryptValueResult {
    public success?: string;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: ICryptValueResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CryptValueResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CryptValueResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_394: string = input.readString();
                        _args.success = value_394;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_395: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_395;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_396: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_396;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CryptValueResult(_args);
    }
}
export interface IGetAllJobTasksResultArgs {
    success?: Array<JobTask.JobTask>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllJobTasksResult {
    public success?: Array<JobTask.JobTask>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllJobTasksResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllJobTasksResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_397: JobTask.JobTask): void => {
                value_397.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllJobTasksResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_398: Array<JobTask.JobTask> = new Array<JobTask.JobTask>();
                        const metadata_30: thrift.TList = input.readListBegin();
                        const size_30: number = metadata_30.size;
                        for (let i_30: number = 0; i_30 < size_30; i_30++) {
                            const value_399: JobTask.JobTask = JobTask.JobTask.read(input);
                            value_398.push(value_399);
                        }
                        input.readListEnd();
                        _args.success = value_398;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_400: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_400;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_401: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_401;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllJobTasksResult(_args);
    }
}
export interface IGetCountAllJobTasksResultArgs {
    success?: number;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetCountAllJobTasksResult {
    public success?: number;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetCountAllJobTasksResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllJobTasksResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
            output.writeI32(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllJobTasksResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_402: number = input.readI32();
                        _args.success = value_402;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_403: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_403;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_404: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_404;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetCountAllJobTasksResult(_args);
    }
}
export interface IDeleteJobTaskResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class DeleteJobTaskResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IDeleteJobTaskResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("DeleteJobTaskResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): DeleteJobTaskResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_405: boolean = input.readBool();
                        _args.success = value_405;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_406: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_406;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_407: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_407;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new DeleteJobTaskResult(_args);
    }
}
export interface IRebuildAttachmentResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class RebuildAttachmentResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IRebuildAttachmentResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RebuildAttachmentResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RebuildAttachmentResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_408: boolean = input.readBool();
                        _args.success = value_408;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_409: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_409;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_410: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_410;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RebuildAttachmentResult(_args);
    }
}
export interface IGetAllUserContentItemsResultArgs {
    success?: Array<__ROOT_NAMESPACE__.ContentItem>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllUserContentItemsResult {
    public success?: Array<__ROOT_NAMESPACE__.ContentItem>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllUserContentItemsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllUserContentItemsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_411: __ROOT_NAMESPACE__.ContentItem): void => {
                value_411.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllUserContentItemsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_412: Array<__ROOT_NAMESPACE__.ContentItem> = new Array<__ROOT_NAMESPACE__.ContentItem>();
                        const metadata_31: thrift.TList = input.readListBegin();
                        const size_31: number = metadata_31.size;
                        for (let i_31: number = 0; i_31 < size_31; i_31++) {
                            const value_413: __ROOT_NAMESPACE__.ContentItem = __ROOT_NAMESPACE__.ContentItem.read(input);
                            value_412.push(value_413);
                        }
                        input.readListEnd();
                        _args.success = value_412;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_414: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_414;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_415: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_415;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllUserContentItemsResult(_args);
    }
}
export interface IChangeUserContentItemsResultArgs {
    success?: Array<__ROOT_NAMESPACE__.ContentItem>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class ChangeUserContentItemsResult {
    public success?: Array<__ROOT_NAMESPACE__.ContentItem>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IChangeUserContentItemsResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeUserContentItemsResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_416: __ROOT_NAMESPACE__.ContentItem): void => {
                value_416.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeUserContentItemsResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_417: Array<__ROOT_NAMESPACE__.ContentItem> = new Array<__ROOT_NAMESPACE__.ContentItem>();
                        const metadata_32: thrift.TList = input.readListBegin();
                        const size_32: number = metadata_32.size;
                        for (let i_32: number = 0; i_32 < size_32; i_32++) {
                            const value_418: __ROOT_NAMESPACE__.ContentItem = __ROOT_NAMESPACE__.ContentItem.read(input);
                            value_417.push(value_418);
                        }
                        input.readListEnd();
                        _args.success = value_417;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_419: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_419;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_420: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_420;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeUserContentItemsResult(_args);
    }
}
export interface IGetAllUserContentHoldersResultArgs {
    success?: Array<__ROOT_NAMESPACE__.ContentHolder>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllUserContentHoldersResult {
    public success?: Array<__ROOT_NAMESPACE__.ContentHolder>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllUserContentHoldersResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllUserContentHoldersResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_421: __ROOT_NAMESPACE__.ContentHolder): void => {
                value_421.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllUserContentHoldersResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_422: Array<__ROOT_NAMESPACE__.ContentHolder> = new Array<__ROOT_NAMESPACE__.ContentHolder>();
                        const metadata_33: thrift.TList = input.readListBegin();
                        const size_33: number = metadata_33.size;
                        for (let i_33: number = 0; i_33 < size_33; i_33++) {
                            const value_423: __ROOT_NAMESPACE__.ContentHolder = __ROOT_NAMESPACE__.ContentHolder.read(input);
                            value_422.push(value_423);
                        }
                        input.readListEnd();
                        _args.success = value_422;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_424: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_424;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_425: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_425;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllUserContentHoldersResult(_args);
    }
}
export interface IChangeUserContentHoldersResultArgs {
    success?: Array<__ROOT_NAMESPACE__.ContentHolder>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class ChangeUserContentHoldersResult {
    public success?: Array<__ROOT_NAMESPACE__.ContentHolder>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IChangeUserContentHoldersResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ChangeUserContentHoldersResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_426: __ROOT_NAMESPACE__.ContentHolder): void => {
                value_426.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ChangeUserContentHoldersResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_427: Array<__ROOT_NAMESPACE__.ContentHolder> = new Array<__ROOT_NAMESPACE__.ContentHolder>();
                        const metadata_34: thrift.TList = input.readListBegin();
                        const size_34: number = metadata_34.size;
                        for (let i_34: number = 0; i_34 < size_34; i_34++) {
                            const value_428: __ROOT_NAMESPACE__.ContentHolder = __ROOT_NAMESPACE__.ContentHolder.read(input);
                            value_427.push(value_428);
                        }
                        input.readListEnd();
                        _args.success = value_427;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_429: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_429;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_430: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_430;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ChangeUserContentHoldersResult(_args);
    }
}
export interface IRemoveLicensesExResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class RemoveLicensesExResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IRemoveLicensesExResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveLicensesExResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveLicensesExResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_431: boolean = input.readBool();
                        _args.success = value_431;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_432: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_432;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_433: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_433;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveLicensesExResult(_args);
    }
}
export interface IGetLicenseForUserResultArgs {
    success?: License.License;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetLicenseForUserResult {
    public success?: License.License;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetLicenseForUserResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetLicenseForUserResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetLicenseForUserResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_434: License.License = License.License.read(input);
                        _args.success = value_434;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_435: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_435;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_436: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_436;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetLicenseForUserResult(_args);
    }
}
export interface IGetAllowedRolesForLicenseResultArgs {
    success?: Set<string>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllowedRolesForLicenseResult {
    public success?: Set<string>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllowedRolesForLicenseResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllowedRolesForLicenseResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.SET, 0);
            output.writeSetBegin(thrift.Thrift.Type.STRING, this.success.size);
            this.success.forEach((value_437: string): void => {
                output.writeString(value_437);
            });
            output.writeSetEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllowedRolesForLicenseResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.SET) {
                        const value_438: Set<string> = new Set<string>();
                        const metadata_35: thrift.TSet = input.readSetBegin();
                        const size_35: number = metadata_35.size;
                        for (let i_35: number = 0; i_35 < size_35; i_35++) {
                            const value_439: string = input.readString();
                            value_438.add(value_439);
                        }
                        input.readSetEnd();
                        _args.success = value_438;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_440: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_440;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_441: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_441;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllowedRolesForLicenseResult(_args);
    }
}
export interface IAssignLicenseToUserResultArgs {
    success?: License.License;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class AssignLicenseToUserResult {
    public success?: License.License;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IAssignLicenseToUserResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("AssignLicenseToUserResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): AssignLicenseToUserResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_442: License.License = License.License.read(input);
                        _args.success = value_442;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_443: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_443;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_444: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_444;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new AssignLicenseToUserResult(_args);
    }
}
export interface IExecuteCustomQueryResultArgs {
    success?: Map<string, string>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class ExecuteCustomQueryResult {
    public success?: Map<string, string>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IExecuteCustomQueryResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("ExecuteCustomQueryResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.MAP, 0);
            output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.STRING, this.success.size);
            this.success.forEach((value_445: string, key_1: string): void => {
                output.writeString(key_1);
                output.writeString(value_445);
            });
            output.writeMapEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): ExecuteCustomQueryResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.MAP) {
                        const value_446: Map<string, string> = new Map<string, string>();
                        const metadata_36: thrift.TMap = input.readMapBegin();
                        const size_36: number = metadata_36.size;
                        for (let i_36: number = 0; i_36 < size_36; i_36++) {
                            const key_2: string = input.readString();
                            const value_447: string = input.readString();
                            value_446.set(key_2, value_447);
                        }
                        input.readMapEnd();
                        _args.success = value_446;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_448: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_448;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_449: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_449;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new ExecuteCustomQueryResult(_args);
    }
}
export interface ICreateOrUpdateUsersResultArgs {
    success?: Array<string>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class CreateOrUpdateUsersResult {
    public success?: Array<string>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: ICreateOrUpdateUsersResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateUsersResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRING, this.success.length);
            this.success.forEach((value_450: string): void => {
                output.writeString(value_450);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateUsersResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_451: Array<string> = new Array<string>();
                        const metadata_37: thrift.TList = input.readListBegin();
                        const size_37: number = metadata_37.size;
                        for (let i_37: number = 0; i_37 < size_37; i_37++) {
                            const value_452: string = input.readString();
                            value_451.push(value_452);
                        }
                        input.readListEnd();
                        _args.success = value_451;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_453: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_453;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_454: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_454;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateOrUpdateUsersResult(_args);
    }
}
export class Client {
    public _seqid: number;
    public _reqs: {
        [name: number]: (err: Error | object | undefined, val?: any) => void;
    };
    public output: thrift.TTransport;
    public protocol: new (trans: thrift.TTransport) => thrift.TProtocol;
    constructor(output: thrift.TTransport, protocol: new (trans: thrift.TTransport) => thrift.TProtocol) {
        this._seqid = 0;
        this._reqs = {};
        this.output = output;
        this.protocol = protocol;
    }
    public incrementSeqId(): number {
        return this._seqid += 1;
    }
    public getAvailableFileStorageList(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<Array<__ROOT_NAMESPACE__.AvailableFileStorage>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<__ROOT_NAMESPACE__.AvailableFileStorage>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAvailableFileStorageList(token, filter, requestId);
        });
    }
    public createOrUpdateFileStorage(token: string, fileStorage: __ROOT_NAMESPACE__.FileStorage, password: string, accountsToAdd: Array<__ROOT_NAMESPACE__.Account>, accountsToRemove: Array<__ROOT_NAMESPACE__.Account>): Promise<__ROOT_NAMESPACE__.FileStorage> {
        const requestId: number = this.incrementSeqId();
        return new Promise<__ROOT_NAMESPACE__.FileStorage>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createOrUpdateFileStorage(token, fileStorage, password, accountsToAdd, accountsToRemove, requestId);
        });
    }
    public getAllFileStorages(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<Array<__ROOT_NAMESPACE__.FileStorage>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<__ROOT_NAMESPACE__.FileStorage>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllFileStorages(token, filter, requestId);
        });
    }
    public getCountAllFileStorages(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<number> {
        const requestId: number = this.incrementSeqId();
        return new Promise<number>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getCountAllFileStorages(token, filter, requestId);
        });
    }
    public removeFileStorages(token: string, fileStorageIds: Array<string>, password: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeFileStorages(token, fileStorageIds, password, requestId);
        });
    }
    public moveAttachment(token: string, docId: string, fileStorageId: string, onlyLatest: boolean): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_moveAttachment(token, docId, fileStorageId, onlyLatest, requestId);
        });
    }
    public createOrUpdateNews(token: string, news: __ROOT_NAMESPACE__.News, accountIDsToAdd: Set<string>, accountIDsToRemove: Set<string>): Promise<__ROOT_NAMESPACE__.News> {
        const requestId: number = this.incrementSeqId();
        return new Promise<__ROOT_NAMESPACE__.News>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createOrUpdateNews(token, news, accountIDsToAdd, accountIDsToRemove, requestId);
        });
    }
    public removeNews(token: string, newsId: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeNews(token, newsId, requestId);
        });
    }
    public getAllExternalModules(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<Array<ExternalModule.ExternalModule>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<ExternalModule.ExternalModule>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllExternalModules(token, filter, requestId);
        });
    }
    public getCountAllExternalModules(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<number> {
        const requestId: number = this.incrementSeqId();
        return new Promise<number>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getCountAllExternalModules(token, filter, requestId);
        });
    }
    public createOrUpdateExternalModule(token: string, externalModule: ExternalModule.ExternalModule, userLoginForNewRegistration: string, secretKey: string, addAccountIds: Set<string>, deleteAccountIds: Set<string>): Promise<ExternalModule.ExternalModule> {
        const requestId: number = this.incrementSeqId();
        return new Promise<ExternalModule.ExternalModule>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createOrUpdateExternalModule(token, externalModule, userLoginForNewRegistration, secretKey, addAccountIds, deleteAccountIds, requestId);
        });
    }
    public refreshExternalModule(token: string, extModuleId: string, removeDeletedStages: boolean): Promise<ExternalModule.ExternalModule> {
        const requestId: number = this.incrementSeqId();
        return new Promise<ExternalModule.ExternalModule>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_refreshExternalModule(token, extModuleId, removeDeletedStages, requestId);
        });
    }
    public removeExternalModule(token: string, extModuleId: string, password: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeExternalModule(token, extModuleId, password, requestId);
        });
    }
    public pingExternalModule(token: string, extModuleId: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_pingExternalModule(token, extModuleId, requestId);
        });
    }
    public pongExternalModule(token: string, extModuleCheckValue: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_pongExternalModule(token, extModuleCheckValue, requestId);
        });
    }
    public getAllDocumentAttachments(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<Array<__ROOT_NAMESPACE__.Attachment>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<__ROOT_NAMESPACE__.Attachment>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllDocumentAttachments(token, filter, requestId);
        });
    }
    public getAllFilledDocumentPatternStages(token: string, fillDocPatternId: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<Array<__ROOT_NAMESPACE__.DocumentPatternStage>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<__ROOT_NAMESPACE__.DocumentPatternStage>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllFilledDocumentPatternStages(token, fillDocPatternId, filter, requestId);
        });
    }
    public resetDocumentForceMoveError(token: string, documentId: string): Promise<number> {
        const requestId: number = this.incrementSeqId();
        return new Promise<number>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_resetDocumentForceMoveError(token, documentId, requestId);
        });
    }
    public changeExecutorForPatternStages(token: string, patternIds: Array<string>, userOrGroup: __ROOT_NAMESPACE__.UserOrGroup, usersOrGroups: Array<__ROOT_NAMESPACE__.UserOrGroup>): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeExecutorForPatternStages(token, patternIds, userOrGroup, usersOrGroups, requestId);
        });
    }
    public setUserPublicKey(token: string, userId: string, publicKey: string, password: string): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setUserPublicKey(token, userId, publicKey, password, requestId);
        });
    }
    public removeUserPublicKey(token: string, keyId: string, password: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeUserPublicKey(token, keyId, password, requestId);
        });
    }
    public getAllUsersRelativeToAccount(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<Array<UserAcc.UserAcc>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<UserAcc.UserAcc>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllUsersRelativeToAccount(token, filter, requestId);
        });
    }
    public getCountAllUsersRelativeToAccount(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<number> {
        const requestId: number = this.incrementSeqId();
        return new Promise<number>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getCountAllUsersRelativeToAccount(token, filter, requestId);
        });
    }
    public changeUserAccounts(token: string, userId: string, accountIdsToAdd: Set<string>, accountIdsToRemove: Set<string>, accountMainId: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeUserAccounts(token, userId, accountIdsToAdd, accountIdsToRemove, accountMainId, requestId);
        });
    }
    public runScheduler(token: string, oName: string, wait: boolean): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_runScheduler(token, oName, wait, requestId);
        });
    }
    public changeEncryptKey(token: string, key: string, accountId: string, password: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeEncryptKey(token, key, accountId, password, requestId);
        });
    }
    public getAllUsersExt(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<Array<UserExt.UserExt>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<UserExt.UserExt>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllUsersExt(token, filter, requestId);
        });
    }
    public getCountAllUsersExt(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<number> {
        const requestId: number = this.incrementSeqId();
        return new Promise<number>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getCountAllUsersExt(token, filter, requestId);
        });
    }
    public getAllUserNotifications(token: string, userId: string, unreadOnly: boolean, filter: __ROOT_NAMESPACE__.KazFilter): Promise<Array<__ROOT_NAMESPACE__.NotificationQueue>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<__ROOT_NAMESPACE__.NotificationQueue>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllUserNotifications(token, userId, unreadOnly, filter, requestId);
        });
    }
    public getAllNotifications(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<Array<__ROOT_NAMESPACE__.NotificationQueue>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<__ROOT_NAMESPACE__.NotificationQueue>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllNotifications(token, filter, requestId);
        });
    }
    public moveDocumentOnOtherPatternStage(token: string, documentId: string, stageId: string, resetMoveError: boolean): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_moveDocumentOnOtherPatternStage(token, documentId, stageId, resetMoveError, requestId);
        });
    }
    public resendDocumentToExternalModule(token: string, documentId: string, accessPolicy: __ROOT_NAMESPACE__.DocumentAccessPolicy): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_resendDocumentToExternalModule(token, documentId, accessPolicy, requestId);
        });
    }
    public getAllSessions(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<Array<__ROOT_NAMESPACE__.AuthSession>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<__ROOT_NAMESPACE__.AuthSession>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllSessions(token, filter, requestId);
        });
    }
    public getCountAllSessions(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<number> {
        const requestId: number = this.incrementSeqId();
        return new Promise<number>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getCountAllSessions(token, filter, requestId);
        });
    }
    public confirmUserPublicKey(token: string, id: string, confirm: boolean): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_confirmUserPublicKey(token, id, confirm, requestId);
        });
    }
    public closeSession(token: string, sessionId: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_closeSession(token, sessionId, requestId);
        });
    }
    public copyPersonalAccess(token: string, copyPersonalAccessSettings: CopyPersonalAccessSettings.CopyPersonalAccessSettings): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_copyPersonalAccess(token, copyPersonalAccessSettings, requestId);
        });
    }
    public getAllLicenses(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<Array<License.License>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<License.License>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllLicenses(token, filter, requestId);
        });
    }
    public getCountAllLicenses(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<number> {
        const requestId: number = this.incrementSeqId();
        return new Promise<number>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getCountAllLicenses(token, filter, requestId);
        });
    }
    public uploadLicenses(token: string, fileContentBytes: Buffer, accountGroup: __ROOT_NAMESPACE__.AccountGroup, account: __ROOT_NAMESPACE__.Account, autoAssignment: boolean, autoAssignmentOrder: number): Promise<Array<License.License>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<License.License>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_uploadLicenses(token, fileContentBytes, accountGroup, account, autoAssignment, autoAssignmentOrder, requestId);
        });
    }
    public removeLicenses(token: string, lkeys: Array<string>): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeLicenses(token, lkeys, requestId);
        });
    }
    public updateLicense(token: string, license: License.License): Promise<License.License> {
        const requestId: number = this.incrementSeqId();
        return new Promise<License.License>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_updateLicense(token, license, requestId);
        });
    }
    public releaseLicence(token: string, userId: string, cancelAutoAssignment: boolean): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_releaseLicence(token, userId, cancelAutoAssignment, requestId);
        });
    }
    public getLicenseModulePage(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<LicenseModulePage.LicenseModulePage> {
        const requestId: number = this.incrementSeqId();
        return new Promise<LicenseModulePage.LicenseModulePage>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getLicenseModulePage(token, filter, requestId);
        });
    }
    public uploadLicenseModule(token: string, fileContentBytes: Buffer): Promise<LicenseModule.LicenseModule> {
        const requestId: number = this.incrementSeqId();
        return new Promise<LicenseModule.LicenseModule>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_uploadLicenseModule(token, fileContentBytes, requestId);
        });
    }
    public removeLicenseModule(token: string, id: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeLicenseModule(token, id, requestId);
        });
    }
    public createOrUpdate(token: string, dictionary: CharMatchingDictionary.CharMatchingDictionary): Promise<CharMatchingDictionary.CharMatchingDictionary> {
        const requestId: number = this.incrementSeqId();
        return new Promise<CharMatchingDictionary.CharMatchingDictionary>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createOrUpdate(token, dictionary, requestId);
        });
    }
    public getAllCharMatchingDictionaries(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<Array<CharMatchingDictionary.CharMatchingDictionary>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<CharMatchingDictionary.CharMatchingDictionary>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllCharMatchingDictionaries(token, filter, requestId);
        });
    }
    public deleteCharMatchingDictionary(token: string, dictionary: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteCharMatchingDictionary(token, dictionary, requestId);
        });
    }
    public getTranslations(token: string, langCode: string): Promise<Buffer> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Buffer>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getTranslations(token, langCode, requestId);
        });
    }
    public setTranslations(token: string, langCode: string, langFile: Buffer): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_setTranslations(token, langCode, langFile, requestId);
        });
    }
    public getDroolLogFile(token: string, docId: string, policy: __ROOT_NAMESPACE__.DocumentAccessPolicy): Promise<Buffer> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Buffer>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getDroolLogFile(token, docId, policy, requestId);
        });
    }
    public cryptValue(token: string, value: string): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_cryptValue(token, value, requestId);
        });
    }
    public getAllJobTasks(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<Array<JobTask.JobTask>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<JobTask.JobTask>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllJobTasks(token, filter, requestId);
        });
    }
    public getCountAllJobTasks(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<number> {
        const requestId: number = this.incrementSeqId();
        return new Promise<number>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getCountAllJobTasks(token, filter, requestId);
        });
    }
    public deleteJobTask(token: string, jobTaskId: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_deleteJobTask(token, jobTaskId, requestId);
        });
    }
    public rebuildAttachment(token: string, attachmentId: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_rebuildAttachment(token, attachmentId, requestId);
        });
    }
    public getAllUserContentItems(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<Array<__ROOT_NAMESPACE__.ContentItem>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<__ROOT_NAMESPACE__.ContentItem>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllUserContentItems(token, filter, requestId);
        });
    }
    public changeUserContentItems(token: string, contentItems: Array<__ROOT_NAMESPACE__.ContentItem>): Promise<Array<__ROOT_NAMESPACE__.ContentItem>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<__ROOT_NAMESPACE__.ContentItem>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeUserContentItems(token, contentItems, requestId);
        });
    }
    public getAllUserContentHolders(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Promise<Array<__ROOT_NAMESPACE__.ContentHolder>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<__ROOT_NAMESPACE__.ContentHolder>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllUserContentHolders(token, filter, requestId);
        });
    }
    public changeUserContentHolders(token: string, toUpdate: Array<__ROOT_NAMESPACE__.ContentHolder>, toRemoveIds: Array<string>): Promise<Array<__ROOT_NAMESPACE__.ContentHolder>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<__ROOT_NAMESPACE__.ContentHolder>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_changeUserContentHolders(token, toUpdate, toRemoveIds, requestId);
        });
    }
    public removeLicensesEx(token: string, accountGroupId: string, accountId: string, dateFrom: Int64, dateTo: Int64): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeLicensesEx(token, accountGroupId, accountId, dateFrom, dateTo, requestId);
        });
    }
    public getLicenseForUser(token: string, userId: string): Promise<License.License> {
        const requestId: number = this.incrementSeqId();
        return new Promise<License.License>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getLicenseForUser(token, userId, requestId);
        });
    }
    public getAllowedRolesForLicense(token: string, licenseKey: string): Promise<Set<string>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Set<string>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllowedRolesForLicense(token, licenseKey, requestId);
        });
    }
    public assignLicenseToUser(token: string, licenseKey: string, userId: string): Promise<License.License> {
        const requestId: number = this.incrementSeqId();
        return new Promise<License.License>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_assignLicenseToUser(token, licenseKey, userId, requestId);
        });
    }
    public executeCustomQuery(token: string, query: string): Promise<Map<string, string>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Map<string, string>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_executeCustomQuery(token, query, requestId);
        });
    }
    public createOrUpdateUsers(token: string, users: Array<__ROOT_NAMESPACE__.UserOrGroup>, options: UserOptions.UserOptions): Promise<Array<string>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<string>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createOrUpdateUsers(token, users, options, requestId);
        });
    }
    public send_getAvailableFileStorageList(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAvailableFileStorageList", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAvailableFileStorageListArgs = new GetAvailableFileStorageListArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createOrUpdateFileStorage(token: string, fileStorage: __ROOT_NAMESPACE__.FileStorage, password: string, accountsToAdd: Array<__ROOT_NAMESPACE__.Account>, accountsToRemove: Array<__ROOT_NAMESPACE__.Account>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createOrUpdateFileStorage", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateOrUpdateFileStorageArgs = new CreateOrUpdateFileStorageArgs({ token, fileStorage, password, accountsToAdd, accountsToRemove });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllFileStorages(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllFileStorages", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllFileStoragesArgs = new GetAllFileStoragesArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getCountAllFileStorages(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getCountAllFileStorages", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetCountAllFileStoragesArgs = new GetCountAllFileStoragesArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeFileStorages(token: string, fileStorageIds: Array<string>, password: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeFileStorages", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveFileStoragesArgs = new RemoveFileStoragesArgs({ token, fileStorageIds, password });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_moveAttachment(token: string, docId: string, fileStorageId: string, onlyLatest: boolean, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("moveAttachment", thrift.Thrift.MessageType.CALL, requestId);
        const args: MoveAttachmentArgs = new MoveAttachmentArgs({ token, docId, fileStorageId, onlyLatest });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createOrUpdateNews(token: string, news: __ROOT_NAMESPACE__.News, accountIDsToAdd: Set<string>, accountIDsToRemove: Set<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createOrUpdateNews", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateOrUpdateNewsArgs = new CreateOrUpdateNewsArgs({ token, news, accountIDsToAdd, accountIDsToRemove });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeNews(token: string, newsId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeNews", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveNewsArgs = new RemoveNewsArgs({ token, newsId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllExternalModules(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllExternalModules", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllExternalModulesArgs = new GetAllExternalModulesArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getCountAllExternalModules(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getCountAllExternalModules", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetCountAllExternalModulesArgs = new GetCountAllExternalModulesArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createOrUpdateExternalModule(token: string, externalModule: ExternalModule.ExternalModule, userLoginForNewRegistration: string, secretKey: string, addAccountIds: Set<string>, deleteAccountIds: Set<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createOrUpdateExternalModule", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateOrUpdateExternalModuleArgs = new CreateOrUpdateExternalModuleArgs({ token, externalModule, userLoginForNewRegistration, secretKey, addAccountIds, deleteAccountIds });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_refreshExternalModule(token: string, extModuleId: string, removeDeletedStages: boolean, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("refreshExternalModule", thrift.Thrift.MessageType.CALL, requestId);
        const args: RefreshExternalModuleArgs = new RefreshExternalModuleArgs({ token, extModuleId, removeDeletedStages });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeExternalModule(token: string, extModuleId: string, password: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeExternalModule", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveExternalModuleArgs = new RemoveExternalModuleArgs({ token, extModuleId, password });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_pingExternalModule(token: string, extModuleId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("pingExternalModule", thrift.Thrift.MessageType.CALL, requestId);
        const args: PingExternalModuleArgs = new PingExternalModuleArgs({ token, extModuleId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_pongExternalModule(token: string, extModuleCheckValue: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("pongExternalModule", thrift.Thrift.MessageType.CALL, requestId);
        const args: PongExternalModuleArgs = new PongExternalModuleArgs({ token, extModuleCheckValue });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllDocumentAttachments(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllDocumentAttachments", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllDocumentAttachmentsArgs = new GetAllDocumentAttachmentsArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllFilledDocumentPatternStages(token: string, fillDocPatternId: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllFilledDocumentPatternStages", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllFilledDocumentPatternStagesArgs = new GetAllFilledDocumentPatternStagesArgs({ token, fillDocPatternId, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_resetDocumentForceMoveError(token: string, documentId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("resetDocumentForceMoveError", thrift.Thrift.MessageType.CALL, requestId);
        const args: ResetDocumentForceMoveErrorArgs = new ResetDocumentForceMoveErrorArgs({ token, documentId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeExecutorForPatternStages(token: string, patternIds: Array<string>, userOrGroup: __ROOT_NAMESPACE__.UserOrGroup, usersOrGroups: Array<__ROOT_NAMESPACE__.UserOrGroup>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeExecutorForPatternStages", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeExecutorForPatternStagesArgs = new ChangeExecutorForPatternStagesArgs({ token, patternIds, userOrGroup, usersOrGroups });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setUserPublicKey(token: string, userId: string, publicKey: string, password: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setUserPublicKey", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetUserPublicKeyArgs = new SetUserPublicKeyArgs({ token, userId, publicKey, password });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeUserPublicKey(token: string, keyId: string, password: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeUserPublicKey", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveUserPublicKeyArgs = new RemoveUserPublicKeyArgs({ token, keyId, password });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllUsersRelativeToAccount(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllUsersRelativeToAccount", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllUsersRelativeToAccountArgs = new GetAllUsersRelativeToAccountArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getCountAllUsersRelativeToAccount(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getCountAllUsersRelativeToAccount", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetCountAllUsersRelativeToAccountArgs = new GetCountAllUsersRelativeToAccountArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeUserAccounts(token: string, userId: string, accountIdsToAdd: Set<string>, accountIdsToRemove: Set<string>, accountMainId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeUserAccounts", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeUserAccountsArgs = new ChangeUserAccountsArgs({ token, userId, accountIdsToAdd, accountIdsToRemove, accountMainId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_runScheduler(token: string, oName: string, wait: boolean, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("runScheduler", thrift.Thrift.MessageType.CALL, requestId);
        const args: RunSchedulerArgs = new RunSchedulerArgs({ token, oName, wait });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeEncryptKey(token: string, key: string, accountId: string, password: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeEncryptKey", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeEncryptKeyArgs = new ChangeEncryptKeyArgs({ token, key, accountId, password });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllUsersExt(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllUsersExt", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllUsersExtArgs = new GetAllUsersExtArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getCountAllUsersExt(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getCountAllUsersExt", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetCountAllUsersExtArgs = new GetCountAllUsersExtArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllUserNotifications(token: string, userId: string, unreadOnly: boolean, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllUserNotifications", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllUserNotificationsArgs = new GetAllUserNotificationsArgs({ token, userId, unreadOnly, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllNotifications(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllNotifications", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllNotificationsArgs = new GetAllNotificationsArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_moveDocumentOnOtherPatternStage(token: string, documentId: string, stageId: string, resetMoveError: boolean, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("moveDocumentOnOtherPatternStage", thrift.Thrift.MessageType.CALL, requestId);
        const args: MoveDocumentOnOtherPatternStageArgs = new MoveDocumentOnOtherPatternStageArgs({ token, documentId, stageId, resetMoveError });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_resendDocumentToExternalModule(token: string, documentId: string, accessPolicy: __ROOT_NAMESPACE__.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("resendDocumentToExternalModule", thrift.Thrift.MessageType.CALL, requestId);
        const args: ResendDocumentToExternalModuleArgs = new ResendDocumentToExternalModuleArgs({ token, documentId, accessPolicy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllSessions(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllSessions", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllSessionsArgs = new GetAllSessionsArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getCountAllSessions(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getCountAllSessions", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetCountAllSessionsArgs = new GetCountAllSessionsArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_confirmUserPublicKey(token: string, id: string, confirm: boolean, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("confirmUserPublicKey", thrift.Thrift.MessageType.CALL, requestId);
        const args: ConfirmUserPublicKeyArgs = new ConfirmUserPublicKeyArgs({ token, id, confirm });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_closeSession(token: string, sessionId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("closeSession", thrift.Thrift.MessageType.CALL, requestId);
        const args: CloseSessionArgs = new CloseSessionArgs({ token, sessionId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_copyPersonalAccess(token: string, copyPersonalAccessSettings: CopyPersonalAccessSettings.CopyPersonalAccessSettings, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("copyPersonalAccess", thrift.Thrift.MessageType.CALL, requestId);
        const args: CopyPersonalAccessArgs = new CopyPersonalAccessArgs({ token, copyPersonalAccessSettings });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllLicenses(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllLicenses", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllLicensesArgs = new GetAllLicensesArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getCountAllLicenses(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getCountAllLicenses", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetCountAllLicensesArgs = new GetCountAllLicensesArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_uploadLicenses(token: string, fileContentBytes: Buffer, accountGroup: __ROOT_NAMESPACE__.AccountGroup, account: __ROOT_NAMESPACE__.Account, autoAssignment: boolean, autoAssignmentOrder: number, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("uploadLicenses", thrift.Thrift.MessageType.CALL, requestId);
        const args: UploadLicensesArgs = new UploadLicensesArgs({ token, fileContentBytes, accountGroup, account, autoAssignment, autoAssignmentOrder });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeLicenses(token: string, lkeys: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeLicenses", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveLicensesArgs = new RemoveLicensesArgs({ token, lkeys });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_updateLicense(token: string, license: License.License, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("updateLicense", thrift.Thrift.MessageType.CALL, requestId);
        const args: UpdateLicenseArgs = new UpdateLicenseArgs({ token, license });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_releaseLicence(token: string, userId: string, cancelAutoAssignment: boolean, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("releaseLicence", thrift.Thrift.MessageType.CALL, requestId);
        const args: ReleaseLicenceArgs = new ReleaseLicenceArgs({ token, userId, cancelAutoAssignment });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getLicenseModulePage(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getLicenseModulePage", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetLicenseModulePageArgs = new GetLicenseModulePageArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_uploadLicenseModule(token: string, fileContentBytes: Buffer, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("uploadLicenseModule", thrift.Thrift.MessageType.CALL, requestId);
        const args: UploadLicenseModuleArgs = new UploadLicenseModuleArgs({ token, fileContentBytes });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeLicenseModule(token: string, id: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeLicenseModule", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveLicenseModuleArgs = new RemoveLicenseModuleArgs({ token, id });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createOrUpdate(token: string, dictionary: CharMatchingDictionary.CharMatchingDictionary, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createOrUpdate", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateOrUpdateArgs = new CreateOrUpdateArgs({ token, dictionary });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllCharMatchingDictionaries(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllCharMatchingDictionaries", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllCharMatchingDictionariesArgs = new GetAllCharMatchingDictionariesArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteCharMatchingDictionary(token: string, dictionary: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteCharMatchingDictionary", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteCharMatchingDictionaryArgs = new DeleteCharMatchingDictionaryArgs({ token, dictionary });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getTranslations(token: string, langCode: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getTranslations", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetTranslationsArgs = new GetTranslationsArgs({ token, langCode });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_setTranslations(token: string, langCode: string, langFile: Buffer, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("setTranslations", thrift.Thrift.MessageType.CALL, requestId);
        const args: SetTranslationsArgs = new SetTranslationsArgs({ token, langCode, langFile });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getDroolLogFile(token: string, docId: string, policy: __ROOT_NAMESPACE__.DocumentAccessPolicy, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getDroolLogFile", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetDroolLogFileArgs = new GetDroolLogFileArgs({ token, docId, policy });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_cryptValue(token: string, value: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("cryptValue", thrift.Thrift.MessageType.CALL, requestId);
        const args: CryptValueArgs = new CryptValueArgs({ token, value });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllJobTasks(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllJobTasks", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllJobTasksArgs = new GetAllJobTasksArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getCountAllJobTasks(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getCountAllJobTasks", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetCountAllJobTasksArgs = new GetCountAllJobTasksArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_deleteJobTask(token: string, jobTaskId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("deleteJobTask", thrift.Thrift.MessageType.CALL, requestId);
        const args: DeleteJobTaskArgs = new DeleteJobTaskArgs({ token, jobTaskId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_rebuildAttachment(token: string, attachmentId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("rebuildAttachment", thrift.Thrift.MessageType.CALL, requestId);
        const args: RebuildAttachmentArgs = new RebuildAttachmentArgs({ token, attachmentId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllUserContentItems(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllUserContentItems", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllUserContentItemsArgs = new GetAllUserContentItemsArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeUserContentItems(token: string, contentItems: Array<__ROOT_NAMESPACE__.ContentItem>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeUserContentItems", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeUserContentItemsArgs = new ChangeUserContentItemsArgs({ token, contentItems });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllUserContentHolders(token: string, filter: __ROOT_NAMESPACE__.KazFilter, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllUserContentHolders", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllUserContentHoldersArgs = new GetAllUserContentHoldersArgs({ token, filter });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_changeUserContentHolders(token: string, toUpdate: Array<__ROOT_NAMESPACE__.ContentHolder>, toRemoveIds: Array<string>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("changeUserContentHolders", thrift.Thrift.MessageType.CALL, requestId);
        const args: ChangeUserContentHoldersArgs = new ChangeUserContentHoldersArgs({ token, toUpdate, toRemoveIds });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeLicensesEx(token: string, accountGroupId: string, accountId: string, dateFrom: Int64, dateTo: Int64, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeLicensesEx", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveLicensesExArgs = new RemoveLicensesExArgs({ token, accountGroupId, accountId, dateFrom, dateTo });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getLicenseForUser(token: string, userId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getLicenseForUser", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetLicenseForUserArgs = new GetLicenseForUserArgs({ token, userId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllowedRolesForLicense(token: string, licenseKey: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllowedRolesForLicense", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllowedRolesForLicenseArgs = new GetAllowedRolesForLicenseArgs({ token, licenseKey });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_assignLicenseToUser(token: string, licenseKey: string, userId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("assignLicenseToUser", thrift.Thrift.MessageType.CALL, requestId);
        const args: AssignLicenseToUserArgs = new AssignLicenseToUserArgs({ token, licenseKey, userId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_executeCustomQuery(token: string, query: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("executeCustomQuery", thrift.Thrift.MessageType.CALL, requestId);
        const args: ExecuteCustomQueryArgs = new ExecuteCustomQueryArgs({ token, query });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createOrUpdateUsers(token: string, users: Array<__ROOT_NAMESPACE__.UserOrGroup>, options: UserOptions.UserOptions, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createOrUpdateUsers", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateOrUpdateUsersArgs = new CreateOrUpdateUsersArgs({ token, users, options });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public recv_getAvailableFileStorageList(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAvailableFileStorageListResult = GetAvailableFileStorageListResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAvailableFileStorageList failed: unknown result"));
                }
            }
        }
    }
    public recv_createOrUpdateFileStorage(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateOrUpdateFileStorageResult = CreateOrUpdateFileStorageResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createOrUpdateFileStorage failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllFileStorages(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllFileStoragesResult = GetAllFileStoragesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllFileStorages failed: unknown result"));
                }
            }
        }
    }
    public recv_getCountAllFileStorages(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetCountAllFileStoragesResult = GetCountAllFileStoragesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getCountAllFileStorages failed: unknown result"));
                }
            }
        }
    }
    public recv_removeFileStorages(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveFileStoragesResult = RemoveFileStoragesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeFileStorages failed: unknown result"));
                }
            }
        }
    }
    public recv_moveAttachment(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: MoveAttachmentResult = MoveAttachmentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "moveAttachment failed: unknown result"));
                }
            }
        }
    }
    public recv_createOrUpdateNews(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateOrUpdateNewsResult = CreateOrUpdateNewsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createOrUpdateNews failed: unknown result"));
                }
            }
        }
    }
    public recv_removeNews(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveNewsResult = RemoveNewsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeNews failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllExternalModules(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllExternalModulesResult = GetAllExternalModulesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllExternalModules failed: unknown result"));
                }
            }
        }
    }
    public recv_getCountAllExternalModules(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetCountAllExternalModulesResult = GetCountAllExternalModulesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getCountAllExternalModules failed: unknown result"));
                }
            }
        }
    }
    public recv_createOrUpdateExternalModule(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateOrUpdateExternalModuleResult = CreateOrUpdateExternalModuleResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createOrUpdateExternalModule failed: unknown result"));
                }
            }
        }
    }
    public recv_refreshExternalModule(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RefreshExternalModuleResult = RefreshExternalModuleResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "refreshExternalModule failed: unknown result"));
                }
            }
        }
    }
    public recv_removeExternalModule(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveExternalModuleResult = RemoveExternalModuleResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeExternalModule failed: unknown result"));
                }
            }
        }
    }
    public recv_pingExternalModule(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: PingExternalModuleResult = PingExternalModuleResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "pingExternalModule failed: unknown result"));
                }
            }
        }
    }
    public recv_pongExternalModule(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: PongExternalModuleResult = PongExternalModuleResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "pongExternalModule failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllDocumentAttachments(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllDocumentAttachmentsResult = GetAllDocumentAttachmentsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllDocumentAttachments failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllFilledDocumentPatternStages(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllFilledDocumentPatternStagesResult = GetAllFilledDocumentPatternStagesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllFilledDocumentPatternStages failed: unknown result"));
                }
            }
        }
    }
    public recv_resetDocumentForceMoveError(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ResetDocumentForceMoveErrorResult = ResetDocumentForceMoveErrorResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "resetDocumentForceMoveError failed: unknown result"));
                }
            }
        }
    }
    public recv_changeExecutorForPatternStages(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeExecutorForPatternStagesResult = ChangeExecutorForPatternStagesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeExecutorForPatternStages failed: unknown result"));
                }
            }
        }
    }
    public recv_setUserPublicKey(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetUserPublicKeyResult = SetUserPublicKeyResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setUserPublicKey failed: unknown result"));
                }
            }
        }
    }
    public recv_removeUserPublicKey(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveUserPublicKeyResult = RemoveUserPublicKeyResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeUserPublicKey failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllUsersRelativeToAccount(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllUsersRelativeToAccountResult = GetAllUsersRelativeToAccountResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllUsersRelativeToAccount failed: unknown result"));
                }
            }
        }
    }
    public recv_getCountAllUsersRelativeToAccount(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetCountAllUsersRelativeToAccountResult = GetCountAllUsersRelativeToAccountResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getCountAllUsersRelativeToAccount failed: unknown result"));
                }
            }
        }
    }
    public recv_changeUserAccounts(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeUserAccountsResult = ChangeUserAccountsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeUserAccounts failed: unknown result"));
                }
            }
        }
    }
    public recv_runScheduler(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RunSchedulerResult = RunSchedulerResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "runScheduler failed: unknown result"));
                }
            }
        }
    }
    public recv_changeEncryptKey(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeEncryptKeyResult = ChangeEncryptKeyResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeEncryptKey failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllUsersExt(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllUsersExtResult = GetAllUsersExtResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllUsersExt failed: unknown result"));
                }
            }
        }
    }
    public recv_getCountAllUsersExt(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetCountAllUsersExtResult = GetCountAllUsersExtResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getCountAllUsersExt failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllUserNotifications(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllUserNotificationsResult = GetAllUserNotificationsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllUserNotifications failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllNotifications(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllNotificationsResult = GetAllNotificationsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllNotifications failed: unknown result"));
                }
            }
        }
    }
    public recv_moveDocumentOnOtherPatternStage(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: MoveDocumentOnOtherPatternStageResult = MoveDocumentOnOtherPatternStageResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "moveDocumentOnOtherPatternStage failed: unknown result"));
                }
            }
        }
    }
    public recv_resendDocumentToExternalModule(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ResendDocumentToExternalModuleResult = ResendDocumentToExternalModuleResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "resendDocumentToExternalModule failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllSessions(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllSessionsResult = GetAllSessionsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllSessions failed: unknown result"));
                }
            }
        }
    }
    public recv_getCountAllSessions(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetCountAllSessionsResult = GetCountAllSessionsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getCountAllSessions failed: unknown result"));
                }
            }
        }
    }
    public recv_confirmUserPublicKey(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ConfirmUserPublicKeyResult = ConfirmUserPublicKeyResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "confirmUserPublicKey failed: unknown result"));
                }
            }
        }
    }
    public recv_closeSession(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CloseSessionResult = CloseSessionResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "closeSession failed: unknown result"));
                }
            }
        }
    }
    public recv_copyPersonalAccess(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CopyPersonalAccessResult = CopyPersonalAccessResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "copyPersonalAccess failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllLicenses(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllLicensesResult = GetAllLicensesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllLicenses failed: unknown result"));
                }
            }
        }
    }
    public recv_getCountAllLicenses(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetCountAllLicensesResult = GetCountAllLicensesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getCountAllLicenses failed: unknown result"));
                }
            }
        }
    }
    public recv_uploadLicenses(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: UploadLicensesResult = UploadLicensesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "uploadLicenses failed: unknown result"));
                }
            }
        }
    }
    public recv_removeLicenses(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveLicensesResult = RemoveLicensesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeLicenses failed: unknown result"));
                }
            }
        }
    }
    public recv_updateLicense(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: UpdateLicenseResult = UpdateLicenseResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "updateLicense failed: unknown result"));
                }
            }
        }
    }
    public recv_releaseLicence(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ReleaseLicenceResult = ReleaseLicenceResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "releaseLicence failed: unknown result"));
                }
            }
        }
    }
    public recv_getLicenseModulePage(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetLicenseModulePageResult = GetLicenseModulePageResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getLicenseModulePage failed: unknown result"));
                }
            }
        }
    }
    public recv_uploadLicenseModule(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: UploadLicenseModuleResult = UploadLicenseModuleResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "uploadLicenseModule failed: unknown result"));
                }
            }
        }
    }
    public recv_removeLicenseModule(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveLicenseModuleResult = RemoveLicenseModuleResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeLicenseModule failed: unknown result"));
                }
            }
        }
    }
    public recv_createOrUpdate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateOrUpdateResult = CreateOrUpdateResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createOrUpdate failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllCharMatchingDictionaries(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllCharMatchingDictionariesResult = GetAllCharMatchingDictionariesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllCharMatchingDictionaries failed: unknown result"));
                }
            }
        }
    }
    public recv_deleteCharMatchingDictionary(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteCharMatchingDictionaryResult = DeleteCharMatchingDictionaryResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteCharMatchingDictionary failed: unknown result"));
                }
            }
        }
    }
    public recv_getTranslations(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetTranslationsResult = GetTranslationsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getTranslations failed: unknown result"));
                }
            }
        }
    }
    public recv_setTranslations(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: SetTranslationsResult = SetTranslationsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "setTranslations failed: unknown result"));
                }
            }
        }
    }
    public recv_getDroolLogFile(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetDroolLogFileResult = GetDroolLogFileResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getDroolLogFile failed: unknown result"));
                }
            }
        }
    }
    public recv_cryptValue(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CryptValueResult = CryptValueResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "cryptValue failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllJobTasks(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllJobTasksResult = GetAllJobTasksResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllJobTasks failed: unknown result"));
                }
            }
        }
    }
    public recv_getCountAllJobTasks(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetCountAllJobTasksResult = GetCountAllJobTasksResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getCountAllJobTasks failed: unknown result"));
                }
            }
        }
    }
    public recv_deleteJobTask(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: DeleteJobTaskResult = DeleteJobTaskResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "deleteJobTask failed: unknown result"));
                }
            }
        }
    }
    public recv_rebuildAttachment(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RebuildAttachmentResult = RebuildAttachmentResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "rebuildAttachment failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllUserContentItems(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllUserContentItemsResult = GetAllUserContentItemsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllUserContentItems failed: unknown result"));
                }
            }
        }
    }
    public recv_changeUserContentItems(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeUserContentItemsResult = ChangeUserContentItemsResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeUserContentItems failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllUserContentHolders(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllUserContentHoldersResult = GetAllUserContentHoldersResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllUserContentHolders failed: unknown result"));
                }
            }
        }
    }
    public recv_changeUserContentHolders(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ChangeUserContentHoldersResult = ChangeUserContentHoldersResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "changeUserContentHolders failed: unknown result"));
                }
            }
        }
    }
    public recv_removeLicensesEx(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveLicensesExResult = RemoveLicensesExResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeLicensesEx failed: unknown result"));
                }
            }
        }
    }
    public recv_getLicenseForUser(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetLicenseForUserResult = GetLicenseForUserResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getLicenseForUser failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllowedRolesForLicense(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllowedRolesForLicenseResult = GetAllowedRolesForLicenseResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllowedRolesForLicense failed: unknown result"));
                }
            }
        }
    }
    public recv_assignLicenseToUser(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: AssignLicenseToUserResult = AssignLicenseToUserResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "assignLicenseToUser failed: unknown result"));
                }
            }
        }
    }
    public recv_executeCustomQuery(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: ExecuteCustomQueryResult = ExecuteCustomQueryResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "executeCustomQuery failed: unknown result"));
                }
            }
        }
    }
    public recv_createOrUpdateUsers(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateOrUpdateUsersResult = CreateOrUpdateUsersResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createOrUpdateUsers failed: unknown result"));
                }
            }
        }
    }
}
export interface IHandler {
    getAvailableFileStorageList(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Array<__ROOT_NAMESPACE__.AvailableFileStorage> | Promise<Array<__ROOT_NAMESPACE__.AvailableFileStorage>>;
    createOrUpdateFileStorage(token: string, fileStorage: __ROOT_NAMESPACE__.FileStorage, password: string, accountsToAdd: Array<__ROOT_NAMESPACE__.Account>, accountsToRemove: Array<__ROOT_NAMESPACE__.Account>): __ROOT_NAMESPACE__.FileStorage | Promise<__ROOT_NAMESPACE__.FileStorage>;
    getAllFileStorages(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Array<__ROOT_NAMESPACE__.FileStorage> | Promise<Array<__ROOT_NAMESPACE__.FileStorage>>;
    getCountAllFileStorages(token: string, filter: __ROOT_NAMESPACE__.KazFilter): number | Promise<number>;
    removeFileStorages(token: string, fileStorageIds: Array<string>, password: string): boolean | Promise<boolean>;
    moveAttachment(token: string, docId: string, fileStorageId: string, onlyLatest: boolean): boolean | Promise<boolean>;
    createOrUpdateNews(token: string, news: __ROOT_NAMESPACE__.News, accountIDsToAdd: Set<string>, accountIDsToRemove: Set<string>): __ROOT_NAMESPACE__.News | Promise<__ROOT_NAMESPACE__.News>;
    removeNews(token: string, newsId: string): boolean | Promise<boolean>;
    getAllExternalModules(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Array<ExternalModule.ExternalModule> | Promise<Array<ExternalModule.ExternalModule>>;
    getCountAllExternalModules(token: string, filter: __ROOT_NAMESPACE__.KazFilter): number | Promise<number>;
    createOrUpdateExternalModule(token: string, externalModule: ExternalModule.ExternalModule, userLoginForNewRegistration: string, secretKey: string, addAccountIds: Set<string>, deleteAccountIds: Set<string>): ExternalModule.ExternalModule | Promise<ExternalModule.ExternalModule>;
    refreshExternalModule(token: string, extModuleId: string, removeDeletedStages: boolean): ExternalModule.ExternalModule | Promise<ExternalModule.ExternalModule>;
    removeExternalModule(token: string, extModuleId: string, password: string): boolean | Promise<boolean>;
    pingExternalModule(token: string, extModuleId: string): boolean | Promise<boolean>;
    pongExternalModule(token: string, extModuleCheckValue: string): boolean | Promise<boolean>;
    getAllDocumentAttachments(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Array<__ROOT_NAMESPACE__.Attachment> | Promise<Array<__ROOT_NAMESPACE__.Attachment>>;
    getAllFilledDocumentPatternStages(token: string, fillDocPatternId: string, filter: __ROOT_NAMESPACE__.KazFilter): Array<__ROOT_NAMESPACE__.DocumentPatternStage> | Promise<Array<__ROOT_NAMESPACE__.DocumentPatternStage>>;
    resetDocumentForceMoveError(token: string, documentId: string): number | Promise<number>;
    changeExecutorForPatternStages(token: string, patternIds: Array<string>, userOrGroup: __ROOT_NAMESPACE__.UserOrGroup, usersOrGroups: Array<__ROOT_NAMESPACE__.UserOrGroup>): boolean | Promise<boolean>;
    setUserPublicKey(token: string, userId: string, publicKey: string, password: string): string | Promise<string>;
    removeUserPublicKey(token: string, keyId: string, password: string): boolean | Promise<boolean>;
    getAllUsersRelativeToAccount(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Array<UserAcc.UserAcc> | Promise<Array<UserAcc.UserAcc>>;
    getCountAllUsersRelativeToAccount(token: string, filter: __ROOT_NAMESPACE__.KazFilter): number | Promise<number>;
    changeUserAccounts(token: string, userId: string, accountIdsToAdd: Set<string>, accountIdsToRemove: Set<string>, accountMainId: string): boolean | Promise<boolean>;
    runScheduler(token: string, oName: string, wait: boolean): boolean | Promise<boolean>;
    changeEncryptKey(token: string, key: string, accountId: string, password: string): boolean | Promise<boolean>;
    getAllUsersExt(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Array<UserExt.UserExt> | Promise<Array<UserExt.UserExt>>;
    getCountAllUsersExt(token: string, filter: __ROOT_NAMESPACE__.KazFilter): number | Promise<number>;
    getAllUserNotifications(token: string, userId: string, unreadOnly: boolean, filter: __ROOT_NAMESPACE__.KazFilter): Array<__ROOT_NAMESPACE__.NotificationQueue> | Promise<Array<__ROOT_NAMESPACE__.NotificationQueue>>;
    getAllNotifications(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Array<__ROOT_NAMESPACE__.NotificationQueue> | Promise<Array<__ROOT_NAMESPACE__.NotificationQueue>>;
    moveDocumentOnOtherPatternStage(token: string, documentId: string, stageId: string, resetMoveError: boolean): boolean | Promise<boolean>;
    resendDocumentToExternalModule(token: string, documentId: string, accessPolicy: __ROOT_NAMESPACE__.DocumentAccessPolicy): boolean | Promise<boolean>;
    getAllSessions(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Array<__ROOT_NAMESPACE__.AuthSession> | Promise<Array<__ROOT_NAMESPACE__.AuthSession>>;
    getCountAllSessions(token: string, filter: __ROOT_NAMESPACE__.KazFilter): number | Promise<number>;
    confirmUserPublicKey(token: string, id: string, confirm: boolean): boolean | Promise<boolean>;
    closeSession(token: string, sessionId: string): boolean | Promise<boolean>;
    copyPersonalAccess(token: string, copyPersonalAccessSettings: CopyPersonalAccessSettings.CopyPersonalAccessSettings): boolean | Promise<boolean>;
    getAllLicenses(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Array<License.License> | Promise<Array<License.License>>;
    getCountAllLicenses(token: string, filter: __ROOT_NAMESPACE__.KazFilter): number | Promise<number>;
    uploadLicenses(token: string, fileContentBytes: Buffer, accountGroup: __ROOT_NAMESPACE__.AccountGroup, account: __ROOT_NAMESPACE__.Account, autoAssignment: boolean, autoAssignmentOrder: number): Array<License.License> | Promise<Array<License.License>>;
    removeLicenses(token: string, lkeys: Array<string>): boolean | Promise<boolean>;
    updateLicense(token: string, license: License.License): License.License | Promise<License.License>;
    releaseLicence(token: string, userId: string, cancelAutoAssignment: boolean): boolean | Promise<boolean>;
    getLicenseModulePage(token: string, filter: __ROOT_NAMESPACE__.KazFilter): LicenseModulePage.LicenseModulePage | Promise<LicenseModulePage.LicenseModulePage>;
    uploadLicenseModule(token: string, fileContentBytes: Buffer): LicenseModule.LicenseModule | Promise<LicenseModule.LicenseModule>;
    removeLicenseModule(token: string, id: string): boolean | Promise<boolean>;
    createOrUpdate(token: string, dictionary: CharMatchingDictionary.CharMatchingDictionary): CharMatchingDictionary.CharMatchingDictionary | Promise<CharMatchingDictionary.CharMatchingDictionary>;
    getAllCharMatchingDictionaries(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Array<CharMatchingDictionary.CharMatchingDictionary> | Promise<Array<CharMatchingDictionary.CharMatchingDictionary>>;
    deleteCharMatchingDictionary(token: string, dictionary: string): boolean | Promise<boolean>;
    getTranslations(token: string, langCode: string): Buffer | Promise<Buffer>;
    setTranslations(token: string, langCode: string, langFile: Buffer): boolean | Promise<boolean>;
    getDroolLogFile(token: string, docId: string, policy: __ROOT_NAMESPACE__.DocumentAccessPolicy): Buffer | Promise<Buffer>;
    cryptValue(token: string, value: string): string | Promise<string>;
    getAllJobTasks(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Array<JobTask.JobTask> | Promise<Array<JobTask.JobTask>>;
    getCountAllJobTasks(token: string, filter: __ROOT_NAMESPACE__.KazFilter): number | Promise<number>;
    deleteJobTask(token: string, jobTaskId: string): boolean | Promise<boolean>;
    rebuildAttachment(token: string, attachmentId: string): boolean | Promise<boolean>;
    getAllUserContentItems(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Array<__ROOT_NAMESPACE__.ContentItem> | Promise<Array<__ROOT_NAMESPACE__.ContentItem>>;
    changeUserContentItems(token: string, contentItems: Array<__ROOT_NAMESPACE__.ContentItem>): Array<__ROOT_NAMESPACE__.ContentItem> | Promise<Array<__ROOT_NAMESPACE__.ContentItem>>;
    getAllUserContentHolders(token: string, filter: __ROOT_NAMESPACE__.KazFilter): Array<__ROOT_NAMESPACE__.ContentHolder> | Promise<Array<__ROOT_NAMESPACE__.ContentHolder>>;
    changeUserContentHolders(token: string, toUpdate: Array<__ROOT_NAMESPACE__.ContentHolder>, toRemoveIds: Array<string>): Array<__ROOT_NAMESPACE__.ContentHolder> | Promise<Array<__ROOT_NAMESPACE__.ContentHolder>>;
    removeLicensesEx(token: string, accountGroupId: string, accountId: string, dateFrom: Int64, dateTo: Int64): boolean | Promise<boolean>;
    getLicenseForUser(token: string, userId: string): License.License | Promise<License.License>;
    getAllowedRolesForLicense(token: string, licenseKey: string): Set<string> | Promise<Set<string>>;
    assignLicenseToUser(token: string, licenseKey: string, userId: string): License.License | Promise<License.License>;
    executeCustomQuery(token: string, query: string): Map<string, string> | Promise<Map<string, string>>;
    createOrUpdateUsers(token: string, users: Array<__ROOT_NAMESPACE__.UserOrGroup>, options: UserOptions.UserOptions): Array<string> | Promise<Array<string>>;
}
export class Processor {
    public _handler: IHandler;
    constructor(handler: IHandler) {
        this._handler = handler;
    }
    public process(input: thrift.TProtocol, output: thrift.TProtocol): void {
        const metadata: thrift.TMessage = input.readMessageBegin();
        const fname: string = metadata.fname;
        const requestId: number = metadata.rseqid;
        const methodName: string = "process_" + fname;
        switch (methodName) {
            case "process_getAvailableFileStorageList": {
                this.process_getAvailableFileStorageList(requestId, input, output);
                return;
            }
            case "process_createOrUpdateFileStorage": {
                this.process_createOrUpdateFileStorage(requestId, input, output);
                return;
            }
            case "process_getAllFileStorages": {
                this.process_getAllFileStorages(requestId, input, output);
                return;
            }
            case "process_getCountAllFileStorages": {
                this.process_getCountAllFileStorages(requestId, input, output);
                return;
            }
            case "process_removeFileStorages": {
                this.process_removeFileStorages(requestId, input, output);
                return;
            }
            case "process_moveAttachment": {
                this.process_moveAttachment(requestId, input, output);
                return;
            }
            case "process_createOrUpdateNews": {
                this.process_createOrUpdateNews(requestId, input, output);
                return;
            }
            case "process_removeNews": {
                this.process_removeNews(requestId, input, output);
                return;
            }
            case "process_getAllExternalModules": {
                this.process_getAllExternalModules(requestId, input, output);
                return;
            }
            case "process_getCountAllExternalModules": {
                this.process_getCountAllExternalModules(requestId, input, output);
                return;
            }
            case "process_createOrUpdateExternalModule": {
                this.process_createOrUpdateExternalModule(requestId, input, output);
                return;
            }
            case "process_refreshExternalModule": {
                this.process_refreshExternalModule(requestId, input, output);
                return;
            }
            case "process_removeExternalModule": {
                this.process_removeExternalModule(requestId, input, output);
                return;
            }
            case "process_pingExternalModule": {
                this.process_pingExternalModule(requestId, input, output);
                return;
            }
            case "process_pongExternalModule": {
                this.process_pongExternalModule(requestId, input, output);
                return;
            }
            case "process_getAllDocumentAttachments": {
                this.process_getAllDocumentAttachments(requestId, input, output);
                return;
            }
            case "process_getAllFilledDocumentPatternStages": {
                this.process_getAllFilledDocumentPatternStages(requestId, input, output);
                return;
            }
            case "process_resetDocumentForceMoveError": {
                this.process_resetDocumentForceMoveError(requestId, input, output);
                return;
            }
            case "process_changeExecutorForPatternStages": {
                this.process_changeExecutorForPatternStages(requestId, input, output);
                return;
            }
            case "process_setUserPublicKey": {
                this.process_setUserPublicKey(requestId, input, output);
                return;
            }
            case "process_removeUserPublicKey": {
                this.process_removeUserPublicKey(requestId, input, output);
                return;
            }
            case "process_getAllUsersRelativeToAccount": {
                this.process_getAllUsersRelativeToAccount(requestId, input, output);
                return;
            }
            case "process_getCountAllUsersRelativeToAccount": {
                this.process_getCountAllUsersRelativeToAccount(requestId, input, output);
                return;
            }
            case "process_changeUserAccounts": {
                this.process_changeUserAccounts(requestId, input, output);
                return;
            }
            case "process_runScheduler": {
                this.process_runScheduler(requestId, input, output);
                return;
            }
            case "process_changeEncryptKey": {
                this.process_changeEncryptKey(requestId, input, output);
                return;
            }
            case "process_getAllUsersExt": {
                this.process_getAllUsersExt(requestId, input, output);
                return;
            }
            case "process_getCountAllUsersExt": {
                this.process_getCountAllUsersExt(requestId, input, output);
                return;
            }
            case "process_getAllUserNotifications": {
                this.process_getAllUserNotifications(requestId, input, output);
                return;
            }
            case "process_getAllNotifications": {
                this.process_getAllNotifications(requestId, input, output);
                return;
            }
            case "process_moveDocumentOnOtherPatternStage": {
                this.process_moveDocumentOnOtherPatternStage(requestId, input, output);
                return;
            }
            case "process_resendDocumentToExternalModule": {
                this.process_resendDocumentToExternalModule(requestId, input, output);
                return;
            }
            case "process_getAllSessions": {
                this.process_getAllSessions(requestId, input, output);
                return;
            }
            case "process_getCountAllSessions": {
                this.process_getCountAllSessions(requestId, input, output);
                return;
            }
            case "process_confirmUserPublicKey": {
                this.process_confirmUserPublicKey(requestId, input, output);
                return;
            }
            case "process_closeSession": {
                this.process_closeSession(requestId, input, output);
                return;
            }
            case "process_copyPersonalAccess": {
                this.process_copyPersonalAccess(requestId, input, output);
                return;
            }
            case "process_getAllLicenses": {
                this.process_getAllLicenses(requestId, input, output);
                return;
            }
            case "process_getCountAllLicenses": {
                this.process_getCountAllLicenses(requestId, input, output);
                return;
            }
            case "process_uploadLicenses": {
                this.process_uploadLicenses(requestId, input, output);
                return;
            }
            case "process_removeLicenses": {
                this.process_removeLicenses(requestId, input, output);
                return;
            }
            case "process_updateLicense": {
                this.process_updateLicense(requestId, input, output);
                return;
            }
            case "process_releaseLicence": {
                this.process_releaseLicence(requestId, input, output);
                return;
            }
            case "process_getLicenseModulePage": {
                this.process_getLicenseModulePage(requestId, input, output);
                return;
            }
            case "process_uploadLicenseModule": {
                this.process_uploadLicenseModule(requestId, input, output);
                return;
            }
            case "process_removeLicenseModule": {
                this.process_removeLicenseModule(requestId, input, output);
                return;
            }
            case "process_createOrUpdate": {
                this.process_createOrUpdate(requestId, input, output);
                return;
            }
            case "process_getAllCharMatchingDictionaries": {
                this.process_getAllCharMatchingDictionaries(requestId, input, output);
                return;
            }
            case "process_deleteCharMatchingDictionary": {
                this.process_deleteCharMatchingDictionary(requestId, input, output);
                return;
            }
            case "process_getTranslations": {
                this.process_getTranslations(requestId, input, output);
                return;
            }
            case "process_setTranslations": {
                this.process_setTranslations(requestId, input, output);
                return;
            }
            case "process_getDroolLogFile": {
                this.process_getDroolLogFile(requestId, input, output);
                return;
            }
            case "process_cryptValue": {
                this.process_cryptValue(requestId, input, output);
                return;
            }
            case "process_getAllJobTasks": {
                this.process_getAllJobTasks(requestId, input, output);
                return;
            }
            case "process_getCountAllJobTasks": {
                this.process_getCountAllJobTasks(requestId, input, output);
                return;
            }
            case "process_deleteJobTask": {
                this.process_deleteJobTask(requestId, input, output);
                return;
            }
            case "process_rebuildAttachment": {
                this.process_rebuildAttachment(requestId, input, output);
                return;
            }
            case "process_getAllUserContentItems": {
                this.process_getAllUserContentItems(requestId, input, output);
                return;
            }
            case "process_changeUserContentItems": {
                this.process_changeUserContentItems(requestId, input, output);
                return;
            }
            case "process_getAllUserContentHolders": {
                this.process_getAllUserContentHolders(requestId, input, output);
                return;
            }
            case "process_changeUserContentHolders": {
                this.process_changeUserContentHolders(requestId, input, output);
                return;
            }
            case "process_removeLicensesEx": {
                this.process_removeLicensesEx(requestId, input, output);
                return;
            }
            case "process_getLicenseForUser": {
                this.process_getLicenseForUser(requestId, input, output);
                return;
            }
            case "process_getAllowedRolesForLicense": {
                this.process_getAllowedRolesForLicense(requestId, input, output);
                return;
            }
            case "process_assignLicenseToUser": {
                this.process_assignLicenseToUser(requestId, input, output);
                return;
            }
            case "process_executeCustomQuery": {
                this.process_executeCustomQuery(requestId, input, output);
                return;
            }
            case "process_createOrUpdateUsers": {
                this.process_createOrUpdateUsers(requestId, input, output);
                return;
            }
            default: {
                input.skip(thrift.Thrift.Type.STRUCT);
                input.readMessageEnd();
                const errMessage = "Unknown function " + fname;
                const err = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                output.writeMessageBegin(fname, thrift.Thrift.MessageType.EXCEPTION, requestId);
                err.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        }
    }
    public process_getAvailableFileStorageList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<__ROOT_NAMESPACE__.AvailableFileStorage>>((resolve, reject): void => {
            try {
                const args: GetAvailableFileStorageListArgs = GetAvailableFileStorageListArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAvailableFileStorageList(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<__ROOT_NAMESPACE__.AvailableFileStorage>): void => {
            const result: GetAvailableFileStorageListResult = new GetAvailableFileStorageListResult({ success: data });
            output.writeMessageBegin("getAvailableFileStorageList", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAvailableFileStorageListResult = new GetAvailableFileStorageListResult({ validError: err });
                output.writeMessageBegin("getAvailableFileStorageList", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAvailableFileStorageListResult = new GetAvailableFileStorageListResult({ error: err });
                output.writeMessageBegin("getAvailableFileStorageList", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAvailableFileStorageList", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createOrUpdateFileStorage(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<__ROOT_NAMESPACE__.FileStorage>((resolve, reject): void => {
            try {
                const args: CreateOrUpdateFileStorageArgs = CreateOrUpdateFileStorageArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createOrUpdateFileStorage(args.token, args.fileStorage, args.password, args.accountsToAdd, args.accountsToRemove));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: __ROOT_NAMESPACE__.FileStorage): void => {
            const result: CreateOrUpdateFileStorageResult = new CreateOrUpdateFileStorageResult({ success: data });
            output.writeMessageBegin("createOrUpdateFileStorage", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: CreateOrUpdateFileStorageResult = new CreateOrUpdateFileStorageResult({ validError: err });
                output.writeMessageBegin("createOrUpdateFileStorage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: CreateOrUpdateFileStorageResult = new CreateOrUpdateFileStorageResult({ error: err });
                output.writeMessageBegin("createOrUpdateFileStorage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createOrUpdateFileStorage", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllFileStorages(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<__ROOT_NAMESPACE__.FileStorage>>((resolve, reject): void => {
            try {
                const args: GetAllFileStoragesArgs = GetAllFileStoragesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllFileStorages(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<__ROOT_NAMESPACE__.FileStorage>): void => {
            const result: GetAllFileStoragesResult = new GetAllFileStoragesResult({ success: data });
            output.writeMessageBegin("getAllFileStorages", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllFileStoragesResult = new GetAllFileStoragesResult({ validError: err });
                output.writeMessageBegin("getAllFileStorages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllFileStoragesResult = new GetAllFileStoragesResult({ error: err });
                output.writeMessageBegin("getAllFileStorages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllFileStorages", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getCountAllFileStorages(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<number>((resolve, reject): void => {
            try {
                const args: GetCountAllFileStoragesArgs = GetCountAllFileStoragesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getCountAllFileStorages(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): void => {
            const result: GetCountAllFileStoragesResult = new GetCountAllFileStoragesResult({ success: data });
            output.writeMessageBegin("getCountAllFileStorages", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetCountAllFileStoragesResult = new GetCountAllFileStoragesResult({ validError: err });
                output.writeMessageBegin("getCountAllFileStorages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetCountAllFileStoragesResult = new GetCountAllFileStoragesResult({ error: err });
                output.writeMessageBegin("getCountAllFileStorages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getCountAllFileStorages", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeFileStorages(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemoveFileStoragesArgs = RemoveFileStoragesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeFileStorages(args.token, args.fileStorageIds, args.password));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemoveFileStoragesResult = new RemoveFileStoragesResult({ success: data });
            output.writeMessageBegin("removeFileStorages", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: RemoveFileStoragesResult = new RemoveFileStoragesResult({ validError: err });
                output.writeMessageBegin("removeFileStorages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: RemoveFileStoragesResult = new RemoveFileStoragesResult({ error: err });
                output.writeMessageBegin("removeFileStorages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeFileStorages", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_moveAttachment(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: MoveAttachmentArgs = MoveAttachmentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.moveAttachment(args.token, args.docId, args.fileStorageId, args.onlyLatest));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: MoveAttachmentResult = new MoveAttachmentResult({ success: data });
            output.writeMessageBegin("moveAttachment", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: MoveAttachmentResult = new MoveAttachmentResult({ validError: err });
                output.writeMessageBegin("moveAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: MoveAttachmentResult = new MoveAttachmentResult({ error: err });
                output.writeMessageBegin("moveAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("moveAttachment", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createOrUpdateNews(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<__ROOT_NAMESPACE__.News>((resolve, reject): void => {
            try {
                const args: CreateOrUpdateNewsArgs = CreateOrUpdateNewsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createOrUpdateNews(args.token, args.news, args.accountIDsToAdd, args.accountIDsToRemove));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: __ROOT_NAMESPACE__.News): void => {
            const result: CreateOrUpdateNewsResult = new CreateOrUpdateNewsResult({ success: data });
            output.writeMessageBegin("createOrUpdateNews", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: CreateOrUpdateNewsResult = new CreateOrUpdateNewsResult({ validError: err });
                output.writeMessageBegin("createOrUpdateNews", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: CreateOrUpdateNewsResult = new CreateOrUpdateNewsResult({ error: err });
                output.writeMessageBegin("createOrUpdateNews", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createOrUpdateNews", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeNews(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemoveNewsArgs = RemoveNewsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeNews(args.token, args.newsId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemoveNewsResult = new RemoveNewsResult({ success: data });
            output.writeMessageBegin("removeNews", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: RemoveNewsResult = new RemoveNewsResult({ validError: err });
                output.writeMessageBegin("removeNews", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: RemoveNewsResult = new RemoveNewsResult({ error: err });
                output.writeMessageBegin("removeNews", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeNews", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllExternalModules(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<ExternalModule.ExternalModule>>((resolve, reject): void => {
            try {
                const args: GetAllExternalModulesArgs = GetAllExternalModulesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllExternalModules(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<ExternalModule.ExternalModule>): void => {
            const result: GetAllExternalModulesResult = new GetAllExternalModulesResult({ success: data });
            output.writeMessageBegin("getAllExternalModules", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllExternalModulesResult = new GetAllExternalModulesResult({ validError: err });
                output.writeMessageBegin("getAllExternalModules", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllExternalModulesResult = new GetAllExternalModulesResult({ error: err });
                output.writeMessageBegin("getAllExternalModules", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllExternalModules", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getCountAllExternalModules(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<number>((resolve, reject): void => {
            try {
                const args: GetCountAllExternalModulesArgs = GetCountAllExternalModulesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getCountAllExternalModules(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): void => {
            const result: GetCountAllExternalModulesResult = new GetCountAllExternalModulesResult({ success: data });
            output.writeMessageBegin("getCountAllExternalModules", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetCountAllExternalModulesResult = new GetCountAllExternalModulesResult({ validError: err });
                output.writeMessageBegin("getCountAllExternalModules", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetCountAllExternalModulesResult = new GetCountAllExternalModulesResult({ error: err });
                output.writeMessageBegin("getCountAllExternalModules", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getCountAllExternalModules", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createOrUpdateExternalModule(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<ExternalModule.ExternalModule>((resolve, reject): void => {
            try {
                const args: CreateOrUpdateExternalModuleArgs = CreateOrUpdateExternalModuleArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createOrUpdateExternalModule(args.token, args.externalModule, args.userLoginForNewRegistration, args.secretKey, args.addAccountIds, args.deleteAccountIds));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ExternalModule.ExternalModule): void => {
            const result: CreateOrUpdateExternalModuleResult = new CreateOrUpdateExternalModuleResult({ success: data });
            output.writeMessageBegin("createOrUpdateExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: CreateOrUpdateExternalModuleResult = new CreateOrUpdateExternalModuleResult({ validError: err });
                output.writeMessageBegin("createOrUpdateExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: CreateOrUpdateExternalModuleResult = new CreateOrUpdateExternalModuleResult({ error: err });
                output.writeMessageBegin("createOrUpdateExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createOrUpdateExternalModule", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_refreshExternalModule(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<ExternalModule.ExternalModule>((resolve, reject): void => {
            try {
                const args: RefreshExternalModuleArgs = RefreshExternalModuleArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.refreshExternalModule(args.token, args.extModuleId, args.removeDeletedStages));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: ExternalModule.ExternalModule): void => {
            const result: RefreshExternalModuleResult = new RefreshExternalModuleResult({ success: data });
            output.writeMessageBegin("refreshExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: RefreshExternalModuleResult = new RefreshExternalModuleResult({ validError: err });
                output.writeMessageBegin("refreshExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: RefreshExternalModuleResult = new RefreshExternalModuleResult({ error: err });
                output.writeMessageBegin("refreshExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("refreshExternalModule", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeExternalModule(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemoveExternalModuleArgs = RemoveExternalModuleArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeExternalModule(args.token, args.extModuleId, args.password));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemoveExternalModuleResult = new RemoveExternalModuleResult({ success: data });
            output.writeMessageBegin("removeExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: RemoveExternalModuleResult = new RemoveExternalModuleResult({ validError: err });
                output.writeMessageBegin("removeExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: RemoveExternalModuleResult = new RemoveExternalModuleResult({ error: err });
                output.writeMessageBegin("removeExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeExternalModule", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_pingExternalModule(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: PingExternalModuleArgs = PingExternalModuleArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.pingExternalModule(args.token, args.extModuleId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: PingExternalModuleResult = new PingExternalModuleResult({ success: data });
            output.writeMessageBegin("pingExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: PingExternalModuleResult = new PingExternalModuleResult({ validError: err });
                output.writeMessageBegin("pingExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: PingExternalModuleResult = new PingExternalModuleResult({ error: err });
                output.writeMessageBegin("pingExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("pingExternalModule", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_pongExternalModule(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: PongExternalModuleArgs = PongExternalModuleArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.pongExternalModule(args.token, args.extModuleCheckValue));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: PongExternalModuleResult = new PongExternalModuleResult({ success: data });
            output.writeMessageBegin("pongExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: PongExternalModuleResult = new PongExternalModuleResult({ validError: err });
                output.writeMessageBegin("pongExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: PongExternalModuleResult = new PongExternalModuleResult({ error: err });
                output.writeMessageBegin("pongExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("pongExternalModule", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllDocumentAttachments(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<__ROOT_NAMESPACE__.Attachment>>((resolve, reject): void => {
            try {
                const args: GetAllDocumentAttachmentsArgs = GetAllDocumentAttachmentsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllDocumentAttachments(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<__ROOT_NAMESPACE__.Attachment>): void => {
            const result: GetAllDocumentAttachmentsResult = new GetAllDocumentAttachmentsResult({ success: data });
            output.writeMessageBegin("getAllDocumentAttachments", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllDocumentAttachmentsResult = new GetAllDocumentAttachmentsResult({ validError: err });
                output.writeMessageBegin("getAllDocumentAttachments", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllDocumentAttachmentsResult = new GetAllDocumentAttachmentsResult({ error: err });
                output.writeMessageBegin("getAllDocumentAttachments", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllDocumentAttachments", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllFilledDocumentPatternStages(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<__ROOT_NAMESPACE__.DocumentPatternStage>>((resolve, reject): void => {
            try {
                const args: GetAllFilledDocumentPatternStagesArgs = GetAllFilledDocumentPatternStagesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllFilledDocumentPatternStages(args.token, args.fillDocPatternId, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<__ROOT_NAMESPACE__.DocumentPatternStage>): void => {
            const result: GetAllFilledDocumentPatternStagesResult = new GetAllFilledDocumentPatternStagesResult({ success: data });
            output.writeMessageBegin("getAllFilledDocumentPatternStages", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllFilledDocumentPatternStagesResult = new GetAllFilledDocumentPatternStagesResult({ validError: err });
                output.writeMessageBegin("getAllFilledDocumentPatternStages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllFilledDocumentPatternStagesResult = new GetAllFilledDocumentPatternStagesResult({ error: err });
                output.writeMessageBegin("getAllFilledDocumentPatternStages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllFilledDocumentPatternStages", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_resetDocumentForceMoveError(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<number>((resolve, reject): void => {
            try {
                const args: ResetDocumentForceMoveErrorArgs = ResetDocumentForceMoveErrorArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.resetDocumentForceMoveError(args.token, args.documentId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): void => {
            const result: ResetDocumentForceMoveErrorResult = new ResetDocumentForceMoveErrorResult({ success: data });
            output.writeMessageBegin("resetDocumentForceMoveError", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: ResetDocumentForceMoveErrorResult = new ResetDocumentForceMoveErrorResult({ validError: err });
                output.writeMessageBegin("resetDocumentForceMoveError", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: ResetDocumentForceMoveErrorResult = new ResetDocumentForceMoveErrorResult({ error: err });
                output.writeMessageBegin("resetDocumentForceMoveError", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("resetDocumentForceMoveError", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeExecutorForPatternStages(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeExecutorForPatternStagesArgs = ChangeExecutorForPatternStagesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeExecutorForPatternStages(args.token, args.patternIds, args.userOrGroup, args.usersOrGroups));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeExecutorForPatternStagesResult = new ChangeExecutorForPatternStagesResult({ success: data });
            output.writeMessageBegin("changeExecutorForPatternStages", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: ChangeExecutorForPatternStagesResult = new ChangeExecutorForPatternStagesResult({ validError: err });
                output.writeMessageBegin("changeExecutorForPatternStages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: ChangeExecutorForPatternStagesResult = new ChangeExecutorForPatternStagesResult({ error: err });
                output.writeMessageBegin("changeExecutorForPatternStages", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeExecutorForPatternStages", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_setUserPublicKey(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: SetUserPublicKeyArgs = SetUserPublicKeyArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setUserPublicKey(args.token, args.userId, args.publicKey, args.password));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: SetUserPublicKeyResult = new SetUserPublicKeyResult({ success: data });
            output.writeMessageBegin("setUserPublicKey", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: SetUserPublicKeyResult = new SetUserPublicKeyResult({ validError: err });
                output.writeMessageBegin("setUserPublicKey", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: SetUserPublicKeyResult = new SetUserPublicKeyResult({ error: err });
                output.writeMessageBegin("setUserPublicKey", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("setUserPublicKey", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeUserPublicKey(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemoveUserPublicKeyArgs = RemoveUserPublicKeyArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeUserPublicKey(args.token, args.keyId, args.password));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemoveUserPublicKeyResult = new RemoveUserPublicKeyResult({ success: data });
            output.writeMessageBegin("removeUserPublicKey", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: RemoveUserPublicKeyResult = new RemoveUserPublicKeyResult({ validError: err });
                output.writeMessageBegin("removeUserPublicKey", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: RemoveUserPublicKeyResult = new RemoveUserPublicKeyResult({ error: err });
                output.writeMessageBegin("removeUserPublicKey", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeUserPublicKey", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllUsersRelativeToAccount(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<UserAcc.UserAcc>>((resolve, reject): void => {
            try {
                const args: GetAllUsersRelativeToAccountArgs = GetAllUsersRelativeToAccountArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllUsersRelativeToAccount(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<UserAcc.UserAcc>): void => {
            const result: GetAllUsersRelativeToAccountResult = new GetAllUsersRelativeToAccountResult({ success: data });
            output.writeMessageBegin("getAllUsersRelativeToAccount", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllUsersRelativeToAccountResult = new GetAllUsersRelativeToAccountResult({ validError: err });
                output.writeMessageBegin("getAllUsersRelativeToAccount", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllUsersRelativeToAccountResult = new GetAllUsersRelativeToAccountResult({ error: err });
                output.writeMessageBegin("getAllUsersRelativeToAccount", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllUsersRelativeToAccount", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getCountAllUsersRelativeToAccount(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<number>((resolve, reject): void => {
            try {
                const args: GetCountAllUsersRelativeToAccountArgs = GetCountAllUsersRelativeToAccountArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getCountAllUsersRelativeToAccount(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): void => {
            const result: GetCountAllUsersRelativeToAccountResult = new GetCountAllUsersRelativeToAccountResult({ success: data });
            output.writeMessageBegin("getCountAllUsersRelativeToAccount", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetCountAllUsersRelativeToAccountResult = new GetCountAllUsersRelativeToAccountResult({ validError: err });
                output.writeMessageBegin("getCountAllUsersRelativeToAccount", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetCountAllUsersRelativeToAccountResult = new GetCountAllUsersRelativeToAccountResult({ error: err });
                output.writeMessageBegin("getCountAllUsersRelativeToAccount", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getCountAllUsersRelativeToAccount", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeUserAccounts(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeUserAccountsArgs = ChangeUserAccountsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeUserAccounts(args.token, args.userId, args.accountIdsToAdd, args.accountIdsToRemove, args.accountMainId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeUserAccountsResult = new ChangeUserAccountsResult({ success: data });
            output.writeMessageBegin("changeUserAccounts", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: ChangeUserAccountsResult = new ChangeUserAccountsResult({ validError: err });
                output.writeMessageBegin("changeUserAccounts", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: ChangeUserAccountsResult = new ChangeUserAccountsResult({ error: err });
                output.writeMessageBegin("changeUserAccounts", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeUserAccounts", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_runScheduler(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RunSchedulerArgs = RunSchedulerArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.runScheduler(args.token, args.oName, args.wait));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RunSchedulerResult = new RunSchedulerResult({ success: data });
            output.writeMessageBegin("runScheduler", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: RunSchedulerResult = new RunSchedulerResult({ validError: err });
                output.writeMessageBegin("runScheduler", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: RunSchedulerResult = new RunSchedulerResult({ error: err });
                output.writeMessageBegin("runScheduler", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("runScheduler", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeEncryptKey(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ChangeEncryptKeyArgs = ChangeEncryptKeyArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeEncryptKey(args.token, args.key, args.accountId, args.password));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ChangeEncryptKeyResult = new ChangeEncryptKeyResult({ success: data });
            output.writeMessageBegin("changeEncryptKey", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: ChangeEncryptKeyResult = new ChangeEncryptKeyResult({ validError: err });
                output.writeMessageBegin("changeEncryptKey", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: ChangeEncryptKeyResult = new ChangeEncryptKeyResult({ error: err });
                output.writeMessageBegin("changeEncryptKey", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeEncryptKey", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllUsersExt(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<UserExt.UserExt>>((resolve, reject): void => {
            try {
                const args: GetAllUsersExtArgs = GetAllUsersExtArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllUsersExt(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<UserExt.UserExt>): void => {
            const result: GetAllUsersExtResult = new GetAllUsersExtResult({ success: data });
            output.writeMessageBegin("getAllUsersExt", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllUsersExtResult = new GetAllUsersExtResult({ validError: err });
                output.writeMessageBegin("getAllUsersExt", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllUsersExtResult = new GetAllUsersExtResult({ error: err });
                output.writeMessageBegin("getAllUsersExt", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllUsersExt", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getCountAllUsersExt(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<number>((resolve, reject): void => {
            try {
                const args: GetCountAllUsersExtArgs = GetCountAllUsersExtArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getCountAllUsersExt(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): void => {
            const result: GetCountAllUsersExtResult = new GetCountAllUsersExtResult({ success: data });
            output.writeMessageBegin("getCountAllUsersExt", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetCountAllUsersExtResult = new GetCountAllUsersExtResult({ validError: err });
                output.writeMessageBegin("getCountAllUsersExt", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetCountAllUsersExtResult = new GetCountAllUsersExtResult({ error: err });
                output.writeMessageBegin("getCountAllUsersExt", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getCountAllUsersExt", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllUserNotifications(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<__ROOT_NAMESPACE__.NotificationQueue>>((resolve, reject): void => {
            try {
                const args: GetAllUserNotificationsArgs = GetAllUserNotificationsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllUserNotifications(args.token, args.userId, args.unreadOnly, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<__ROOT_NAMESPACE__.NotificationQueue>): void => {
            const result: GetAllUserNotificationsResult = new GetAllUserNotificationsResult({ success: data });
            output.writeMessageBegin("getAllUserNotifications", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllUserNotificationsResult = new GetAllUserNotificationsResult({ validError: err });
                output.writeMessageBegin("getAllUserNotifications", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllUserNotificationsResult = new GetAllUserNotificationsResult({ error: err });
                output.writeMessageBegin("getAllUserNotifications", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllUserNotifications", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllNotifications(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<__ROOT_NAMESPACE__.NotificationQueue>>((resolve, reject): void => {
            try {
                const args: GetAllNotificationsArgs = GetAllNotificationsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllNotifications(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<__ROOT_NAMESPACE__.NotificationQueue>): void => {
            const result: GetAllNotificationsResult = new GetAllNotificationsResult({ success: data });
            output.writeMessageBegin("getAllNotifications", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllNotificationsResult = new GetAllNotificationsResult({ validError: err });
                output.writeMessageBegin("getAllNotifications", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllNotificationsResult = new GetAllNotificationsResult({ error: err });
                output.writeMessageBegin("getAllNotifications", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllNotifications", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_moveDocumentOnOtherPatternStage(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: MoveDocumentOnOtherPatternStageArgs = MoveDocumentOnOtherPatternStageArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.moveDocumentOnOtherPatternStage(args.token, args.documentId, args.stageId, args.resetMoveError));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: MoveDocumentOnOtherPatternStageResult = new MoveDocumentOnOtherPatternStageResult({ success: data });
            output.writeMessageBegin("moveDocumentOnOtherPatternStage", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: MoveDocumentOnOtherPatternStageResult = new MoveDocumentOnOtherPatternStageResult({ validError: err });
                output.writeMessageBegin("moveDocumentOnOtherPatternStage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: MoveDocumentOnOtherPatternStageResult = new MoveDocumentOnOtherPatternStageResult({ error: err });
                output.writeMessageBegin("moveDocumentOnOtherPatternStage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("moveDocumentOnOtherPatternStage", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_resendDocumentToExternalModule(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ResendDocumentToExternalModuleArgs = ResendDocumentToExternalModuleArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.resendDocumentToExternalModule(args.token, args.documentId, args.accessPolicy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ResendDocumentToExternalModuleResult = new ResendDocumentToExternalModuleResult({ success: data });
            output.writeMessageBegin("resendDocumentToExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: ResendDocumentToExternalModuleResult = new ResendDocumentToExternalModuleResult({ validError: err });
                output.writeMessageBegin("resendDocumentToExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: ResendDocumentToExternalModuleResult = new ResendDocumentToExternalModuleResult({ error: err });
                output.writeMessageBegin("resendDocumentToExternalModule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("resendDocumentToExternalModule", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllSessions(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<__ROOT_NAMESPACE__.AuthSession>>((resolve, reject): void => {
            try {
                const args: GetAllSessionsArgs = GetAllSessionsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllSessions(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<__ROOT_NAMESPACE__.AuthSession>): void => {
            const result: GetAllSessionsResult = new GetAllSessionsResult({ success: data });
            output.writeMessageBegin("getAllSessions", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllSessionsResult = new GetAllSessionsResult({ validError: err });
                output.writeMessageBegin("getAllSessions", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllSessionsResult = new GetAllSessionsResult({ error: err });
                output.writeMessageBegin("getAllSessions", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllSessions", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getCountAllSessions(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<number>((resolve, reject): void => {
            try {
                const args: GetCountAllSessionsArgs = GetCountAllSessionsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getCountAllSessions(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): void => {
            const result: GetCountAllSessionsResult = new GetCountAllSessionsResult({ success: data });
            output.writeMessageBegin("getCountAllSessions", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetCountAllSessionsResult = new GetCountAllSessionsResult({ validError: err });
                output.writeMessageBegin("getCountAllSessions", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetCountAllSessionsResult = new GetCountAllSessionsResult({ error: err });
                output.writeMessageBegin("getCountAllSessions", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getCountAllSessions", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_confirmUserPublicKey(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ConfirmUserPublicKeyArgs = ConfirmUserPublicKeyArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.confirmUserPublicKey(args.token, args.id, args.confirm));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ConfirmUserPublicKeyResult = new ConfirmUserPublicKeyResult({ success: data });
            output.writeMessageBegin("confirmUserPublicKey", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: ConfirmUserPublicKeyResult = new ConfirmUserPublicKeyResult({ validError: err });
                output.writeMessageBegin("confirmUserPublicKey", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: ConfirmUserPublicKeyResult = new ConfirmUserPublicKeyResult({ error: err });
                output.writeMessageBegin("confirmUserPublicKey", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("confirmUserPublicKey", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_closeSession(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: CloseSessionArgs = CloseSessionArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.closeSession(args.token, args.sessionId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: CloseSessionResult = new CloseSessionResult({ success: data });
            output.writeMessageBegin("closeSession", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: CloseSessionResult = new CloseSessionResult({ validError: err });
                output.writeMessageBegin("closeSession", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: CloseSessionResult = new CloseSessionResult({ error: err });
                output.writeMessageBegin("closeSession", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("closeSession", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_copyPersonalAccess(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: CopyPersonalAccessArgs = CopyPersonalAccessArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.copyPersonalAccess(args.token, args.copyPersonalAccessSettings));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: CopyPersonalAccessResult = new CopyPersonalAccessResult({ success: data });
            output.writeMessageBegin("copyPersonalAccess", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: CopyPersonalAccessResult = new CopyPersonalAccessResult({ validError: err });
                output.writeMessageBegin("copyPersonalAccess", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: CopyPersonalAccessResult = new CopyPersonalAccessResult({ error: err });
                output.writeMessageBegin("copyPersonalAccess", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("copyPersonalAccess", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllLicenses(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<License.License>>((resolve, reject): void => {
            try {
                const args: GetAllLicensesArgs = GetAllLicensesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllLicenses(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<License.License>): void => {
            const result: GetAllLicensesResult = new GetAllLicensesResult({ success: data });
            output.writeMessageBegin("getAllLicenses", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllLicensesResult = new GetAllLicensesResult({ validError: err });
                output.writeMessageBegin("getAllLicenses", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllLicensesResult = new GetAllLicensesResult({ error: err });
                output.writeMessageBegin("getAllLicenses", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllLicenses", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getCountAllLicenses(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<number>((resolve, reject): void => {
            try {
                const args: GetCountAllLicensesArgs = GetCountAllLicensesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getCountAllLicenses(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): void => {
            const result: GetCountAllLicensesResult = new GetCountAllLicensesResult({ success: data });
            output.writeMessageBegin("getCountAllLicenses", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetCountAllLicensesResult = new GetCountAllLicensesResult({ validError: err });
                output.writeMessageBegin("getCountAllLicenses", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetCountAllLicensesResult = new GetCountAllLicensesResult({ error: err });
                output.writeMessageBegin("getCountAllLicenses", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getCountAllLicenses", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_uploadLicenses(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<License.License>>((resolve, reject): void => {
            try {
                const args: UploadLicensesArgs = UploadLicensesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.uploadLicenses(args.token, args.fileContentBytes, args.accountGroup, args.account, args.autoAssignment, args.autoAssignmentOrder));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<License.License>): void => {
            const result: UploadLicensesResult = new UploadLicensesResult({ success: data });
            output.writeMessageBegin("uploadLicenses", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: UploadLicensesResult = new UploadLicensesResult({ validError: err });
                output.writeMessageBegin("uploadLicenses", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: UploadLicensesResult = new UploadLicensesResult({ error: err });
                output.writeMessageBegin("uploadLicenses", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("uploadLicenses", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeLicenses(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemoveLicensesArgs = RemoveLicensesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeLicenses(args.token, args.lkeys));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemoveLicensesResult = new RemoveLicensesResult({ success: data });
            output.writeMessageBegin("removeLicenses", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: RemoveLicensesResult = new RemoveLicensesResult({ validError: err });
                output.writeMessageBegin("removeLicenses", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: RemoveLicensesResult = new RemoveLicensesResult({ error: err });
                output.writeMessageBegin("removeLicenses", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeLicenses", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_updateLicense(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<License.License>((resolve, reject): void => {
            try {
                const args: UpdateLicenseArgs = UpdateLicenseArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.updateLicense(args.token, args.license));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: License.License): void => {
            const result: UpdateLicenseResult = new UpdateLicenseResult({ success: data });
            output.writeMessageBegin("updateLicense", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: UpdateLicenseResult = new UpdateLicenseResult({ validError: err });
                output.writeMessageBegin("updateLicense", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: UpdateLicenseResult = new UpdateLicenseResult({ error: err });
                output.writeMessageBegin("updateLicense", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("updateLicense", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_releaseLicence(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: ReleaseLicenceArgs = ReleaseLicenceArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.releaseLicence(args.token, args.userId, args.cancelAutoAssignment));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: ReleaseLicenceResult = new ReleaseLicenceResult({ success: data });
            output.writeMessageBegin("releaseLicence", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: ReleaseLicenceResult = new ReleaseLicenceResult({ validError: err });
                output.writeMessageBegin("releaseLicence", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: ReleaseLicenceResult = new ReleaseLicenceResult({ error: err });
                output.writeMessageBegin("releaseLicence", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("releaseLicence", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getLicenseModulePage(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<LicenseModulePage.LicenseModulePage>((resolve, reject): void => {
            try {
                const args: GetLicenseModulePageArgs = GetLicenseModulePageArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getLicenseModulePage(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: LicenseModulePage.LicenseModulePage): void => {
            const result: GetLicenseModulePageResult = new GetLicenseModulePageResult({ success: data });
            output.writeMessageBegin("getLicenseModulePage", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetLicenseModulePageResult = new GetLicenseModulePageResult({ validError: err });
                output.writeMessageBegin("getLicenseModulePage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetLicenseModulePageResult = new GetLicenseModulePageResult({ error: err });
                output.writeMessageBegin("getLicenseModulePage", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getLicenseModulePage", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_uploadLicenseModule(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<LicenseModule.LicenseModule>((resolve, reject): void => {
            try {
                const args: UploadLicenseModuleArgs = UploadLicenseModuleArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.uploadLicenseModule(args.token, args.fileContentBytes));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: LicenseModule.LicenseModule): void => {
            const result: UploadLicenseModuleResult = new UploadLicenseModuleResult({ success: data });
            output.writeMessageBegin("uploadLicenseModule", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: UploadLicenseModuleResult = new UploadLicenseModuleResult({ validError: err });
                output.writeMessageBegin("uploadLicenseModule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: UploadLicenseModuleResult = new UploadLicenseModuleResult({ error: err });
                output.writeMessageBegin("uploadLicenseModule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("uploadLicenseModule", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeLicenseModule(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemoveLicenseModuleArgs = RemoveLicenseModuleArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeLicenseModule(args.token, args.id));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemoveLicenseModuleResult = new RemoveLicenseModuleResult({ success: data });
            output.writeMessageBegin("removeLicenseModule", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: RemoveLicenseModuleResult = new RemoveLicenseModuleResult({ validError: err });
                output.writeMessageBegin("removeLicenseModule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: RemoveLicenseModuleResult = new RemoveLicenseModuleResult({ error: err });
                output.writeMessageBegin("removeLicenseModule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeLicenseModule", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createOrUpdate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<CharMatchingDictionary.CharMatchingDictionary>((resolve, reject): void => {
            try {
                const args: CreateOrUpdateArgs = CreateOrUpdateArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createOrUpdate(args.token, args.dictionary));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: CharMatchingDictionary.CharMatchingDictionary): void => {
            const result: CreateOrUpdateResult = new CreateOrUpdateResult({ success: data });
            output.writeMessageBegin("createOrUpdate", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: CreateOrUpdateResult = new CreateOrUpdateResult({ validError: err });
                output.writeMessageBegin("createOrUpdate", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: CreateOrUpdateResult = new CreateOrUpdateResult({ error: err });
                output.writeMessageBegin("createOrUpdate", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createOrUpdate", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllCharMatchingDictionaries(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<CharMatchingDictionary.CharMatchingDictionary>>((resolve, reject): void => {
            try {
                const args: GetAllCharMatchingDictionariesArgs = GetAllCharMatchingDictionariesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllCharMatchingDictionaries(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<CharMatchingDictionary.CharMatchingDictionary>): void => {
            const result: GetAllCharMatchingDictionariesResult = new GetAllCharMatchingDictionariesResult({ success: data });
            output.writeMessageBegin("getAllCharMatchingDictionaries", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllCharMatchingDictionariesResult = new GetAllCharMatchingDictionariesResult({ validError: err });
                output.writeMessageBegin("getAllCharMatchingDictionaries", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllCharMatchingDictionariesResult = new GetAllCharMatchingDictionariesResult({ error: err });
                output.writeMessageBegin("getAllCharMatchingDictionaries", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllCharMatchingDictionaries", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_deleteCharMatchingDictionary(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: DeleteCharMatchingDictionaryArgs = DeleteCharMatchingDictionaryArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteCharMatchingDictionary(args.token, args.dictionary));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: DeleteCharMatchingDictionaryResult = new DeleteCharMatchingDictionaryResult({ success: data });
            output.writeMessageBegin("deleteCharMatchingDictionary", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: DeleteCharMatchingDictionaryResult = new DeleteCharMatchingDictionaryResult({ validError: err });
                output.writeMessageBegin("deleteCharMatchingDictionary", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: DeleteCharMatchingDictionaryResult = new DeleteCharMatchingDictionaryResult({ error: err });
                output.writeMessageBegin("deleteCharMatchingDictionary", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("deleteCharMatchingDictionary", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getTranslations(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Buffer>((resolve, reject): void => {
            try {
                const args: GetTranslationsArgs = GetTranslationsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getTranslations(args.token, args.langCode));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Buffer): void => {
            const result: GetTranslationsResult = new GetTranslationsResult({ success: data });
            output.writeMessageBegin("getTranslations", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetTranslationsResult = new GetTranslationsResult({ validError: err });
                output.writeMessageBegin("getTranslations", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetTranslationsResult = new GetTranslationsResult({ error: err });
                output.writeMessageBegin("getTranslations", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getTranslations", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_setTranslations(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: SetTranslationsArgs = SetTranslationsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.setTranslations(args.token, args.langCode, args.langFile));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: SetTranslationsResult = new SetTranslationsResult({ success: data });
            output.writeMessageBegin("setTranslations", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: SetTranslationsResult = new SetTranslationsResult({ validError: err });
                output.writeMessageBegin("setTranslations", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: SetTranslationsResult = new SetTranslationsResult({ error: err });
                output.writeMessageBegin("setTranslations", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("setTranslations", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getDroolLogFile(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Buffer>((resolve, reject): void => {
            try {
                const args: GetDroolLogFileArgs = GetDroolLogFileArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getDroolLogFile(args.token, args.docId, args.policy));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Buffer): void => {
            const result: GetDroolLogFileResult = new GetDroolLogFileResult({ success: data });
            output.writeMessageBegin("getDroolLogFile", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetDroolLogFileResult = new GetDroolLogFileResult({ validError: err });
                output.writeMessageBegin("getDroolLogFile", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetDroolLogFileResult = new GetDroolLogFileResult({ error: err });
                output.writeMessageBegin("getDroolLogFile", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getDroolLogFile", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_cryptValue(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: CryptValueArgs = CryptValueArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.cryptValue(args.token, args.value));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: CryptValueResult = new CryptValueResult({ success: data });
            output.writeMessageBegin("cryptValue", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: CryptValueResult = new CryptValueResult({ validError: err });
                output.writeMessageBegin("cryptValue", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: CryptValueResult = new CryptValueResult({ error: err });
                output.writeMessageBegin("cryptValue", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("cryptValue", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllJobTasks(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<JobTask.JobTask>>((resolve, reject): void => {
            try {
                const args: GetAllJobTasksArgs = GetAllJobTasksArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllJobTasks(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<JobTask.JobTask>): void => {
            const result: GetAllJobTasksResult = new GetAllJobTasksResult({ success: data });
            output.writeMessageBegin("getAllJobTasks", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllJobTasksResult = new GetAllJobTasksResult({ validError: err });
                output.writeMessageBegin("getAllJobTasks", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllJobTasksResult = new GetAllJobTasksResult({ error: err });
                output.writeMessageBegin("getAllJobTasks", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllJobTasks", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getCountAllJobTasks(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<number>((resolve, reject): void => {
            try {
                const args: GetCountAllJobTasksArgs = GetCountAllJobTasksArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getCountAllJobTasks(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): void => {
            const result: GetCountAllJobTasksResult = new GetCountAllJobTasksResult({ success: data });
            output.writeMessageBegin("getCountAllJobTasks", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetCountAllJobTasksResult = new GetCountAllJobTasksResult({ validError: err });
                output.writeMessageBegin("getCountAllJobTasks", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetCountAllJobTasksResult = new GetCountAllJobTasksResult({ error: err });
                output.writeMessageBegin("getCountAllJobTasks", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getCountAllJobTasks", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_deleteJobTask(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: DeleteJobTaskArgs = DeleteJobTaskArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.deleteJobTask(args.token, args.jobTaskId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: DeleteJobTaskResult = new DeleteJobTaskResult({ success: data });
            output.writeMessageBegin("deleteJobTask", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: DeleteJobTaskResult = new DeleteJobTaskResult({ validError: err });
                output.writeMessageBegin("deleteJobTask", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: DeleteJobTaskResult = new DeleteJobTaskResult({ error: err });
                output.writeMessageBegin("deleteJobTask", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("deleteJobTask", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_rebuildAttachment(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RebuildAttachmentArgs = RebuildAttachmentArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.rebuildAttachment(args.token, args.attachmentId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RebuildAttachmentResult = new RebuildAttachmentResult({ success: data });
            output.writeMessageBegin("rebuildAttachment", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: RebuildAttachmentResult = new RebuildAttachmentResult({ validError: err });
                output.writeMessageBegin("rebuildAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: RebuildAttachmentResult = new RebuildAttachmentResult({ error: err });
                output.writeMessageBegin("rebuildAttachment", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("rebuildAttachment", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllUserContentItems(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<__ROOT_NAMESPACE__.ContentItem>>((resolve, reject): void => {
            try {
                const args: GetAllUserContentItemsArgs = GetAllUserContentItemsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllUserContentItems(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<__ROOT_NAMESPACE__.ContentItem>): void => {
            const result: GetAllUserContentItemsResult = new GetAllUserContentItemsResult({ success: data });
            output.writeMessageBegin("getAllUserContentItems", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllUserContentItemsResult = new GetAllUserContentItemsResult({ validError: err });
                output.writeMessageBegin("getAllUserContentItems", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllUserContentItemsResult = new GetAllUserContentItemsResult({ error: err });
                output.writeMessageBegin("getAllUserContentItems", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllUserContentItems", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeUserContentItems(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<__ROOT_NAMESPACE__.ContentItem>>((resolve, reject): void => {
            try {
                const args: ChangeUserContentItemsArgs = ChangeUserContentItemsArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeUserContentItems(args.token, args.contentItems));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<__ROOT_NAMESPACE__.ContentItem>): void => {
            const result: ChangeUserContentItemsResult = new ChangeUserContentItemsResult({ success: data });
            output.writeMessageBegin("changeUserContentItems", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: ChangeUserContentItemsResult = new ChangeUserContentItemsResult({ validError: err });
                output.writeMessageBegin("changeUserContentItems", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: ChangeUserContentItemsResult = new ChangeUserContentItemsResult({ error: err });
                output.writeMessageBegin("changeUserContentItems", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeUserContentItems", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllUserContentHolders(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<__ROOT_NAMESPACE__.ContentHolder>>((resolve, reject): void => {
            try {
                const args: GetAllUserContentHoldersArgs = GetAllUserContentHoldersArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllUserContentHolders(args.token, args.filter));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<__ROOT_NAMESPACE__.ContentHolder>): void => {
            const result: GetAllUserContentHoldersResult = new GetAllUserContentHoldersResult({ success: data });
            output.writeMessageBegin("getAllUserContentHolders", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllUserContentHoldersResult = new GetAllUserContentHoldersResult({ validError: err });
                output.writeMessageBegin("getAllUserContentHolders", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllUserContentHoldersResult = new GetAllUserContentHoldersResult({ error: err });
                output.writeMessageBegin("getAllUserContentHolders", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllUserContentHolders", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_changeUserContentHolders(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<__ROOT_NAMESPACE__.ContentHolder>>((resolve, reject): void => {
            try {
                const args: ChangeUserContentHoldersArgs = ChangeUserContentHoldersArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.changeUserContentHolders(args.token, args.toUpdate, args.toRemoveIds));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<__ROOT_NAMESPACE__.ContentHolder>): void => {
            const result: ChangeUserContentHoldersResult = new ChangeUserContentHoldersResult({ success: data });
            output.writeMessageBegin("changeUserContentHolders", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: ChangeUserContentHoldersResult = new ChangeUserContentHoldersResult({ validError: err });
                output.writeMessageBegin("changeUserContentHolders", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: ChangeUserContentHoldersResult = new ChangeUserContentHoldersResult({ error: err });
                output.writeMessageBegin("changeUserContentHolders", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("changeUserContentHolders", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeLicensesEx(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemoveLicensesExArgs = RemoveLicensesExArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeLicensesEx(args.token, args.accountGroupId, args.accountId, args.dateFrom, args.dateTo));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemoveLicensesExResult = new RemoveLicensesExResult({ success: data });
            output.writeMessageBegin("removeLicensesEx", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: RemoveLicensesExResult = new RemoveLicensesExResult({ validError: err });
                output.writeMessageBegin("removeLicensesEx", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: RemoveLicensesExResult = new RemoveLicensesExResult({ error: err });
                output.writeMessageBegin("removeLicensesEx", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeLicensesEx", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getLicenseForUser(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<License.License>((resolve, reject): void => {
            try {
                const args: GetLicenseForUserArgs = GetLicenseForUserArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getLicenseForUser(args.token, args.userId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: License.License): void => {
            const result: GetLicenseForUserResult = new GetLicenseForUserResult({ success: data });
            output.writeMessageBegin("getLicenseForUser", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetLicenseForUserResult = new GetLicenseForUserResult({ validError: err });
                output.writeMessageBegin("getLicenseForUser", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetLicenseForUserResult = new GetLicenseForUserResult({ error: err });
                output.writeMessageBegin("getLicenseForUser", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getLicenseForUser", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllowedRolesForLicense(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Set<string>>((resolve, reject): void => {
            try {
                const args: GetAllowedRolesForLicenseArgs = GetAllowedRolesForLicenseArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllowedRolesForLicense(args.token, args.licenseKey));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Set<string>): void => {
            const result: GetAllowedRolesForLicenseResult = new GetAllowedRolesForLicenseResult({ success: data });
            output.writeMessageBegin("getAllowedRolesForLicense", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllowedRolesForLicenseResult = new GetAllowedRolesForLicenseResult({ validError: err });
                output.writeMessageBegin("getAllowedRolesForLicense", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllowedRolesForLicenseResult = new GetAllowedRolesForLicenseResult({ error: err });
                output.writeMessageBegin("getAllowedRolesForLicense", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllowedRolesForLicense", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_assignLicenseToUser(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<License.License>((resolve, reject): void => {
            try {
                const args: AssignLicenseToUserArgs = AssignLicenseToUserArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.assignLicenseToUser(args.token, args.licenseKey, args.userId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: License.License): void => {
            const result: AssignLicenseToUserResult = new AssignLicenseToUserResult({ success: data });
            output.writeMessageBegin("assignLicenseToUser", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: AssignLicenseToUserResult = new AssignLicenseToUserResult({ validError: err });
                output.writeMessageBegin("assignLicenseToUser", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: AssignLicenseToUserResult = new AssignLicenseToUserResult({ error: err });
                output.writeMessageBegin("assignLicenseToUser", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("assignLicenseToUser", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_executeCustomQuery(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Map<string, string>>((resolve, reject): void => {
            try {
                const args: ExecuteCustomQueryArgs = ExecuteCustomQueryArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.executeCustomQuery(args.token, args.query));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Map<string, string>): void => {
            const result: ExecuteCustomQueryResult = new ExecuteCustomQueryResult({ success: data });
            output.writeMessageBegin("executeCustomQuery", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: ExecuteCustomQueryResult = new ExecuteCustomQueryResult({ validError: err });
                output.writeMessageBegin("executeCustomQuery", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: ExecuteCustomQueryResult = new ExecuteCustomQueryResult({ error: err });
                output.writeMessageBegin("executeCustomQuery", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("executeCustomQuery", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createOrUpdateUsers(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<string>>((resolve, reject): void => {
            try {
                const args: CreateOrUpdateUsersArgs = CreateOrUpdateUsersArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createOrUpdateUsers(args.token, args.users, args.options));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<string>): void => {
            const result: CreateOrUpdateUsersResult = new CreateOrUpdateUsersResult({ success: data });
            output.writeMessageBegin("createOrUpdateUsers", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: CreateOrUpdateUsersResult = new CreateOrUpdateUsersResult({ validError: err });
                output.writeMessageBegin("createOrUpdateUsers", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: CreateOrUpdateUsersResult = new CreateOrUpdateUsersResult({ error: err });
                output.writeMessageBegin("createOrUpdateUsers", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createOrUpdateUsers", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
}
