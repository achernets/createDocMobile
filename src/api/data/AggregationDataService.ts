/* tslint:disable */
/* eslint-disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v3.7.6
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import * as thrift from "thrift";
import * as __ROOT_NAMESPACE__ from "./";
import * as AggregationDocumentData from "./AggregationDocumentData";
import * as Registry from "./Registry";
export interface IGetDocumentDataArgsArgs {
    token: string;
    documentId: string;
    requiredData: Set<__ROOT_NAMESPACE__.AggregationRequiredType>;
    policy: __ROOT_NAMESPACE__.DocumentAccessPolicy;
    decrypt: boolean;
    executorsPortion: number;
}
export class GetDocumentDataArgs {
    public token: string;
    public documentId: string;
    public requiredData: Set<__ROOT_NAMESPACE__.AggregationRequiredType>;
    public policy: __ROOT_NAMESPACE__.DocumentAccessPolicy;
    public decrypt: boolean;
    public executorsPortion: number;
    constructor(args: IGetDocumentDataArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.documentId != null) {
            this.documentId = args.documentId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[documentId] is unset!");
        }
        if (args != null && args.requiredData != null) {
            this.requiredData = args.requiredData;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[requiredData] is unset!");
        }
        if (args != null && args.policy != null) {
            this.policy = args.policy;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[policy] is unset!");
        }
        if (args != null && args.decrypt != null) {
            this.decrypt = args.decrypt;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[decrypt] is unset!");
        }
        if (args != null && args.executorsPortion != null) {
            this.executorsPortion = args.executorsPortion;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[executorsPortion] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentDataArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.documentId != null) {
            output.writeFieldBegin("documentId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.documentId);
            output.writeFieldEnd();
        }
        if (this.requiredData != null) {
            output.writeFieldBegin("requiredData", thrift.Thrift.Type.SET, 3);
            output.writeSetBegin(thrift.Thrift.Type.I32, this.requiredData.size);
            this.requiredData.forEach((value_1: __ROOT_NAMESPACE__.AggregationRequiredType): void => {
                output.writeI32(value_1);
            });
            output.writeSetEnd();
            output.writeFieldEnd();
        }
        if (this.policy != null) {
            output.writeFieldBegin("policy", thrift.Thrift.Type.STRUCT, 4);
            this.policy.write(output);
            output.writeFieldEnd();
        }
        if (this.decrypt != null) {
            output.writeFieldBegin("decrypt", thrift.Thrift.Type.BOOL, 5);
            output.writeBool(this.decrypt);
            output.writeFieldEnd();
        }
        if (this.executorsPortion != null) {
            output.writeFieldBegin("executorsPortion", thrift.Thrift.Type.I32, 6);
            output.writeI32(this.executorsPortion);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentDataArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_2: string = input.readString();
                        _args.token = value_2;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_3: string = input.readString();
                        _args.documentId = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.SET) {
                        const value_4: Set<__ROOT_NAMESPACE__.AggregationRequiredType> = new Set<__ROOT_NAMESPACE__.AggregationRequiredType>();
                        const metadata_1: thrift.TSet = input.readSetBegin();
                        const size_1: number = metadata_1.size;
                        for (let i_1: number = 0; i_1 < size_1; i_1++) {
                            const value_5: __ROOT_NAMESPACE__.AggregationRequiredType = input.readI32();
                            value_4.add(value_5);
                        }
                        input.readSetEnd();
                        _args.requiredData = value_4;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_6: __ROOT_NAMESPACE__.DocumentAccessPolicy = __ROOT_NAMESPACE__.DocumentAccessPolicy.read(input);
                        _args.policy = value_6;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 5:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_7: boolean = input.readBool();
                        _args.decrypt = value_7;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 6:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_8: number = input.readI32();
                        _args.executorsPortion = value_8;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.documentId !== undefined && _args.requiredData !== undefined && _args.policy !== undefined && _args.decrypt !== undefined && _args.executorsPortion !== undefined) {
            return new GetDocumentDataArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetDocumentDataArgs from input");
        }
    }
}
export interface IGetAllRegistriesArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
    forAdmin: boolean;
}
export class GetAllRegistriesArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    public forAdmin: boolean;
    constructor(args: IGetAllRegistriesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
        if (args != null && args.forAdmin != null) {
            this.forAdmin = args.forAdmin;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[forAdmin] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllRegistriesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        if (this.forAdmin != null) {
            output.writeFieldBegin("forAdmin", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.forAdmin);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllRegistriesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_9: string = input.readString();
                        _args.token = value_9;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_10: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_10;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_11: boolean = input.readBool();
                        _args.forAdmin = value_11;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined && _args.forAdmin !== undefined) {
            return new GetAllRegistriesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetAllRegistriesArgs from input");
        }
    }
}
export interface IGetCountAllRegistriesArgsArgs {
    token: string;
    filter: __ROOT_NAMESPACE__.KazFilter;
    forAdmin: boolean;
}
export class GetCountAllRegistriesArgs {
    public token: string;
    public filter: __ROOT_NAMESPACE__.KazFilter;
    public forAdmin: boolean;
    constructor(args: IGetCountAllRegistriesArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.filter != null) {
            this.filter = args.filter;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[filter] is unset!");
        }
        if (args != null && args.forAdmin != null) {
            this.forAdmin = args.forAdmin;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[forAdmin] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllRegistriesArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.filter != null) {
            output.writeFieldBegin("filter", thrift.Thrift.Type.STRUCT, 2);
            this.filter.write(output);
            output.writeFieldEnd();
        }
        if (this.forAdmin != null) {
            output.writeFieldBegin("forAdmin", thrift.Thrift.Type.BOOL, 3);
            output.writeBool(this.forAdmin);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllRegistriesArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_12: string = input.readString();
                        _args.token = value_12;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_13: __ROOT_NAMESPACE__.KazFilter = __ROOT_NAMESPACE__.KazFilter.read(input);
                        _args.filter = value_13;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_14: boolean = input.readBool();
                        _args.forAdmin = value_14;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.filter !== undefined && _args.forAdmin !== undefined) {
            return new GetCountAllRegistriesArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetCountAllRegistriesArgs from input");
        }
    }
}
export interface IGetRegistryByIdArgsArgs {
    token: string;
    id: string;
    requiredData: Set<__ROOT_NAMESPACE__.AggregationRequiredType>;
}
export class GetRegistryByIdArgs {
    public token: string;
    public id: string;
    public requiredData: Set<__ROOT_NAMESPACE__.AggregationRequiredType>;
    constructor(args: IGetRegistryByIdArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.id != null) {
            this.id = args.id;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[id] is unset!");
        }
        if (args != null && args.requiredData != null) {
            this.requiredData = args.requiredData;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[requiredData] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetRegistryByIdArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.id != null) {
            output.writeFieldBegin("id", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.id);
            output.writeFieldEnd();
        }
        if (this.requiredData != null) {
            output.writeFieldBegin("requiredData", thrift.Thrift.Type.SET, 3);
            output.writeSetBegin(thrift.Thrift.Type.I32, this.requiredData.size);
            this.requiredData.forEach((value_15: __ROOT_NAMESPACE__.AggregationRequiredType): void => {
                output.writeI32(value_15);
            });
            output.writeSetEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetRegistryByIdArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_16: string = input.readString();
                        _args.token = value_16;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_17: string = input.readString();
                        _args.id = value_17;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.SET) {
                        const value_18: Set<__ROOT_NAMESPACE__.AggregationRequiredType> = new Set<__ROOT_NAMESPACE__.AggregationRequiredType>();
                        const metadata_2: thrift.TSet = input.readSetBegin();
                        const size_2: number = metadata_2.size;
                        for (let i_2: number = 0; i_2 < size_2; i_2++) {
                            const value_19: __ROOT_NAMESPACE__.AggregationRequiredType = input.readI32();
                            value_18.add(value_19);
                        }
                        input.readSetEnd();
                        _args.requiredData = value_18;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.id !== undefined && _args.requiredData !== undefined) {
            return new GetRegistryByIdArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read GetRegistryByIdArgs from input");
        }
    }
}
export interface IRemoveRegistryArgsArgs {
    token: string;
    registryId: string;
}
export class RemoveRegistryArgs {
    public token: string;
    public registryId: string;
    constructor(args: IRemoveRegistryArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.registryId != null) {
            this.registryId = args.registryId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[registryId] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveRegistryArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.registryId != null) {
            output.writeFieldBegin("registryId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.registryId);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveRegistryArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_20: string = input.readString();
                        _args.token = value_20;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_21: string = input.readString();
                        _args.registryId = value_21;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.registryId !== undefined) {
            return new RemoveRegistryArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read RemoveRegistryArgs from input");
        }
    }
}
export interface ICreateOrUpdateRegistryArgsArgs {
    token: string;
    registry: Registry.Registry;
    userOrGroupList: Array<__ROOT_NAMESPACE__.UserOrGroup>;
    accountList: Array<__ROOT_NAMESPACE__.Account>;
}
export class CreateOrUpdateRegistryArgs {
    public token: string;
    public registry: Registry.Registry;
    public userOrGroupList: Array<__ROOT_NAMESPACE__.UserOrGroup>;
    public accountList: Array<__ROOT_NAMESPACE__.Account>;
    constructor(args: ICreateOrUpdateRegistryArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.registry != null) {
            this.registry = args.registry;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[registry] is unset!");
        }
        if (args != null && args.userOrGroupList != null) {
            this.userOrGroupList = args.userOrGroupList;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[userOrGroupList] is unset!");
        }
        if (args != null && args.accountList != null) {
            this.accountList = args.accountList;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[accountList] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateRegistryArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.registry != null) {
            output.writeFieldBegin("registry", thrift.Thrift.Type.STRUCT, 2);
            this.registry.write(output);
            output.writeFieldEnd();
        }
        if (this.userOrGroupList != null) {
            output.writeFieldBegin("userOrGroupList", thrift.Thrift.Type.LIST, 3);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.userOrGroupList.length);
            this.userOrGroupList.forEach((value_22: __ROOT_NAMESPACE__.UserOrGroup): void => {
                value_22.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.accountList != null) {
            output.writeFieldBegin("accountList", thrift.Thrift.Type.LIST, 4);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.accountList.length);
            this.accountList.forEach((value_23: __ROOT_NAMESPACE__.Account): void => {
                value_23.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateRegistryArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_24: string = input.readString();
                        _args.token = value_24;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_25: Registry.Registry = Registry.Registry.read(input);
                        _args.registry = value_25;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_26: Array<__ROOT_NAMESPACE__.UserOrGroup> = new Array<__ROOT_NAMESPACE__.UserOrGroup>();
                        const metadata_3: thrift.TList = input.readListBegin();
                        const size_3: number = metadata_3.size;
                        for (let i_3: number = 0; i_3 < size_3; i_3++) {
                            const value_27: __ROOT_NAMESPACE__.UserOrGroup = __ROOT_NAMESPACE__.UserOrGroup.read(input);
                            value_26.push(value_27);
                        }
                        input.readListEnd();
                        _args.userOrGroupList = value_26;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_28: Array<__ROOT_NAMESPACE__.Account> = new Array<__ROOT_NAMESPACE__.Account>();
                        const metadata_4: thrift.TList = input.readListBegin();
                        const size_4: number = metadata_4.size;
                        for (let i_4: number = 0; i_4 < size_4; i_4++) {
                            const value_29: __ROOT_NAMESPACE__.Account = __ROOT_NAMESPACE__.Account.read(input);
                            value_28.push(value_29);
                        }
                        input.readListEnd();
                        _args.accountList = value_28;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.registry !== undefined && _args.userOrGroupList !== undefined && _args.accountList !== undefined) {
            return new CreateOrUpdateRegistryArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateOrUpdateRegistryArgs from input");
        }
    }
}
export interface ICompareJiraTimeArgsArgs {
    jiraTime1: string;
    jiraTime2: string;
}
export class CompareJiraTimeArgs {
    public jiraTime1: string;
    public jiraTime2: string;
    constructor(args: ICompareJiraTimeArgsArgs) {
        if (args != null && args.jiraTime1 != null) {
            this.jiraTime1 = args.jiraTime1;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[jiraTime1] is unset!");
        }
        if (args != null && args.jiraTime2 != null) {
            this.jiraTime2 = args.jiraTime2;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[jiraTime2] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CompareJiraTimeArgs");
        if (this.jiraTime1 != null) {
            output.writeFieldBegin("jiraTime1", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.jiraTime1);
            output.writeFieldEnd();
        }
        if (this.jiraTime2 != null) {
            output.writeFieldBegin("jiraTime2", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.jiraTime2);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CompareJiraTimeArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_30: string = input.readString();
                        _args.jiraTime1 = value_30;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_31: string = input.readString();
                        _args.jiraTime2 = value_31;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.jiraTime1 !== undefined && _args.jiraTime2 !== undefined) {
            return new CompareJiraTimeArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CompareJiraTimeArgs from input");
        }
    }
}
export interface ICreateOrUpdateRegistrySortRuleArgsArgs {
    token: string;
    registryId: string;
    defaultSortColumn: string;
}
export class CreateOrUpdateRegistrySortRuleArgs {
    public token: string;
    public registryId: string;
    public defaultSortColumn: string;
    constructor(args: ICreateOrUpdateRegistrySortRuleArgsArgs) {
        if (args != null && args.token != null) {
            this.token = args.token;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[token] is unset!");
        }
        if (args != null && args.registryId != null) {
            this.registryId = args.registryId;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[registryId] is unset!");
        }
        if (args != null && args.defaultSortColumn != null) {
            this.defaultSortColumn = args.defaultSortColumn;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[defaultSortColumn] is unset!");
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateRegistrySortRuleArgs");
        if (this.token != null) {
            output.writeFieldBegin("token", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.token);
            output.writeFieldEnd();
        }
        if (this.registryId != null) {
            output.writeFieldBegin("registryId", thrift.Thrift.Type.STRING, 2);
            output.writeString(this.registryId);
            output.writeFieldEnd();
        }
        if (this.defaultSortColumn != null) {
            output.writeFieldBegin("defaultSortColumn", thrift.Thrift.Type.STRING, 3);
            output.writeString(this.defaultSortColumn);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateRegistrySortRuleArgs {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_32: string = input.readString();
                        _args.token = value_32;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_33: string = input.readString();
                        _args.registryId = value_33;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_34: string = input.readString();
                        _args.defaultSortColumn = value_34;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.token !== undefined && _args.registryId !== undefined && _args.defaultSortColumn !== undefined) {
            return new CreateOrUpdateRegistrySortRuleArgs(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CreateOrUpdateRegistrySortRuleArgs from input");
        }
    }
}
export interface IGetDocumentDataResultArgs {
    success?: AggregationDocumentData.AggregationDocumentData;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetDocumentDataResult {
    public success?: AggregationDocumentData.AggregationDocumentData;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetDocumentDataResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetDocumentDataResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetDocumentDataResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_35: AggregationDocumentData.AggregationDocumentData = AggregationDocumentData.AggregationDocumentData.read(input);
                        _args.success = value_35;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_36: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_36;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_37: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_37;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetDocumentDataResult(_args);
    }
}
export interface IGetAllRegistriesResultArgs {
    success?: Array<Registry.Registry>;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetAllRegistriesResult {
    public success?: Array<Registry.Registry>;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetAllRegistriesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetAllRegistriesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
            output.writeListBegin(thrift.Thrift.Type.STRUCT, this.success.length);
            this.success.forEach((value_38: Registry.Registry): void => {
                value_38.write(output);
            });
            output.writeListEnd();
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetAllRegistriesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.LIST) {
                        const value_39: Array<Registry.Registry> = new Array<Registry.Registry>();
                        const metadata_5: thrift.TList = input.readListBegin();
                        const size_5: number = metadata_5.size;
                        for (let i_5: number = 0; i_5 < size_5; i_5++) {
                            const value_40: Registry.Registry = Registry.Registry.read(input);
                            value_39.push(value_40);
                        }
                        input.readListEnd();
                        _args.success = value_39;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_41: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_41;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_42: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_42;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetAllRegistriesResult(_args);
    }
}
export interface IGetCountAllRegistriesResultArgs {
    success?: number;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetCountAllRegistriesResult {
    public success?: number;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetCountAllRegistriesResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetCountAllRegistriesResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
            output.writeI32(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetCountAllRegistriesResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_43: number = input.readI32();
                        _args.success = value_43;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_44: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_44;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_45: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_45;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetCountAllRegistriesResult(_args);
    }
}
export interface IGetRegistryByIdResultArgs {
    success?: Registry.Registry;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class GetRegistryByIdResult {
    public success?: Registry.Registry;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IGetRegistryByIdResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("GetRegistryByIdResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): GetRegistryByIdResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_46: Registry.Registry = Registry.Registry.read(input);
                        _args.success = value_46;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_47: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_47;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_48: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_48;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new GetRegistryByIdResult(_args);
    }
}
export interface IRemoveRegistryResultArgs {
    success?: boolean;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class RemoveRegistryResult {
    public success?: boolean;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: IRemoveRegistryResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("RemoveRegistryResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.BOOL, 0);
            output.writeBool(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): RemoveRegistryResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.BOOL) {
                        const value_49: boolean = input.readBool();
                        _args.success = value_49;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_50: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_50;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_51: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_51;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new RemoveRegistryResult(_args);
    }
}
export interface ICreateOrUpdateRegistryResultArgs {
    success?: Registry.Registry;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class CreateOrUpdateRegistryResult {
    public success?: Registry.Registry;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: ICreateOrUpdateRegistryResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateRegistryResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
            this.success.write(output);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateRegistryResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_52: Registry.Registry = Registry.Registry.read(input);
                        _args.success = value_52;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_53: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_53;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_54: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_54;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateOrUpdateRegistryResult(_args);
    }
}
export interface ICompareJiraTimeResultArgs {
    success?: number;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class CompareJiraTimeResult {
    public success?: number;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: ICompareJiraTimeResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CompareJiraTimeResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
            output.writeI32(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CompareJiraTimeResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_55: number = input.readI32();
                        _args.success = value_55;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_56: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_56;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_57: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_57;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CompareJiraTimeResult(_args);
    }
}
export interface ICreateOrUpdateRegistrySortRuleResultArgs {
    success?: string;
    validError?: __ROOT_NAMESPACE__.PreconditionException;
    error?: __ROOT_NAMESPACE__.ServerException;
}
export class CreateOrUpdateRegistrySortRuleResult {
    public success?: string;
    public validError?: __ROOT_NAMESPACE__.PreconditionException;
    public error?: __ROOT_NAMESPACE__.ServerException;
    constructor(args?: ICreateOrUpdateRegistrySortRuleResultArgs) {
        if (args != null && args.success != null) {
            this.success = args.success;
        }
        if (args != null && args.validError != null) {
            this.validError = args.validError;
        }
        if (args != null && args.error != null) {
            this.error = args.error;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("CreateOrUpdateRegistrySortRuleResult");
        if (this.success != null) {
            output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
            output.writeString(this.success);
            output.writeFieldEnd();
        }
        if (this.validError != null) {
            output.writeFieldBegin("validError", thrift.Thrift.Type.STRUCT, 1);
            this.validError.write(output);
            output.writeFieldEnd();
        }
        if (this.error != null) {
            output.writeFieldBegin("error", thrift.Thrift.Type.STRUCT, 2);
            this.error.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): CreateOrUpdateRegistrySortRuleResult {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 0:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_58: string = input.readString();
                        _args.success = value_58;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_59: __ROOT_NAMESPACE__.PreconditionException = __ROOT_NAMESPACE__.PreconditionException.read(input);
                        _args.validError = value_59;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        const value_60: __ROOT_NAMESPACE__.ServerException = __ROOT_NAMESPACE__.ServerException.read(input);
                        _args.error = value_60;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new CreateOrUpdateRegistrySortRuleResult(_args);
    }
}
export class Client {
    public _seqid: number;
    public _reqs: {
        [name: number]: (err: Error | object | undefined, val?: any) => void;
    };
    public output: thrift.TTransport;
    public protocol: new (trans: thrift.TTransport) => thrift.TProtocol;
    constructor(output: thrift.TTransport, protocol: new (trans: thrift.TTransport) => thrift.TProtocol) {
        this._seqid = 0;
        this._reqs = {};
        this.output = output;
        this.protocol = protocol;
    }
    public incrementSeqId(): number {
        return this._seqid += 1;
    }
    public getDocumentData(token: string, documentId: string, requiredData: Set<__ROOT_NAMESPACE__.AggregationRequiredType>, policy: __ROOT_NAMESPACE__.DocumentAccessPolicy, decrypt: boolean, executorsPortion: number): Promise<AggregationDocumentData.AggregationDocumentData> {
        const requestId: number = this.incrementSeqId();
        return new Promise<AggregationDocumentData.AggregationDocumentData>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getDocumentData(token, documentId, requiredData, policy, decrypt, executorsPortion, requestId);
        });
    }
    public getAllRegistries(token: string, filter: __ROOT_NAMESPACE__.KazFilter, forAdmin: boolean): Promise<Array<Registry.Registry>> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Array<Registry.Registry>>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getAllRegistries(token, filter, forAdmin, requestId);
        });
    }
    public getCountAllRegistries(token: string, filter: __ROOT_NAMESPACE__.KazFilter, forAdmin: boolean): Promise<number> {
        const requestId: number = this.incrementSeqId();
        return new Promise<number>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getCountAllRegistries(token, filter, forAdmin, requestId);
        });
    }
    public getRegistryById(token: string, id: string, requiredData: Set<__ROOT_NAMESPACE__.AggregationRequiredType>): Promise<Registry.Registry> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Registry.Registry>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_getRegistryById(token, id, requiredData, requestId);
        });
    }
    public removeRegistry(token: string, registryId: string): Promise<boolean> {
        const requestId: number = this.incrementSeqId();
        return new Promise<boolean>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_removeRegistry(token, registryId, requestId);
        });
    }
    public createOrUpdateRegistry(token: string, registry: Registry.Registry, userOrGroupList: Array<__ROOT_NAMESPACE__.UserOrGroup>, accountList: Array<__ROOT_NAMESPACE__.Account>): Promise<Registry.Registry> {
        const requestId: number = this.incrementSeqId();
        return new Promise<Registry.Registry>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createOrUpdateRegistry(token, registry, userOrGroupList, accountList, requestId);
        });
    }
    public compareJiraTime(jiraTime1: string, jiraTime2: string): Promise<number> {
        const requestId: number = this.incrementSeqId();
        return new Promise<number>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_compareJiraTime(jiraTime1, jiraTime2, requestId);
        });
    }
    public createOrUpdateRegistrySortRule(token: string, registryId: string, defaultSortColumn: string): Promise<string> {
        const requestId: number = this.incrementSeqId();
        return new Promise<string>((resolve, reject): void => {
            this._reqs[requestId] = (error, result) => {
                delete this._reqs[requestId];
                if (error != null) {
                    reject(error);
                }
                else {
                    resolve(result);
                }
            };
            this.send_createOrUpdateRegistrySortRule(token, registryId, defaultSortColumn, requestId);
        });
    }
    public send_getDocumentData(token: string, documentId: string, requiredData: Set<__ROOT_NAMESPACE__.AggregationRequiredType>, policy: __ROOT_NAMESPACE__.DocumentAccessPolicy, decrypt: boolean, executorsPortion: number, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getDocumentData", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetDocumentDataArgs = new GetDocumentDataArgs({ token, documentId, requiredData, policy, decrypt, executorsPortion });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getAllRegistries(token: string, filter: __ROOT_NAMESPACE__.KazFilter, forAdmin: boolean, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getAllRegistries", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetAllRegistriesArgs = new GetAllRegistriesArgs({ token, filter, forAdmin });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getCountAllRegistries(token: string, filter: __ROOT_NAMESPACE__.KazFilter, forAdmin: boolean, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getCountAllRegistries", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetCountAllRegistriesArgs = new GetCountAllRegistriesArgs({ token, filter, forAdmin });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_getRegistryById(token: string, id: string, requiredData: Set<__ROOT_NAMESPACE__.AggregationRequiredType>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("getRegistryById", thrift.Thrift.MessageType.CALL, requestId);
        const args: GetRegistryByIdArgs = new GetRegistryByIdArgs({ token, id, requiredData });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_removeRegistry(token: string, registryId: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("removeRegistry", thrift.Thrift.MessageType.CALL, requestId);
        const args: RemoveRegistryArgs = new RemoveRegistryArgs({ token, registryId });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createOrUpdateRegistry(token: string, registry: Registry.Registry, userOrGroupList: Array<__ROOT_NAMESPACE__.UserOrGroup>, accountList: Array<__ROOT_NAMESPACE__.Account>, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createOrUpdateRegistry", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateOrUpdateRegistryArgs = new CreateOrUpdateRegistryArgs({ token, registry, userOrGroupList, accountList });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_compareJiraTime(jiraTime1: string, jiraTime2: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("compareJiraTime", thrift.Thrift.MessageType.CALL, requestId);
        const args: CompareJiraTimeArgs = new CompareJiraTimeArgs({ jiraTime1, jiraTime2 });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public send_createOrUpdateRegistrySortRule(token: string, registryId: string, defaultSortColumn: string, requestId: number): void {
        const output: thrift.TProtocol = new this.protocol(this.output);
        output.writeMessageBegin("createOrUpdateRegistrySortRule", thrift.Thrift.MessageType.CALL, requestId);
        const args: CreateOrUpdateRegistrySortRuleArgs = new CreateOrUpdateRegistrySortRuleArgs({ token, registryId, defaultSortColumn });
        args.write(output);
        output.writeMessageEnd();
        this.output.flush();
        return;
    }
    public recv_getDocumentData(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetDocumentDataResult = GetDocumentDataResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getDocumentData failed: unknown result"));
                }
            }
        }
    }
    public recv_getAllRegistries(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetAllRegistriesResult = GetAllRegistriesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getAllRegistries failed: unknown result"));
                }
            }
        }
    }
    public recv_getCountAllRegistries(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetCountAllRegistriesResult = GetCountAllRegistriesResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getCountAllRegistries failed: unknown result"));
                }
            }
        }
    }
    public recv_getRegistryById(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: GetRegistryByIdResult = GetRegistryByIdResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "getRegistryById failed: unknown result"));
                }
            }
        }
    }
    public recv_removeRegistry(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: RemoveRegistryResult = RemoveRegistryResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "removeRegistry failed: unknown result"));
                }
            }
        }
    }
    public recv_createOrUpdateRegistry(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateOrUpdateRegistryResult = CreateOrUpdateRegistryResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createOrUpdateRegistry failed: unknown result"));
                }
            }
        }
    }
    public recv_compareJiraTime(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CompareJiraTimeResult = CompareJiraTimeResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "compareJiraTime failed: unknown result"));
                }
            }
        }
    }
    public recv_createOrUpdateRegistrySortRule(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
        const noop = (): any => null;
        const callback = this._reqs[requestId] || noop;
        if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
            const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
            x.read(input);
            input.readMessageEnd();
            return callback(x);
        }
        else {
            const result: CreateOrUpdateRegistrySortRuleResult = CreateOrUpdateRegistrySortRuleResult.read(input);
            input.readMessageEnd();
            if (result.validError != null) {
                return callback(result.validError);
            }
            else if (result.error != null) {
                return callback(result.error);
            }
            else {
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "createOrUpdateRegistrySortRule failed: unknown result"));
                }
            }
        }
    }
}
export interface IHandler {
    getDocumentData(token: string, documentId: string, requiredData: Set<__ROOT_NAMESPACE__.AggregationRequiredType>, policy: __ROOT_NAMESPACE__.DocumentAccessPolicy, decrypt: boolean, executorsPortion: number): AggregationDocumentData.AggregationDocumentData | Promise<AggregationDocumentData.AggregationDocumentData>;
    getAllRegistries(token: string, filter: __ROOT_NAMESPACE__.KazFilter, forAdmin: boolean): Array<Registry.Registry> | Promise<Array<Registry.Registry>>;
    getCountAllRegistries(token: string, filter: __ROOT_NAMESPACE__.KazFilter, forAdmin: boolean): number | Promise<number>;
    getRegistryById(token: string, id: string, requiredData: Set<__ROOT_NAMESPACE__.AggregationRequiredType>): Registry.Registry | Promise<Registry.Registry>;
    removeRegistry(token: string, registryId: string): boolean | Promise<boolean>;
    createOrUpdateRegistry(token: string, registry: Registry.Registry, userOrGroupList: Array<__ROOT_NAMESPACE__.UserOrGroup>, accountList: Array<__ROOT_NAMESPACE__.Account>): Registry.Registry | Promise<Registry.Registry>;
    compareJiraTime(jiraTime1: string, jiraTime2: string): number | Promise<number>;
    createOrUpdateRegistrySortRule(token: string, registryId: string, defaultSortColumn: string): string | Promise<string>;
}
export class Processor {
    public _handler: IHandler;
    constructor(handler: IHandler) {
        this._handler = handler;
    }
    public process(input: thrift.TProtocol, output: thrift.TProtocol): void {
        const metadata: thrift.TMessage = input.readMessageBegin();
        const fname: string = metadata.fname;
        const requestId: number = metadata.rseqid;
        const methodName: string = "process_" + fname;
        switch (methodName) {
            case "process_getDocumentData": {
                this.process_getDocumentData(requestId, input, output);
                return;
            }
            case "process_getAllRegistries": {
                this.process_getAllRegistries(requestId, input, output);
                return;
            }
            case "process_getCountAllRegistries": {
                this.process_getCountAllRegistries(requestId, input, output);
                return;
            }
            case "process_getRegistryById": {
                this.process_getRegistryById(requestId, input, output);
                return;
            }
            case "process_removeRegistry": {
                this.process_removeRegistry(requestId, input, output);
                return;
            }
            case "process_createOrUpdateRegistry": {
                this.process_createOrUpdateRegistry(requestId, input, output);
                return;
            }
            case "process_compareJiraTime": {
                this.process_compareJiraTime(requestId, input, output);
                return;
            }
            case "process_createOrUpdateRegistrySortRule": {
                this.process_createOrUpdateRegistrySortRule(requestId, input, output);
                return;
            }
            default: {
                input.skip(thrift.Thrift.Type.STRUCT);
                input.readMessageEnd();
                const errMessage = "Unknown function " + fname;
                const err = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                output.writeMessageBegin(fname, thrift.Thrift.MessageType.EXCEPTION, requestId);
                err.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        }
    }
    public process_getDocumentData(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<AggregationDocumentData.AggregationDocumentData>((resolve, reject): void => {
            try {
                const args: GetDocumentDataArgs = GetDocumentDataArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getDocumentData(args.token, args.documentId, args.requiredData, args.policy, args.decrypt, args.executorsPortion));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: AggregationDocumentData.AggregationDocumentData): void => {
            const result: GetDocumentDataResult = new GetDocumentDataResult({ success: data });
            output.writeMessageBegin("getDocumentData", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetDocumentDataResult = new GetDocumentDataResult({ validError: err });
                output.writeMessageBegin("getDocumentData", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetDocumentDataResult = new GetDocumentDataResult({ error: err });
                output.writeMessageBegin("getDocumentData", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getDocumentData", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getAllRegistries(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Array<Registry.Registry>>((resolve, reject): void => {
            try {
                const args: GetAllRegistriesArgs = GetAllRegistriesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getAllRegistries(args.token, args.filter, args.forAdmin));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Array<Registry.Registry>): void => {
            const result: GetAllRegistriesResult = new GetAllRegistriesResult({ success: data });
            output.writeMessageBegin("getAllRegistries", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetAllRegistriesResult = new GetAllRegistriesResult({ validError: err });
                output.writeMessageBegin("getAllRegistries", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetAllRegistriesResult = new GetAllRegistriesResult({ error: err });
                output.writeMessageBegin("getAllRegistries", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getAllRegistries", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getCountAllRegistries(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<number>((resolve, reject): void => {
            try {
                const args: GetCountAllRegistriesArgs = GetCountAllRegistriesArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getCountAllRegistries(args.token, args.filter, args.forAdmin));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): void => {
            const result: GetCountAllRegistriesResult = new GetCountAllRegistriesResult({ success: data });
            output.writeMessageBegin("getCountAllRegistries", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetCountAllRegistriesResult = new GetCountAllRegistriesResult({ validError: err });
                output.writeMessageBegin("getCountAllRegistries", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetCountAllRegistriesResult = new GetCountAllRegistriesResult({ error: err });
                output.writeMessageBegin("getCountAllRegistries", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getCountAllRegistries", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_getRegistryById(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Registry.Registry>((resolve, reject): void => {
            try {
                const args: GetRegistryByIdArgs = GetRegistryByIdArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.getRegistryById(args.token, args.id, args.requiredData));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Registry.Registry): void => {
            const result: GetRegistryByIdResult = new GetRegistryByIdResult({ success: data });
            output.writeMessageBegin("getRegistryById", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: GetRegistryByIdResult = new GetRegistryByIdResult({ validError: err });
                output.writeMessageBegin("getRegistryById", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: GetRegistryByIdResult = new GetRegistryByIdResult({ error: err });
                output.writeMessageBegin("getRegistryById", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("getRegistryById", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_removeRegistry(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<boolean>((resolve, reject): void => {
            try {
                const args: RemoveRegistryArgs = RemoveRegistryArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.removeRegistry(args.token, args.registryId));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: boolean): void => {
            const result: RemoveRegistryResult = new RemoveRegistryResult({ success: data });
            output.writeMessageBegin("removeRegistry", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: RemoveRegistryResult = new RemoveRegistryResult({ validError: err });
                output.writeMessageBegin("removeRegistry", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: RemoveRegistryResult = new RemoveRegistryResult({ error: err });
                output.writeMessageBegin("removeRegistry", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("removeRegistry", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createOrUpdateRegistry(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<Registry.Registry>((resolve, reject): void => {
            try {
                const args: CreateOrUpdateRegistryArgs = CreateOrUpdateRegistryArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createOrUpdateRegistry(args.token, args.registry, args.userOrGroupList, args.accountList));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: Registry.Registry): void => {
            const result: CreateOrUpdateRegistryResult = new CreateOrUpdateRegistryResult({ success: data });
            output.writeMessageBegin("createOrUpdateRegistry", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: CreateOrUpdateRegistryResult = new CreateOrUpdateRegistryResult({ validError: err });
                output.writeMessageBegin("createOrUpdateRegistry", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: CreateOrUpdateRegistryResult = new CreateOrUpdateRegistryResult({ error: err });
                output.writeMessageBegin("createOrUpdateRegistry", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createOrUpdateRegistry", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_compareJiraTime(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<number>((resolve, reject): void => {
            try {
                const args: CompareJiraTimeArgs = CompareJiraTimeArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.compareJiraTime(args.jiraTime1, args.jiraTime2));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: number): void => {
            const result: CompareJiraTimeResult = new CompareJiraTimeResult({ success: data });
            output.writeMessageBegin("compareJiraTime", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: CompareJiraTimeResult = new CompareJiraTimeResult({ validError: err });
                output.writeMessageBegin("compareJiraTime", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: CompareJiraTimeResult = new CompareJiraTimeResult({ error: err });
                output.writeMessageBegin("compareJiraTime", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("compareJiraTime", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
    public process_createOrUpdateRegistrySortRule(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
        new Promise<string>((resolve, reject): void => {
            try {
                const args: CreateOrUpdateRegistrySortRuleArgs = CreateOrUpdateRegistrySortRuleArgs.read(input);
                input.readMessageEnd();
                resolve(this._handler.createOrUpdateRegistrySortRule(args.token, args.registryId, args.defaultSortColumn));
            }
            catch (err) {
                reject(err);
            }
        }).then((data: string): void => {
            const result: CreateOrUpdateRegistrySortRuleResult = new CreateOrUpdateRegistrySortRuleResult({ success: data });
            output.writeMessageBegin("createOrUpdateRegistrySortRule", thrift.Thrift.MessageType.REPLY, requestId);
            result.write(output);
            output.writeMessageEnd();
            output.flush();
            return;
        }).catch((err: Error): void => {
            if (err instanceof __ROOT_NAMESPACE__.PreconditionException) {
                const result: CreateOrUpdateRegistrySortRuleResult = new CreateOrUpdateRegistrySortRuleResult({ validError: err });
                output.writeMessageBegin("createOrUpdateRegistrySortRule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else if (err instanceof __ROOT_NAMESPACE__.ServerException) {
                const result: CreateOrUpdateRegistrySortRuleResult = new CreateOrUpdateRegistrySortRuleResult({ error: err });
                output.writeMessageBegin("createOrUpdateRegistrySortRule", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
            else {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("createOrUpdateRegistrySortRule", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }
        });
    }
}
