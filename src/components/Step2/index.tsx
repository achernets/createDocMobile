import { JSX, useEffect, useState, Fragment } from "react";
import { Button, Space, Tabs, Toast } from "antd-mobile";
import useAppStore from "../../store/useAppStore";
import { useShallow } from "zustand/shallow";
import { FormStyled, TabsStyled } from "./styled";
import { useForm } from "react-hook-form";
import { ADocument, AttachmentEditMode, AttachmentExtStatus, AttCreateInfo, ContentHolder, ContentHolderLink, ContentItem, ContentItemHBValue, ContentItemType, ContentItemValue, ContentTableDefinition, DocumentAccessPolicy, DocumentAccessPolicyType, FreezeDocumentPattern, PreconditionException, UserOrGroupType } from "../../api/data";
import UploadAttAndPatternTemplate from "../Form/UploadAttAndPatternTemplate";
import Holder from "../Form/Holder";
import TabInfo from "./components/TabInfo";
import Stages from "./components/Stages";
import { map, reduce, size, debounce, uniqBy, findIndex, filter, get, concat, find, compact } from "lodash";
import { ContentItemExecScript, contentItemSchema } from "../../utils/document";
import { DocumentServiceClient, FilledDocumentPatternServiceClient } from "../../api";
import { getLetterJiraTime, getNumberJiraTime, parseDate, sendMessageMobile } from "../../utils";
import { yupResolver } from "@hookform/resolvers/yup"
import * as yup from "yup"
import { useTranslation } from "react-i18next";



const Step2 = (): JSX.Element => {
  const { docInfo, token, clientInfo, account, groupPattern, pattern } = useAppStore(
    useShallow((state) => ({
      token: state.token,
      account: state.account,
      groupPattern: state.groupPattern,
      pattern: state.pattern,
      docInfo: state.docInfo,
      clientInfo: state.clientInfo
    })),
  );

  const docEdit = true;

  const { t } = useTranslation();

  const { control, watch, setValue, getValues, handleSubmit } = useForm({
    defaultValues: docInfo,
    shouldUnregister: false,
    criteriaMode: 'all',
    resolver: yupResolver(yup.object({
      scGrifs: docEdit ? yup.array().when(['pattern.useSC'], ([useSC]) => {
        return useSC ? yup.array().nullable().min(1, 'form.required') : yup.array().nullable();
      }) : yup.array().nullable(),
      document: docEdit ? yup.object().when(['pattern.autoGenerateDocName', 'formEdit'], ([autoGenerateDocName, formEdit]) => {
        return yup.object({
          documentDeadlineDate: yup.number().when('controlForDocument', ([controlForDocument]) => {
            return controlForDocument ? yup.number().nullable().positive().required('form.required') : yup.number().nullable();
          }),
          nameDocument: autoGenerateDocName ? yup.string().notRequired() : yup.string().min(3, '3').required('form.required'),
          externalNumber: (formEdit === 'inbox_simple' || formEdit === 'inbox') ? yup.string().required('form.required') : yup.string().nullable(),
          externalRegDate: (formEdit === 'inbox_simple' || formEdit === 'inbox') ? yup.number().nullable().positive().required('form.required') : yup.number().nullable()
        });
      }) : yup.object().nullable(),
      controlUsers: yup.array().nullable(),
      // holders: yup.array().when(['contentItems'], ([contentItems]) => {
      //   return yup.array().of(yup.object({
      //     contentHolderLink: yup.array().of(yup.object({
      //       contentItem: yup.object().when(['visible', 'requared'], ([visible, requared]) => {
      //         return visible ? yup.object({
      //           value: yup.object().when(['key', 'type', 'tMask'], ([key, type, tMask]) => {
      //             switch (type) {
      //               case ContentItemType.TEXT_FIELD:
      //                 if (tMask && tMask !== null) {
      //                   return yup.object({
      //                     strValue: requared ?
      //                       yup.string().transform((value) => get(contentItems, `${key}.value.strValue`, value)).nullable().required('form.required').matches(tMask, 'incorrect') :
      //                       yup.string().nullable().matches(tMask, {
      //                         message: 'incorrect',
      //                         name: 'incorrect',
      //                         excludeEmptyString: true
      //                       })
      //                   });
      //                 };
      //                 return yup.object({
      //                   strValue: requared ? yup.string().transform((value) => get(contentItems, `${key}.value.strValue`, value)).nullable().required('form.required') : yup.string().nullable()
      //                 });
      //               case ContentItemType.USER_CHOICE:
      //               case ContentItemType.ATTACHMENT:
      //               case ContentItemType.ORG_STRUCTURE:
      //               case ContentItemType.TABLE:
      //               case ContentItemType.SEPARATOR:
      //               case ContentItemType.MARK:
      //               case ContentItemType.CONTAINER:
      //               case ContentItemType.BUTTON:
      //                 return yup.object().nullable();
      //               case ContentItemType.CHECKBOX:
      //                 return yup.object({
      //                   //@ts-ignore
      //                   strValue: requared ? yup.string().transform((value) => get(contentItems, `${key}.value.strValue`, value)).oneOf([true, 'true']).required('form.required') : yup.string().nullable()
      //                 });
      //               case ContentItemType.HAND_BOOK:
      //                 return yup.object({
      //                   hbValue: yup.object({
      //                     row: requared ? yup.object().transform((value) => get(contentItems, `${key}.value.hbValue`, value)).nullable().required('form.required') : yup.object().nullable()
      //                   }).nullable()
      //                 });
      //               default:
      //                 return yup.object({
      //                   strValue: requared ? yup.string().transform((value) => get(contentItems, `${key}.value.strValue`, value)).nullable().required('form.required') : yup.string().nullable()
      //                 });
      //             };
      //           }),
      //           childItems: yup.array().when(['key', 'type'], ([key, type]) => {
      //             switch (type) {
      //               case ContentItemType.TABLE:
      //                 return yup.array().transform((value) => get(contentItems, `${key}.childItems`, value)).nullable().min(requared ? 1 : 0, 'form.required');
      //               default:
      //                 return yup.array().nullable();
      //             };
      //           }),
      //           users: yup.array().when(['key', 'type'], ([key, type]) => {
      //             switch (type) {
      //               case ContentItemType.USER_CHOICE:
      //                 return yup.array().transform((value) => get(contentItems, `${key}.users`, value)).nullable().min(requared ? 1 : 0, 'form.required');
      //               default:
      //                 return yup.array().nullable();
      //             };
      //           }),
      //           attachment: yup.object().when(['key', 'type'], ([key, type]) => {
      //             switch (type) {
      //               case ContentItemType.ATTACHMENT:
      //                 return requared ? yup.object().transform((value) => get(contentItems, `${key}.attachment`, value)).nullable().required('form.required') : yup.object().nullable();
      //               default:
      //                 return yup.object().nullable();
      //             };
      //           }),
      //           department: yup.object().when(['key', 'type'], ([key, type]) => {
      //             switch (type) {
      //               case ContentItemType.ORG_STRUCTURE:
      //                 return requared ? yup.object().transform((value) => get(contentItems, `${key}.department`, value)).nullable().required('form.required') : yup.object().nullable();
      //               default:
      //                 return yup.object().nullable();
      //             };
      //           })
      //         }) : yup.object();
      //       })
      //     }))
      //   }))
      // })
      stages: docEdit ? yup.array().of(yup.object({
        userOrGroups: yup.array().when('stageReq', ([stageReq]) => {
          return stageReq ? yup.array().min(1, 'form.required') : yup.array().nullable();
        }),
        deadLine: yup.string().when('runPerriodicall', ([runPerriodicall]) => {
          return !runPerriodicall ? yup.string().nullable().required('form.required') : yup.string().nullable();
        }),
        startPeriod: yup.number().when('runPerriodicall', ([runPerriodicall]) => {
          return runPerriodicall ? yup.number().min(1, 'form.required').required('form.required') : yup.number().nullable();
        }),
        periodicJiraEndDate: yup.string().nullable().test(
          'periodicJiraEndDate-required',
          'form.required',
          function (value) {
            const { runPerriodicall, periodicEndDate } = this.parent;
            const hasData = parseDate(periodicEndDate);
            const hasNumber = getNumberJiraTime(value) > 0;
            const hasLetter = getLetterJiraTime(value).length > 0;
            if (runPerriodicall && (hasData === null || hasData === undefined) && (hasNumber === false || hasLetter === false)) {
              return this.createError({ message: 'form.required' });
            }
            return true;
          }
        ),
        periodicEndDate: yup.number().nullable().test(
          'periodicJiraEndDate-required',
          'form.required',
          function (value) {
            const { runPerriodicall, periodicEndDate } = this.parent;
            const hasData = parseDate(periodicEndDate);
            const hasNumber = getNumberJiraTime(value) > 0;
            const hasLetter = getLetterJiraTime(value).length > 0;
            if (runPerriodicall && (hasData === null || hasData === undefined) && (hasNumber === false || hasLetter === false)) {
              return this.createError({ message: 'form.required' });
            }
            return true;
          }
        ),
        nextStartPeriod: yup.string().when('runPerriodicall', ([runPerriodicall]) => {
          return runPerriodicall ? yup.string().nullable().required('form.required') : yup.string().nullable();
        }),
        cardActivityPeriod: yup.string().when('runPerriodicall', ([runPerriodicall]) => {
          return runPerriodicall ? yup.string().nullable().required('form.required') : yup.string().nullable();
        })
      })) : yup.array().nullable(),
    }).test(function (values) {
      const allErrors = [];
      //@ts-ignore
      for (const key in values?.contentItems) {
        const itm = reduce(holders, (hash, itm) => {
          const os = find(itm.contentHolderLink, { requared: true, visible: true, contentItem: { key: key } });
          if (os) hash = os.contentItem;
          return hash;
        }, undefined);
        try {
          //@ts-ignore
          if (itm) contentItemSchema(true).validateSync(values?.contentItems[key], { abortEarly: false });
        } catch (err: any) {
          let path = `contentItems.${key}.`;
          switch (itm.type) {
            case ContentItemType.TEXT_FIELD:
            case ContentItemType.MULTILINE_TEXT_FIELD:
            case ContentItemType.CHECKBOX:
            case ContentItemType.COMBO_BOX:
            case ContentItemType.CALENDAR:
            case ContentItemType.DATE_TIME:
            case ContentItemType.SWITCH_ITEM:
            case ContentItemType.HTTP_LINK:
            case ContentItemType.CURRENCY:
            case ContentItemType.JIRA_TIME:
              path = path + 'value.strValue';
              break;
            case ContentItemType.USER_CHOICE:
              path = path + 'users';
              break;

            case ContentItemType.CALENDAR_RANGE:
              path = path + 'value';
              break;
            case ContentItemType.ATTACHMENT:
              path = path + 'attachment';
              break;
            case ContentItemType.ORG_STRUCTURE:
              path = path + 'department';
              break;
            case ContentItemType.HAND_BOOK:
              path = path + 'value.hbValue';
              break;
            case ContentItemType.TABLE:
            case ContentItemType.CONTAINER:
              path = path + 'childItems';
              break;
            default:
              break;
          }
          allErrors.push(
            this.createError({
              path: path,
              message: err.message,
            })
          );
        }
      }
      if (allErrors.length > 0) {
        throw new yup.ValidationError(allErrors);
      }
      return true
    })
    )
  });

  const [changes, setChanges] = useState([]);
  const [changesIsWork, setChangesIsWork] = useState(false);

  const execFunc = async (obj) => {
    const holder = getValues(obj.holderPath);
    const fn = new Function('Methods', `return (async () => {${obj.item.onChangeScript}})();`);
    console.log('start');
    const getContentItem = (key: string) => getValues(`contentItems.${key}`);
    const getPathLinkByKey = (key) => {
      return `${obj.holderPath}.contentHolderLink.${findIndex(holder.contentHolderLink, { contentItem: { key: key } })}`
    };
    await fn(ContentItemExecScript(setValue, getValues, getContentItem, getPathLinkByKey)).then(() => {
      console.log('end');
      setChanges(prev => prev.filter((_, i) => i !== 0));
      setChangesIsWork(false);
    }).catch((err) => {
      console.log(`Script error contentItemKey=${obj.item.contentItem.key}`, err);
      setChanges(prev => prev.filter((_, i) => i !== 0));
      setChangesIsWork(false);
    });
  };

  const debouncedExec = debounce((change) => {
    execFunc(change);
  }, 300);

  useEffect(() => {
    if (size(changes) === 0) return;
    if (changesIsWork === false) {
      setChangesIsWork(true);
      debouncedExec(changes[0]);
    }
  }, [debouncedExec, changes, changesIsWork]);

  useEffect(() => {
    const scripts = reduce(docInfo.holders, (hash, itm, index) => {
      if (itm.onShow && itm.onShow !== null && itm.onShow !== '') {
        hash.push({
          holderPath: `holders.${index}`,
          pathItem: `holders.${index}`,
          item: {
            onChangeScript: itm.onShow
          }
        });
      }
      return hash;
    }, []);
    if(size(scripts) > 0) setChanges(prev=>uniqBy([...prev, ...scripts].reverse(), 'pathItem').reverse());
  }, [docInfo.holders]);

  useEffect(() => {
    const { unsubscribe } = watch((_, { name }) => {
      if (name?.startsWith('contentItems.')) {
        const paths = name.split('.');
        const holders = getValues('holders');
        const links = reduce(holders, (hash, holder, index) => {
          map(holder.contentHolderLink, (itm, idx) => {
            if (itm.contentItem.key === paths[1] && itm.onChangeScript !== undefined && itm.onChangeScript !== null && itm.onChangeScript !== '') {
              hash.push({
                holderPath: `holders.${index}`,
                pathItem: `holders.${index}.contentHolderLink.${idx}`,
                item: itm
              });
            }
          })
          return hash;
        }, []);
        setChanges(prev => {
          return uniqBy([
            ...prev,
            ...links
          ].reverse(), 'pathItem').reverse();
        });
      }
    });
    return () => unsubscribe();
  }, [watch, getValues]);

  const [holders] = watch(['holders']);

  const onSave = (data, event) => {
    return new Promise(async (resolve, reject) => {
      let toastHandler: ReturnType<typeof Toast.show> | null = null;
      try {
        const isDraft = event.target.dataset['action'] === "true";
        toastHandler?.close();
        toastHandler = Toast.show({
          icon: 'loading',
          content: t(isDraft ? 'MobileCreateDoc.loaderCreateDraft' : 'MobileCreateDoc.loaderCreateDoc'),
          duration: 0,
        });
        const freezePattern = await FilledDocumentPatternServiceClient.createAndCheckFilledDocumentPattern(
          token,
          new FreezeDocumentPattern({
            originalPatternId: pattern.id
          }),
          filter(data.stages, { changeOnDraft: true }),
          []
        );
        if (size(freezePattern?.exList) > 0 || freezePattern.fillPattern === null) {
          throw new PreconditionException(get(freezePattern, `exList.0`, {}));
        }
        const document = await DocumentServiceClient.createDocument(
          token,
          new ADocument({
            ...data.document,
            filledDocumentPattern: freezePattern.fillPattern,
          }),
          data.controlUsers,
          reduce(data.holders as ContentHolder[], (hash, item) => {
            return concat(hash, item.contentHolderLink?.map((itm: ContentHolderLink) => {
              const contentItem = get(data.contentItems, itm?.contentItem?.key, null);
              return new ContentHolderLink({
                ...itm,
                contentItem: contentItem !== null ? new ContentItem({
                  ...contentItem,
                  tableDefenition: contentItem.type === ContentItemType.TABLE ? new ContentTableDefinition({
                    ...contentItem?.tableDefenition,
                    columnDefenition: map(contentItem?.tableDefenition?.columnDefenition, itm => new ContentItem(itm))
                  }) : null,
                  childItems: map(contentItem?.childItems, itm => new ContentItem(itm)),
                  value: new ContentItemValue({
                    ...contentItem?.value,
                    strValue: contentItem?.value?.strValue && contentItem?.value?.strValue !== null ? String(contentItem?.value?.strValue) : null,
                    strValue2: contentItem?.value?.strValue2 && contentItem?.value?.strValue2 !== null ? String(contentItem?.value?.strValue2) : null,
                    hbValue: new ContentItemHBValue(contentItem?.value?.hbValue)
                  })
                }) : null
              });
            }));
          }, []),
          data.scGrifs?.reduce((prev, current) => {
            prev.add(current.id);
            return prev;
          }, new Set()),
          map(data.attachments, attachment => new AttCreateInfo({
            attachmentId: attachment.id,
            attachmentTemplateId: attachment.patternAttachmentTemplateId,
            fileName: attachment.fileName,
            forDraft: attachment.forDraft,
            editMode: AttachmentEditMode.MULTIPLE,
            attachmentExtStatus: attachment.attachmentExtStatus
          })),
          data.docRelations
        );
        if (!isDraft) {
          try {
            const permissions = await DocumentServiceClient.calculatePermissions(
              token,
              document.id,
              new DocumentAccessPolicy({
                type: DocumentAccessPolicyType.ACCESS
              })
            );
            const actions = filter(permissions.actions, action => {
              if (action?.canSetDecision === false || action?.additionConfirmation || action?.cancelDecision || action?.answerQuestion || action?.link?.allowRepeatDecision) return false;
              return action?.userOrGroupId === clientInfo?.id || action?.type === UserOrGroupType.GROUP;
            });
            if (actions?.length === 1) {
              await DocumentServiceClient.setDocumentDecision(
                token,
                document.id,
                actions[0].link.decision,
                '',
                true,
                '',
                actions[0].execId,
                [],
                [],
                new DocumentAccessPolicy({
                  type: DocumentAccessPolicyType.ACCESS
                }),
                new Map()
              )
            }
            sendMessageMobile('createDocument', document?.id);
          } catch (error) {
            sendMessageMobile('setDocumentDecision', document?.id);
          }
        } else {
          sendMessageMobile('createDraftDocument', document?.id);
        }
        resolve(document);
        toastHandler?.close();
      } catch (error) {
        toastHandler?.close();
        reject(error);
      }
    });
  };

  return (
    <>
      <FormStyled
        name="form"
        footer={
          <Space justify={"between"} block>
            <Button
              style={{ minWidth: 100 }}
              size="large"
              data-action={true}
              onClick={handleSubmit(onSave, (data) => {
                console.log(data)
              })}
            >
              {t('MobileCreateDoc.toDraft')}
            </Button>
            <Button
              style={{ minWidth: 100 }}
              type="submit"
              color="primary"
              size="large"
              data-action={false}
              onClick={handleSubmit(onSave, (data) => console.log(data))}
            >
              {t('MobileCreateDoc.create')}
            </Button>
          </Space>
        }
      >
        <div
          style={{
            fontSize: 12,
            fontWeight: 400,
            lineHeight: "20px",
            color: "rgba(0, 0, 0, 0.45)",
            padding: '0px 16px'
          }}
        >
          {account?.accountName} / {groupPattern?.nameDocPatGroup} /{" "}
          <span style={{ color: "#000000" }}>{pattern?.nameDocPattern}</span>
        </div>
        <TabsStyled defaultActiveKey={"info"}>
          <Tabs.Tab title={t('MobileCreateDoc.data')} key={"info"}>
            <TabInfo
              control={control}
              pattern={pattern}
              watch={watch}
              formEdit={docInfo?.formEdit}
              setChanges={setChanges}
              notRemoveScIds={map(docInfo?.scGrifs, itm => itm.id)}
            />
          </Tabs.Tab>
          {map(holders, (holder: ContentHolder, index: number) => {
            return <Fragment key={holder.id}>
              {holder.showInInfo === false && <Tabs.Tab title={holder.oName} key={holder.id}>
                <Holder
                  holder={holder}
                  name={`holders.${index}`}
                  control={control}
                  setChanges={setChanges}
                  patternId={pattern.id}
                />
              </Tabs.Tab>}
            </Fragment>
          })}
          <Tabs.Tab title={t('MobileCreateDoc.attachments')} key={"atts"}>
            <UploadAttAndPatternTemplate
              name={"attachments"}
              control={control}
              pattern={pattern}
              allowSubStatuses={[AttachmentExtStatus.PRIMARY, AttachmentExtStatus.SECONDARY]}
            />
          </Tabs.Tab>

          <Tabs.Tab title={t('MobileCreateDoc.stages')} key={"stages"}>
            <Stages
              name={"stages"}
              control={control}
              pattern={pattern}
            />
          </Tabs.Tab>
        </TabsStyled>
      </FormStyled>
    </>
  );
};

export default Step2;
